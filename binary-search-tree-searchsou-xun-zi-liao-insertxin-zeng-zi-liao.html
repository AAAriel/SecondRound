<!DOCTYPE html>
<html lang="zh-hant">
<head>
  <link href='//fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,700,400italic' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" type="text/css" href="http://alrightchiu.github.io/SecondRound/theme/css/style.min.css">
  <link rel="stylesheet" type="text/css" href="http://alrightchiu.github.io/SecondRound/theme/css/pygments.min.css">
  <link rel="stylesheet" type="text/css" href="http://alrightchiu.github.io/SecondRound/theme/css/font-awesome.min.css">
  <link href="http://alrightchiu.github.io/SecondRound/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Ordinary Days Atom">

  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="robots" content="" />
<meta name="author" content="Chiu CC" />
<meta name="description" content="介紹Binary Search Tree的基本操作：Search(搜尋資料)與Insert(新增資料)。" />
<meta name="keywords" content="C++">
<meta property="og:site_name" content="Ordinary Days"/>
<meta property="og:title" content="Binary Search Tree: Search(搜尋資料)、Insert(新增資料)"/>
<meta property="og:description" content="介紹Binary Search Tree的基本操作：Search(搜尋資料)與Insert(新增資料)。"/>
<meta property="og:locale" content="zh_TW"/>
<meta property="og:url" content="http://alrightchiu.github.io/SecondRound/binary-search-tree-searchsou-xun-zi-liao-insertxin-zeng-zi-liao.html"/>
<meta property="og:type" content="article"/>
<meta property="article:published_time" content="2016-01-03 20:17:00+08:00"/>
<meta property="article:modified_time" content=""/>
<meta property="article:author" content="http://alrightchiu.github.io/SecondRound/author/chiu-cc.html">
<meta property="article:section" content="演算法與資料結構"/>
<meta property="article:tag" content="C++"/>
<meta property="og:image" content="http://alrightchiu.github.io/SecondRound/fig/antiwar.jpg">  <title>Ordinary Days &ndash; Binary Search Tree: Search(搜尋資料)、Insert(新增資料)</title>
</head>
<body>
  <aside>
    <div>
      <a href="http://alrightchiu.github.io/SecondRound">
        <img src="http://alrightchiu.github.io/SecondRound/fig/antiwar.jpg" alt="Ordinary Days" title="Ordinary Days">
      </a>
      <h1><a href="http://alrightchiu.github.io/SecondRound">Ordinary Days</a></h1>
      <p>Hey</p>
      <nav>
        <ul class="list">
          <li><a href="http://alrightchiu.github.io/SecondRound/pages/about.html#about">About</a></li>
        </ul>
      </nav>
      <ul class="social">
        <li><a class="sc-github" href="https://github.com/alrightchiu" target="_blank"><i class="fa fa-github"></i></a></li>
      </ul>
    </div>
  </aside>
  <main>
    <nav>
      <a href="http://alrightchiu.github.io/SecondRound">Home</a>
      <a href="http://alrightchiu.github.io/SecondRound/archives.html">Archives</a>
      <a href="http://alrightchiu.github.io/SecondRound/categories.html">Categories</a>
      <a href="http://alrightchiu.github.io/SecondRound/tags.html">Tags</a>
      <a href="http://alrightchiu.github.io/SecondRound/feeds/all.atom.xml">Atom</a>
    </nav>

<article>
  <header>
    <h1 id="binary-search-tree-searchsou-xun-zi-liao-insertxin-zeng-zi-liao">Binary Search Tree: Search(搜尋資料)、Insert(新增資料)</h1>
    <p>Posted on  1 03, 2016 in <a href="http://alrightchiu.github.io/SecondRound/category/yan-suan-fa-yu-zi-liao-jie-gou.html">演算法與資料結構</a></p>
  </header>
  <div>
    <p></br></p>
<h6><strong>先備知識與注意事項</strong></h6>
<p>在開始介紹search(搜尋資料)與insert(新增資料)之前，先定義好<code>class TreeNode</code>與<code>class BST</code>，順便對未來將介紹的其他member function(成員函式)留下美好的第一印象：</p>
<div class="highlight"><pre><span class="code-line"><span class="c1">// C++ code</span></span>
<span class="code-line"><span class="cp">#include &lt;iostream&gt;</span></span>
<span class="code-line"><span class="cp">#include &lt;string&gt;</span></span>
<span class="code-line"><span class="k">class</span> <span class="nc">BST</span><span class="p">;</span></span>
<span class="code-line"><span class="k">class</span> <span class="nc">TreeNode</span><span class="p">{</span></span>
<span class="code-line"><span class="k">private</span><span class="o">:</span></span>
<span class="code-line">    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">leftchild</span><span class="p">;</span></span>
<span class="code-line">    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">rightchild</span><span class="p">;</span></span>
<span class="code-line">    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span></span>
<span class="code-line">    <span class="kt">int</span> <span class="n">key</span><span class="p">;</span></span>
<span class="code-line">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">element</span><span class="p">;</span></span>
<span class="code-line"><span class="k">public</span><span class="o">:</span></span>
<span class="code-line">    <span class="c1">// constructor</span></span>
<span class="code-line">    <span class="n">TreeNode</span><span class="p">()</span><span class="o">:</span><span class="n">key</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">element</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">){</span></span>
<span class="code-line">        <span class="n">leftchild</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">rightchild</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">parent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></span>
<span class="code-line">    <span class="p">}</span></span>
<span class="code-line">    <span class="n">TreeNode</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">b</span><span class="p">)</span><span class="o">:</span><span class="n">key</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">element</span><span class="p">(</span><span class="n">b</span><span class="p">){</span></span>
<span class="code-line">        <span class="n">leftchild</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">rightchild</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">parent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></span>
<span class="code-line">    <span class="p">}</span></span>
<span class="code-line">    <span class="c1">// default copy constructor</span></span>
<span class="code-line">    <span class="c1">// default destructor</span></span>
<span class="code-line"></span>
<span class="code-line">    <span class="kt">int</span> <span class="n">GetKey</span><span class="p">()</span> <span class="k">const</span><span class="p">{</span> <span class="k">return</span> <span class="n">key</span><span class="p">;};</span></span>
<span class="code-line">    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">GetElement</span><span class="p">()</span> <span class="k">const</span><span class="p">{</span> <span class="k">return</span> <span class="n">element</span><span class="p">;};</span></span>
<span class="code-line"></span>
<span class="code-line">    <span class="kt">void</span> <span class="nf">SetKey</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="p">){</span> <span class="n">key</span> <span class="o">=</span> <span class="n">k</span><span class="p">;};</span></span>
<span class="code-line">    <span class="kt">void</span> <span class="nf">SetElement</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">e</span><span class="p">){</span> <span class="n">element</span> <span class="o">=</span> <span class="n">e</span><span class="p">;};</span>   </span>
<span class="code-line"></span>
<span class="code-line">    <span class="k">friend</span> <span class="k">class</span> <span class="nc">BST</span><span class="p">;</span>   <span class="c1">// 放在 private 或 public 都可以 </span></span>
<span class="code-line"><span class="p">};</span></span>
<span class="code-line"></span>
<span class="code-line"><span class="c1">// class BST</span></span>
<span class="code-line"><span class="k">class</span> <span class="nc">BST</span><span class="p">{</span></span>
<span class="code-line"><span class="k">private</span><span class="o">:</span></span>
<span class="code-line">    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">root</span><span class="p">;</span></span>
<span class="code-line">    <span class="n">TreeNode</span><span class="o">*</span> <span class="nf">Rightmost</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">current</span><span class="p">);</span></span>
<span class="code-line">    <span class="n">TreeNode</span><span class="o">*</span> <span class="nf">Leftmost</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">current</span><span class="p">);</span></span>
<span class="code-line">    <span class="n">TreeNode</span><span class="o">*</span> <span class="nf">Copy</span><span class="p">(</span><span class="k">const</span> <span class="n">TreeNode</span> <span class="o">*</span><span class="n">origNode</span><span class="p">);</span>    <span class="c1">// preorder traversal, 用在 copy constructor和 operator=</span></span>
<span class="code-line">    <span class="kt">void</span> <span class="nf">PostorderDelete</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">current</span><span class="p">);</span></span>
<span class="code-line"><span class="k">public</span><span class="o">:</span></span>
<span class="code-line">    <span class="n">BST</span><span class="p">(){</span> <span class="n">root</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">};</span>     <span class="c1">// default constructor</span></span>
<span class="code-line">    <span class="n">BST</span><span class="p">(</span><span class="k">const</span> <span class="n">BST</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">);</span>      <span class="c1">// copy constructor</span></span>
<span class="code-line">    <span class="n">BST</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="n">BST</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">);</span></span>
<span class="code-line">    <span class="o">~</span><span class="n">BST</span><span class="p">();</span>  <span class="c1">// destructor</span></span>
<span class="code-line"></span>
<span class="code-line">    <span class="n">TreeNode</span><span class="o">*</span> <span class="nf">Search</span><span class="p">(</span><span class="kt">int</span> <span class="n">key</span><span class="p">);</span></span>
<span class="code-line">    <span class="kt">void</span> <span class="nf">InsertBST</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">&amp;</span><span class="n">new_node</span><span class="p">);</span></span>
<span class="code-line"></span>
<span class="code-line">    <span class="n">TreeNode</span><span class="o">*</span> <span class="nf">Successor</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">current</span><span class="p">);</span></span>
<span class="code-line">    <span class="n">TreeNode</span><span class="o">*</span> <span class="nf">Predecessor</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">current</span><span class="p">);</span></span>
<span class="code-line">    <span class="kt">void</span> <span class="nf">InorderPrint</span><span class="p">();</span></span>
<span class="code-line">    <span class="kt">void</span> <span class="nf">DeleteBST</span><span class="p">(</span><span class="kt">int</span> <span class="n">KEY</span><span class="p">);</span></span>
<span class="code-line"></span>
<span class="code-line">    <span class="kt">bool</span> <span class="nf">IsEmpty</span><span class="p">()</span> <span class="k">const</span><span class="p">{</span><span class="k">return</span> <span class="p">(</span><span class="n">root</span><span class="o">==</span><span class="nb">NULL</span><span class="p">);};</span>    <span class="c1">// 確認BST是否存有資料</span></span>
<span class="code-line"><span class="p">};</span></span>
</pre></div>


<p>文章內容將著重於BST這個資料結構，並提供此資料結構中可行的演算法，因此，有關C++的實作方法並不唯一，筆者相信有更優秀的寫法(有效利用記憶體、避免memory leak(記憶體洩漏)等議題)，建議讀者可以多多參考例如<a href="http://codereview.stackexchange.com/">Stack Exchange:Code Review</a>等等眾多優秀的網站，看網友的程式碼的寫法以及由該份程式碼所開啟的討論串，應該會對實際寫作技巧有些幫助。<br />
(筆者也還在學啊啊啊啊)</p>
<p>另外，用以測試的<code>main()</code>將在BST系列的演算法都介紹完後登場。</p>
<hr />
<h2>目錄</h2>
<ul>
<li><a href="#search">BST::Search(搜尋)</a></li>
<li><a href="#insert">BST::Insert(新增資料)</a></li>
<li><a href="#main">main()</a></li>
<li><a href="#ref">參考資料</a></li>
</ul>
<p><a name="search"></a></p>
<h2><strong>BST::Search(搜尋)</strong></h2>
<p>BST的<code>Search()</code>操作，便是根據BST的特徵：<span class="math">\(Key(L)&lt;Key(Current)&lt;Key(R)\)</span>，判斷<code>Current</code>node應該往left subtree走，還是往right subtree走。</p>
<p>現有一棵BST如圖一(a)所示：</p>
<p><center>
<img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/search_insert/f18.png?raw=true" /></p>
<p><strong>圖一(a)：。</strong><br />
</center>   </p>
<p>搜尋結果可能成功，可能失敗，以下便分別以兩個KEY值作說明。</p>
<h4>搜尋成功</h4>
<ul>
<li>若現在要從BST中搜尋基紐隊長，便以基紐隊長的KEY(627)進入BST。<br />
進入BST後，便把用來移動的<code>Current</code>node指向<code>root</code>，如圖一(b)。  </li>
</ul>
<p><center>
<img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/search_insert/f19.png?raw=true" /></p>
<p><strong>圖一(b)：。</strong><br />
</center> </p>
<ul>
<li>此時，便將KEY(627)和比克(<code>root</code>)的戰鬥力(513)比較，結果是基紐隊長戰勝，因此，基紐隊長如果在BST裡面，應該會長在比克的right subtree，於是便將<code>Current</code>往比克的right child(達爾)移動，如圖一(c)。</li>
</ul>
<p><center>
<img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/search_insert/f20.png?raw=true" /></p>
<p><strong>圖一(c)：。</strong><br />
</center> </p>
<ul>
<li>將<code>Current</code>移動到達爾之後，再將KEY(627)與達爾的戰鬥力(524)比較，結果仍然是基紐隊長大勝，因此步驟同上，繼續將<code>Current</code>往達爾的right child(弗力札)移動，如圖一(d)。</li>
</ul>
<p><center>
<img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/search_insert/f21.png?raw=true" /></p>
<p><strong>圖一(d)：。</strong><br />
</center> </p>
<ul>
<li>將<code>Current</code>移動到弗力札之後，再將KEY(627)與弗力札的戰鬥力(709)比較，結果是弗力札略勝，於是便往弗力札的left child尋找基紐隊長，如圖一(e)。</li>
</ul>
<p><center>
<img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/search_insert/f22.png?raw=true" /></p>
<p><strong>圖一(e)：。</strong><br />
</center></p>
<ul>
<li>此時，<code>Current</code>的Key(627)與傳送進<code>Search()</code>的KEY(627)相同，便確認<code>Current</code>即為基紐隊長，於是跳出<code>while</code>迴圈，並傳回<code>Current</code>。<br />
即搜尋成功。</li>
</ul>
<h4>搜尋失敗</h4>
<ul>
<li>若現在要從BST中尋找克林，便以克林的戰鬥力(2)為KEY(2)，進入<code>Search()</code>。<br />
進入BST後，同樣把用來移動的<code>Current</code>node指向<code>root</code>，如圖一(b)。</li>
</ul>
<p><center>
<img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/search_insert/f19.png?raw=true" /></p>
<p><strong>圖一(b)：。</strong><br />
</center> </p>
<ul>
<li>接著便將KEY(2)和比克的戰鬥力(513)比較，結果是比克勝出，於是將<code>Currnet</code>往比克的left child(龜仙人)移動，如圖一(f)。</li>
</ul>
<p><center>
<img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/search_insert/f23.png?raw=true" /></p>
<p><strong>圖一(f)：。</strong><br />
</center> </p>
<ul>
<li>將<code>Current</code>移動至龜仙人後，將KEY(2)和龜仙人的戰鬥力(8)比較，便判斷出，要將<code>Current</code>往龜仙人的left child移動，如圖一(f)。<br />
然而，由於龜仙人沒有left child，於是<code>Current</code>指向<code>NULL</code>，便跳出迴圈，並回傳<code>NULL</code>，即表示搜尋失敗，克林不在BST中。</li>
</ul>
<p>以下是<code>BST::Search()</code>的範例程式碼，其中，有兩種情況會跳出<code>while</code>迴圈：</p>
<ol>
<li>KEY與<code>Current</code>node的key相同，表示搜尋成功；</li>
<li><code>Current</code>移動到<code>NULL</code>，表示搜尋失敗。</li>
</ol>
<div class="highlight"><pre><span class="code-line"><span class="c1">// C++ code</span></span>
<span class="code-line"><span class="n">TreeNode</span><span class="o">*</span> <span class="n">BST</span><span class="o">::</span><span class="n">Search</span><span class="p">(</span><span class="kt">int</span> <span class="n">KEY</span><span class="p">){</span></span>
<span class="code-line">    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">current</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">;</span></span>
<span class="code-line">    <span class="n">current</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span></span>
<span class="code-line">    <span class="k">while</span> <span class="p">(</span><span class="n">current</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">KEY</span> <span class="o">!=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">GetKey</span><span class="p">())</span> <span class="p">{</span></span>
<span class="code-line">        <span class="k">if</span> <span class="p">(</span><span class="n">KEY</span> <span class="o">&lt;</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">GetKey</span><span class="p">())</span></span>
<span class="code-line">            <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">leftchild</span><span class="p">;</span>   <span class="c1">// 向左走</span></span>
<span class="code-line">        <span class="k">else</span></span>
<span class="code-line">            <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">rightchild</span><span class="p">;</span>  <span class="c1">// 向右走</span></span>
<span class="code-line">    <span class="p">}</span></span>
<span class="code-line">    <span class="k">return</span> <span class="n">current</span><span class="p">;</span></span>
<span class="code-line"><span class="p">}</span></span>
</pre></div>


<p></br> 
<a name="insert"></a></p>
<h2><strong>BST::InsertBST(新增資料)</strong></h2>
<p>函式<code>InsertBST()</code>的演算法概念，可以視為<code>Search()</code>的延伸：</p>
<ol>
<li>根據BST對Key之規則，先找到「將要新增之node」適合的位置；</li>
<li>再將欲新增的node接上BST。</li>
</ol>
<p>要尋找「對新增node而言的適當位置」，需要召喚一位「哨兵」先行探路，而「將會成為新增node的<strong>parent node</strong>(準新手爸媽)」則跟著「哨兵」的腳步，往前推進。 </p>
<p>定義「哨兵」為<strong>x</strong>，「準新手爸媽」為<strong>y</strong>，現欲新增「比克，戰鬥力(513)」進入如圖二(a)之BST。<br />
(這裡的「哨兵<strong>x</strong>」具有<code>BST::Search()</code>中<code>Current</code>node的功能。)</p>
<p><center>
<img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/search_insert/f24.png?raw=true" /></p>
<p><strong>圖二(a)：。</strong><br />
</center> </p>
<ul>
<li>如圖二(a)，剛進入BST時，「哨兵<strong>x</strong>」進到<code>root</code>，而「準新手爸媽<strong>y</strong>」即為<code>root</code>的parent，即為<code>NULL</code>。  </li>
<li>接著，將欲新增node之Key(比克(513))與「哨兵<strong>x</strong>」之Key(龜仙人(8))相比，比克的戰鬥力比龜仙人高，所以比克應該要長在龜仙人的right subtree，因此把「哨兵<strong>x</strong>」往龜仙人的right child(悟空)移動，並且更新「準新手爸媽<strong>y</strong>」為龜仙人，如圖二(b)。</li>
</ul>
<p><center>
<img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/search_insert/f25.png?raw=true" /></p>
<p><strong>圖二(b)：。</strong><br />
</center> </p>
<ul>
<li>接著，繼續比較欲新增node之Key(比克(513))與「哨兵<strong>x</strong>」之Key(悟空(1000))，結果是悟空的戰鬥力較高，比克應該要長在悟空的left subtree，因此，將「哨兵<strong>x</strong>」往悟空的left child(<code>NULL</code>)移動，同時更新「準新手爸媽<strong>y</strong>」為悟空，如圖二(c)。</li>
<li>更新後，「準新手爸媽<strong>y</strong>」成為悟空，「哨兵<strong>x</strong>」指向<code>NULL</code>壯烈犧牲，即達到跳出迴圈之條件。此時，便找到了「新增node」之適當位置。<br />
那個「適當位置」在哪裡呢？就是「準新手爸媽<strong>y</strong>」的child pointer。</li>
</ul>
<p><center>
<img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/search_insert/f26.png?raw=true" /></p>
<p><strong>圖二(c)：。</strong><br />
</center> </p>
<ul>
<li>下一步，便是比較欲新增node之Key(比克(513))與「準新手爸媽<strong>y</strong>」之Key(悟空(1000))，發現悟空戰鬥力較高，因此，比克(513)便成為「準新手爸媽<strong>y</strong>」的left child，如圖二(d)，便成功把比克(513)接到BST上。</li>
</ul>
<p><center>
<img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/search_insert/f27.png?raw=true" /></p>
<p><strong>圖二(d)：。</strong><br />
</center> </p>
<p>以下是<code>BST::InsertBST()</code>的範例程式碼，關鍵便是「哨兵<strong>x</strong>」與「準新手爸媽<strong>y</strong>」的冒險之旅：</p>
<div class="highlight"><pre><span class="code-line"><span class="c1">// C++ code</span></span>
<span class="code-line"><span class="kt">void</span> <span class="n">BST</span><span class="o">::</span><span class="n">InsertBST</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">&amp;</span><span class="n">new_node</span><span class="p">){</span></span>
<span class="code-line">    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">y</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">;</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></span>
<span class="code-line">    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">x</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">;</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></span>
<span class="code-line">    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">insert_node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">new_node</span><span class="p">);</span> <span class="c1">// call default copy constructor of TreeNode</span></span>
<span class="code-line"></span>
<span class="code-line">    <span class="n">x</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span></span>
<span class="code-line">    <span class="k">while</span> <span class="p">(</span><span class="n">x</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span></span>
<span class="code-line">        <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span></span>
<span class="code-line">        <span class="k">if</span> <span class="p">(</span><span class="n">insert_node</span><span class="o">-&gt;</span><span class="n">GetKey</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">GetKey</span><span class="p">())</span></span>
<span class="code-line">            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">leftchild</span><span class="p">;</span></span>
<span class="code-line">        <span class="k">else</span></span>
<span class="code-line">            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">rightchild</span><span class="p">;</span></span>
<span class="code-line">    <span class="p">}</span></span>
<span class="code-line">    <span class="n">insert_node</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span></span>
<span class="code-line">    <span class="k">if</span> <span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span></span>
<span class="code-line">        <span class="k">this</span><span class="o">-&gt;</span><span class="n">root</span> <span class="o">=</span> <span class="n">insert_node</span><span class="p">;</span></span>
<span class="code-line">    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">insert_node</span><span class="o">-&gt;</span><span class="n">GetKey</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">y</span><span class="o">-&gt;</span><span class="n">GetKey</span><span class="p">())</span></span>
<span class="code-line">        <span class="n">y</span><span class="o">-&gt;</span><span class="n">leftchild</span> <span class="o">=</span> <span class="n">insert_node</span><span class="p">;</span></span>
<span class="code-line">    <span class="k">else</span></span>
<span class="code-line">        <span class="n">y</span><span class="o">-&gt;</span><span class="n">rightchild</span> <span class="o">=</span> <span class="n">insert_node</span><span class="p">;</span></span>
<span class="code-line"><span class="p">}</span></span>
</pre></div>


<p>備註：  </p>
<ul>
<li>在定義函式<code>InsertBST()</code>時，函式的參數(argument)可能會視情境而有所改變，這裡是以一個<code>TreeNode</code>的物件(object)之<strong>reference</strong>作為參數，傳進函式<code>InsertBST()</code>。</li>
<li>在<code>InsertBST()</code>特別標示出BST是為了與之後會介紹的Red Black Tree(紅黑樹)之<code>InsertRBT()</code>做區別。</li>
</ul>
<p><a name="main"></a></p>
<h2><strong>main()</strong></h2>
<p>有了<code>BST::InsertBST()</code>後，就可以用土法煉鋼的方式建立一棵如圖二(d)的BST:</p>
<div class="highlight"><pre><span class="code-line"><span class="c1">// C++ code</span></span>
<span class="code-line"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span></span>
<span class="code-line">    <span class="n">BST</span> <span class="n">b1</span><span class="p">;</span></span>
<span class="code-line">    <span class="n">TreeNode</span> <span class="n">n1</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="s">&quot;龜仙人&quot;</span><span class="p">);</span></span>
<span class="code-line">    <span class="n">TreeNode</span> <span class="n">n2</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span><span class="s">&quot;悟空&quot;</span><span class="p">);</span></span>
<span class="code-line">    <span class="n">TreeNode</span> <span class="n">n3</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="s">&quot;克林&quot;</span><span class="p">);</span></span>
<span class="code-line">    <span class="n">TreeNode</span> <span class="n">n4</span><span class="p">(</span><span class="mi">513</span><span class="p">,</span><span class="s">&quot;比克&quot;</span><span class="p">);</span></span>
<span class="code-line">    <span class="n">b1</span><span class="p">.</span><span class="n">InsertBST</span><span class="p">(</span><span class="n">n1</span><span class="p">);</span></span>
<span class="code-line">    <span class="n">b1</span><span class="p">.</span><span class="n">InsertBST</span><span class="p">(</span><span class="n">n2</span><span class="p">);</span></span>
<span class="code-line">    <span class="n">b1</span><span class="p">.</span><span class="n">InsertBST</span><span class="p">(</span><span class="n">n3</span><span class="p">);</span></span>
<span class="code-line">    <span class="n">b1</span><span class="p">.</span><span class="n">InsertBST</span><span class="p">(</span><span class="n">n4</span><span class="p">);</span></span>
<span class="code-line">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span></span>
<span class="code-line"><span class="p">}</span></span>
</pre></div>


<p>以上便是BST中<code>Search()</code>與<code>InsertBST()</code>之介紹，只要掌握BST的性質<span class="math">\(Key(L)&lt;Key(Current)&lt;Key(R)\)</span>與樹中的Traversal(pointer的移動)即可輕鬆上路。 </p>
<p></br>
<a name="ref"></a></p>
<h6><strong>參考資料</strong>：</h6>
<ul>
<li><a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844">Introduction to Algorithms</a> </li>
<li><a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376">Fundamentals of Data Structures in C++</a></li>
</ul>
<p></br></p>
<script type="text/javascript">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width < 768) ? "left" : align;
        indent = (screen.width < 768) ? "0em" : indent;
        linebreak = (screen.width < 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' && location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
</script>
  </div>
  <div class="tag-cloud">
    <p>
      <a href="http://alrightchiu.github.io/SecondRound/tag/c.html">C++</a>
    </p>
  </div>
</article>

    <footer>
<p>
  &copy; Chiu CC  - This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>
</p>
<p>Built using <a href="http://getpelican.com" target="_blank">Pelican</a> - <a href="https://github.com/alexandrevicenzi/flex" target="_blank">Flex</a> theme by <a href="http://alexandrevicenzi.com" target="_blank">Alexandre Vicenzi</a></p><p>
  <a rel="license"
     href="http://creativecommons.org/licenses/by-sa/4.0/"
     target="_blank">
    <img alt="Creative Commons License"
         title="Creative Commons License"
         style="border-width:0"
         src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png"
         width="80"
         height="15"/>
  </a>
</p>    </footer>
  </main>





<script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "BlogPosting",
  "name": "Binary Search Tree: Search(搜尋資料)、Insert(新增資料)",
  "headline": "Binary Search Tree: Search(搜尋資料)、Insert(新增資料)",
  "datePublished": "2016-01-03 20:17:00+08:00",
  "dateModified": "",
  "author": {
    "@type": "Person",
    "name": "Chiu CC",
    "url": "http://alrightchiu.github.io/SecondRound/author/chiu-cc.html"
  },
  "image": "http://alrightchiu.github.io/SecondRound/fig/antiwar.jpg",
  "url": "http://alrightchiu.github.io/SecondRound/binary-search-tree-searchsou-xun-zi-liao-insertxin-zeng-zi-liao.html",
  "description": "介紹Binary Search Tree的基本操作：Search(搜尋資料)與Insert(新增資料)。"
}
</script></body>
</html>