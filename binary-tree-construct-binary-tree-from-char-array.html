<!DOCTYPE html>
<html lang="zh-hant">
<head>
  <link href='//fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,700,400italic' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" type="text/css" href="http://alrightchiu.github.io/SecondRound/theme/css/style.min.css">
  <link rel="stylesheet" type="text/css" href="http://alrightchiu.github.io/SecondRound/theme/css/pygments.min.css">
  <link rel="stylesheet" type="text/css" href="http://alrightchiu.github.io/SecondRound/theme/css/font-awesome.min.css">
  <link href="http://alrightchiu.github.io/SecondRound/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Ordinary Days Atom">

  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="robots" content="" />
<meta name="author" content="Chiu CC" />
<meta name="description" content="介紹Binary Tree中的Traversal(尋訪)。" />
<meta name="keywords" content="今天不寫明天就忘了">
<meta property="og:site_name" content="Ordinary Days"/>
<meta property="og:title" content="Binary Tree: Construct Binary Tree from char array"/>
<meta property="og:description" content="介紹Binary Tree中的Traversal(尋訪)。"/>
<meta property="og:locale" content="zh_TW"/>
<meta property="og:url" content="http://alrightchiu.github.io/SecondRound/binary-tree-construct-binary-tree-from-char-array.html"/>
<meta property="og:type" content="article"/>
<meta property="article:published_time" content="2015-12-19 20:27:00+08:00"/>
<meta property="article:modified_time" content=""/>
<meta property="article:author" content="http://alrightchiu.github.io/SecondRound/author/chiu-cc.html">
<meta property="article:section" content="演算法與資料結構"/>
<meta property="article:tag" content="今天不寫明天就忘了"/>
<meta property="og:image" content="http://alrightchiu.github.io/SecondRound/fig/antiwar.jpg">  <title>Ordinary Days &ndash; Binary Tree: Construct Binary Tree from char array</title>
</head>
<body>
  <aside>
    <div>
      <a href="http://alrightchiu.github.io/SecondRound">
        <img src="http://alrightchiu.github.io/SecondRound/fig/antiwar.jpg" alt="Ordinary Days" title="Ordinary Days">
      </a>
      <h1><a href="http://alrightchiu.github.io/SecondRound">Ordinary Days</a></h1>
      <p>Hey</p>
      <nav>
        <ul class="list">
          <li><a href="http://alrightchiu.github.io/SecondRound/pages/about.html#about">About</a></li>
        </ul>
      </nav>
      <ul class="social">
        <li><a class="sc-github" href="https://github.com/alrightchiu" target="_blank"><i class="fa fa-github"></i></a></li>
      </ul>
    </div>
  </aside>
  <main>
    <nav>
      <a href="http://alrightchiu.github.io/SecondRound">Home</a>
      <a href="http://alrightchiu.github.io/SecondRound/archives.html">Archives</a>
      <a href="http://alrightchiu.github.io/SecondRound/categories.html">Categories</a>
      <a href="http://alrightchiu.github.io/SecondRound/tags.html">Tags</a>
      <a href="http://alrightchiu.github.io/SecondRound/feeds/all.atom.xml">Atom</a>
    </nav>

<article>
  <header>
    <h1 id="binary-tree-construct-binary-tree-from-char-array">Binary Tree: Construct Binary Tree from char array</h1>
    <p>Posted on 12 19, 2015 in <a href="http://alrightchiu.github.io/SecondRound/category/yan-suan-fa-yu-zi-liao-jie-gou.html">演算法與資料結構</a></p>
  </header>
  <div>
    <p></br></p>
<h6><strong>先備知識與注意事項</strong></h6>
<p>在<a href="http://alrightchiu.github.io/SecondRound/binary-tree-traversal.html#ex_code">Binary Tree：Traversal</a>中，非常沒誠意地用暴力方式建了一棵Binary Tree，在這裡至上深深歉意，因此，在本篇文章將提供一種方法，由一個字串陣列(char array)輸入字母，並按照<a href="http://alrightchiu.github.io/SecondRound/binary-tree-intro.html#fullcomplete">Complete Binary Tree</a>之順序重新建立<strong>那顆樹</strong>。(一種不健康的雪恥心態)</p>
<p>其中，問題情境之原始資料是一個字串陣列(char array)，為了方便處理(偷懶)選擇使用C++語言中的神器：<a href="http://www3.ntu.edu.sg/home/ehchua/programming/cpp/cp10_io.html">stringstream</a>，這裡礙於篇幅與主題(與筆者自己也還在摸索)，就不多談避免誤導，點進連結中有非常詳細的說明，關於<code>istringstream</code>、<code>ostringstream</code>、<code>stringstream</code>等等template class之繼承關係(inheritance)。<br />
重點是，<code>stringstream</code>就是神，就是行，學起來簡直光宗耀祖。</p>
<p>以及，以下提供的Binary Tree之建立方法，基本上是在<a href="http://alrightchiu.github.io/SecondRound/binary-tree-traversal.html#ex_code">Binary Tree：Traversal介紹過的level-order traversal</a>上加油添醋，因此<a href="https://en.wikipedia.org/wiki/Queue_%28abstract_data_type%29">queue(佇列)</a>的概念會再次出現。</p>
<p></br></p>
<h2>目錄</h2>
<ul>
<li><a href="#description">問題描述</a></li>
<li>
<p><a href="#code">程式碼</a>  </p>
<ul>
<li><a href="#def">定義class TreeNode、class BinaryTree</a> </li>
<li><a href="#constructor">Constructor of BinaryTree</a> </li>
<li><a href="#func1">Function：LevelorderConstruct()</a></li>
<li><a href="#func2">Function：insertLevelorder()</a></li>
</ul>
</li>
<li>
<p><a href="#ref">參考資料</a></p>
</li>
<li></li>
</ul>
<p><a name="description"></a></p>
<h2><strong>問題描述</strong></h2>
<p>問題描述如下：</p>
<ul>
<li>給定一個字串陣列，欲按照Complete Binary Tree之位置規則建立一棵Binary Tree，若陣列元素之資料為大寫字母(ASCII：65~90)，則將其建立成Tree的node，若陣列元素為 ' x ' 則表示該位置沒有node。</li>
</ul>
<p>以<a href="http://alrightchiu.github.io/SecondRound/binary-tree-traversal.html#ex_code">Binary Tree：Traversal</a>中所提到的Binary Tree為例，如圖一：
</br><br />
<center>
<img alt="binary tree" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/ex.png?raw=true" /></p>
<p><strong>圖一：。</strong><br />
</center>   </p>
<p>其所對應的字串陣列即為：<code>A B C D E F x x x G H x I</code>，如圖二所示：</p>
<p><center>
<img alt="binary tree of char array" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/ex_char.png?raw=true" /></p>
<p><strong>圖二：。</strong><br />
</center> </p>
<p>以下程式範例的目的就是要以如此文明的方式建立出如圖一的Binary Tree。</p>
<p><a name="code"></a></p>
<h2><strong>程式碼</strong></h2>
<p>先看看<code>main()</code>中，上半部分別為</p>
<ul>
<li>原始資料：字串陣列</li>
<li>以該字串陣列實體化(instantiate)一棵Binary Tree</li>
<li>以inorder traversal印出樹的資料</li>
</ul>
<p>溫馨小提醒：純粹以inorder traversal之結果並無法驗證樹之結構正如圖一(舉例來說：以inorder traversal對某一Linked list也可能得出相同結果)，因此，建議還是使用IDE的debug功能把pointer全部攤開。</p>
<div class="highlight"><pre><span class="code-line"><span class="c1">// C++ code</span></span>
<span class="code-line"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span></span>
<span class="code-line">    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="s">&quot;A B C D E F x x x G H x I&quot;</span><span class="p">;</span></span>
<span class="code-line">    <span class="n">BinaryTree</span> <span class="n">T</span><span class="p">(</span><span class="n">a</span><span class="p">);</span></span>
<span class="code-line">    <span class="n">T</span><span class="p">.</span><span class="n">Inorder_by_parent</span><span class="p">();</span></span>
<span class="code-line">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span></span>
<span class="code-line"></span>
<span class="code-line">    <span class="n">T</span><span class="p">.</span><span class="n">insertLevelorder</span><span class="p">(</span><span class="sc">&#39;K&#39;</span><span class="p">);</span></span>
<span class="code-line">    <span class="n">T</span><span class="p">.</span><span class="n">insertLevelorder</span><span class="p">(</span><span class="sc">&#39;L&#39;</span><span class="p">);</span></span>
<span class="code-line">    <span class="n">T</span><span class="p">.</span><span class="n">insertLevelorder</span><span class="p">(</span><span class="sc">&#39;M&#39;</span><span class="p">);</span></span>
<span class="code-line">    <span class="n">T</span><span class="p">.</span><span class="n">insertLevelorder</span><span class="p">(</span><span class="sc">&#39;N&#39;</span><span class="p">);</span></span>
<span class="code-line">    <span class="n">T</span><span class="p">.</span><span class="n">Inorder_by_parent</span><span class="p">();</span></span>
<span class="code-line">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span></span>
<span class="code-line"></span>
<span class="code-line">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span></span>
<span class="code-line"><span class="p">}</span></span>
</pre></div>


<p>在經過一連串程式碼後，預期得到的output：</p>
<div class="highlight"><pre><span class="code-line"><span class="n">D</span> <span class="n">B</span> <span class="n">G</span> <span class="n">E</span> <span class="n">H</span> <span class="n">A</span> <span class="n">F</span> <span class="n">I</span> <span class="n">C</span>   </span>
<span class="code-line"><span class="n">L</span> <span class="n">D</span> <span class="n">M</span> <span class="n">B</span> <span class="n">G</span> <span class="n">E</span> <span class="n">H</span> <span class="n">A</span> <span class="n">N</span> <span class="n">F</span> <span class="n">I</span> <span class="n">C</span> <span class="n">K</span>    </span>
</pre></div>


<p></br> </p>
<p><a name="def"></a></p>
<h4><strong>定義class TreeNode、class BinaryTree</strong></h4>
<p>幾點說明：</p>
<ul>
<li>
<p>這裡對<code>class TreeNode</code>與<code>class BinaryTree</code>之定義，與<a href="http://alrightchiu.github.io/SecondRound/binary-tree-traversal.html#ex_code">上一篇文章</a>之最大不同在於資料的隱蔽性，因為在此不需要於<code>main()</code>中存取任何pointer(<code>root</code>、<code>leftchild</code>、<code>rightchild</code>)，因此將之放進<strong>private</strong>區塊。</p>
</li>
<li>
<p>在許多traversal中，時常以pointer不為NULL作為<code>while</code>的判斷式，因此在constructor中，多做一步，將pointer指向NULL(eg：<code>leftchild = 0</code>)避免埋地雷在日後炸自己。</p>
</li>
<li>
<p>在<code>class BinaryTree</code>除了上一篇介紹過的inorder traversal外，多了兩個新朋友<code>LevelorderConstruct()</code>與<code>insertLevelorder()</code>，前者即是本篇主角，吃進<code>stringstream</code>後，把樹建出來；後者純粹是好玩，其功能為「以Complete Binary Tree之位置規則，在理應出現node的位置，新增node」。</p>
</li>
</ul>
<p>看下去。</p>
<div class="highlight"><pre><span class="code-line"><span class="c1">// C++ code</span></span>
<span class="code-line"><span class="k">class</span> <span class="nc">BinaryTree</span><span class="p">;</span></span>
<span class="code-line"><span class="k">class</span> <span class="nc">TreeNode</span><span class="p">{</span></span>
<span class="code-line"><span class="k">private</span><span class="o">:</span></span>
<span class="code-line">    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">leftchild</span><span class="p">;</span></span>
<span class="code-line">    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">rightchild</span><span class="p">;</span></span>
<span class="code-line">    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span></span>
<span class="code-line">    <span class="kt">char</span> <span class="n">data</span><span class="p">;</span></span>
<span class="code-line"><span class="k">public</span><span class="o">:</span></span>
<span class="code-line">    <span class="n">TreeNode</span><span class="p">(){</span> <span class="n">leftchild</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">rightchild</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">parent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">};</span></span>
<span class="code-line">    <span class="n">TreeNode</span><span class="p">(</span><span class="kt">char</span> <span class="n">s</span><span class="p">)</span><span class="o">:</span><span class="n">data</span><span class="p">(</span><span class="n">s</span><span class="p">){</span><span class="n">leftchild</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">rightchild</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">parent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">};</span></span>
<span class="code-line"></span>
<span class="code-line">    <span class="k">friend</span> <span class="k">class</span> <span class="nc">BinaryTree</span><span class="p">;</span></span>
<span class="code-line"><span class="p">};</span></span>
<span class="code-line"></span>
<span class="code-line"><span class="k">class</span> <span class="nc">BinaryTree</span><span class="p">{</span></span>
<span class="code-line"><span class="k">private</span><span class="o">:</span></span>
<span class="code-line">    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">root</span><span class="p">;</span></span>
<span class="code-line"><span class="k">public</span><span class="o">:</span></span>
<span class="code-line">    <span class="n">BinaryTree</span><span class="p">(){</span> <span class="n">root</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;};</span></span>
<span class="code-line">    <span class="n">BinaryTree</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str</span><span class="p">);</span></span>
<span class="code-line"></span>
<span class="code-line">    <span class="kt">void</span> <span class="nf">LevelorderConstruct</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">stringstream</span> <span class="o">&amp;</span><span class="n">ss</span><span class="p">);</span></span>
<span class="code-line">    <span class="kt">void</span> <span class="nf">insertLevelorder</span><span class="p">(</span><span class="kt">char</span> <span class="n">data</span><span class="p">);</span></span>
<span class="code-line"></span>
<span class="code-line">    <span class="n">TreeNode</span><span class="o">*</span> <span class="nf">leftmost</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">current</span><span class="p">);</span></span>
<span class="code-line">    <span class="n">TreeNode</span><span class="o">*</span> <span class="nf">InorderSuccessor</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">current</span><span class="p">);</span></span>
<span class="code-line">    <span class="kt">void</span> <span class="nf">Inorder_by_parent</span><span class="p">();</span></span>
<span class="code-line"><span class="p">};</span></span>
</pre></div>


<p></br>  </p>
<p><a name="constructor"></a></p>
<h4><strong>Constructor of BinaryTree</strong></h4>
<p><code>class BinaryTree</code>的constructor很直觀，拿到一個字串陣列，先送進<code>stringstream</code>後，再由<code>stringstream</code>放進樹中，先對樹的<code>root</code>進行記憶體配置以及賦值，接著以level-order的方式建立Binary Tree。</p>
<div class="highlight"><pre><span class="code-line"><span class="c1">// C++ code</span></span>
<span class="code-line"><span class="n">BinaryTree</span><span class="o">::</span><span class="n">BinaryTree</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str</span><span class="p">){</span></span>
<span class="code-line">    <span class="n">std</span><span class="o">::</span><span class="n">stringstream</span>  <span class="n">ss</span><span class="p">;</span></span>
<span class="code-line">    <span class="n">ss</span> <span class="o">&lt;&lt;</span> <span class="n">str</span><span class="p">;</span></span>
<span class="code-line"></span>
<span class="code-line">    <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">;</span></span>
<span class="code-line">    <span class="n">ss</span> <span class="o">&gt;&gt;</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span></span>
<span class="code-line"></span>
<span class="code-line">    <span class="n">LevelorderConstruct</span><span class="p">(</span><span class="n">ss</span><span class="p">);</span></span>
<span class="code-line"><span class="p">}</span></span>
</pre></div>


<p></br></p>
<p><a name="func1"></a></p>
<h4><strong>Function：LevelorderConstruct()</strong></h4>
<ul>
<li>在看<code>LevelorderConstruct()</code>的函式主體之前，再看一眼<a href="http://alrightchiu.github.io/SecondRound/binary-tree-traversal.html#level">level-order traversal</a>，概念上即是藉著<code>queue</code>的「先排隊就先購票」的特性，在同一個level中，只要確保由左至右將node放進<code>queue</code>中，便能確保在進入下一個level後，以先前放入node之順序進行visiting。  </li>
<li>在<code>while</code>內，新增條件用來判斷從<code>stringstream</code>中輸出的字母是「大寫字母」(ASCII：65~90)還是「x」，前者要放入樹中建成node，後者則忽略不計。  </li>
<li>整份程式碼的關鍵在於神器<code>stringstream &amp;ss</code>，只要不斷地透過<code>ss &gt;&gt; data</code>，<code>ss</code>便會自動尋找下一筆資料餵進<code>data</code>。</li>
<li>最後，當<code>stringstream</code>不再更新<code>data</code>時，也就是字串陣列已全數讀取完畢，即跳出<code>while</code>迴圈。</li>
</ul>
<p>步驟如下：</p>
<ul>
<li>首先，在Binary Tree的constructor中，先配置<code>root</code>的記憶體位置，並透過第一次<code>ss &gt;&gt; root-&gt;data</code>將第一個字母放進<code>root</code>中，如圖三(a)。</li>
</ul>
<p><center>
<img alt="construct_0" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/construct0.png?raw=true" /></p>
<p><strong>圖三(a)：從ss取出第一個字母'A'放進<code>root</code>。</strong><br />
</center> </p>
<p>接著進入<code>while</code>迴圈。  </p>
<ul>
<li>條件式：<code>ss &gt;&gt; data</code>若為真，表示成功從<code>ss</code>中取出字母，傳進<code>data</code>。  </li>
<li>進入迴圈後，先判斷取出的字母若為大寫字母(在此為<strong>'B'</strong>)，即生成一個新的<code>new_node</code>，將B放進<code>new_node</code>中，並將<code>CurrentNode</code>(在此為A)的left child指向<code>new_node</code>，如圖三(b)。  </li>
<li>在<code>queue</code>  的部分，若成功建立出新的node(此為B)，便把B放進<code>queue</code>的隊伍中，表示之後將要把<code>CurrentNode</code>移到B，繼續往下建立新的node。</li>
</ul>
<p><center> 
<img alt="construct_1" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/construct1.png?raw=true" /></p>
<p><strong>圖三(b)：。</strong><br />
</center> </p>
<p>在同一個迴圈裡，建立完<code>CurrentNode</code>的left child後，接著嘗試建立right child。  </p>
<ul>
<li>條件式：<code>if( !(ss &gt;&gt; data) )</code>若為真，表示<code>ss</code>中的字母已經讀取完畢，即跳出迴圈(<code>break</code>)。若否，則繼續從<code>ss</code>中讀取字母。</li>
<li>判斷字母是否為大寫字母(此為<strong>'C'</strong>)，便如同生成left child之方法，建立新的<code>new_node</code>、配置記憶體、將字母<strong>'C'</strong>放進<code>new_node</code>中，並將<code>CurrentNode</code>之right child指向<code>new_node</code>，如圖三(c)。</li>
<li>已成功建立新的node(C)，便把C放進<code>queue</code>的隊伍中，表示之後將要把<code>CurrentNode</code>移到B，繼續往下建立新的node。
此時，<code>queue</code>裡有兩個node，分別為B與C，要注意的是，排隊時，先進入隊伍的人會代表隊伍的前方，因此B為<code>queue</code>的<strong>Front</strong>，C為<code>queue</code>的<strong>End</strong>。</li>
</ul>
<p><center>
<img alt="construct_2" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/construct2.png?raw=true" />  </p>
<p><strong>圖三(c)：。</strong><br />
</center> </p>
<p>在建立完<code>CurrentNode</code>的left child與right child後，接著要移動<code>CurrentNode</code>，作為下一個<code>while</code>迴圈的起點。<br />
<code>queue</code>的功能便是提供<code>CurrentNode</code>移動的依據：</p>
<ul>
<li>一律將<code>queue</code>隊伍的第一個node視作新的<code>CurrentNode</code>：<code>CurrentNode = q.front()</code>。</li>
<li>將<code>CurrentNode</code>移動至B後，便把B從<code>queue</code>移除：<code>q.pop()</code>，如圖三(d)。</li>
</ul>
<p>如此便能保證，<code>CurrentNode</code>的移動會依照level-order「由上至下、由左至右」之順序。
</br><br />
<center>
<img alt="construct_3" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/construct3.png?raw=true" />  </p>
<p><strong>圖三(d)：。</strong><br />
</center> </p>
<p>進入第二次<code>while</code>迴圈後，重複以上之步驟：</p>
<ul>
<li>從<code>ss</code>取出字母，放進<code>data</code>。</li>
<li>判斷<code>data</code>是否為大寫，若是，便依序在<code>CurrentNode</code>之left child與right child建立新的node。</li>
<li>並且，將成功建立之node放進<code>queue</code>隊伍中，用作之後<code>CurrentNode</code>移動之用。</li>
</ul>
<p>仔細觀察圖三(e)至圖三(h)之<code>ss</code>與<code>CurrentNode</code>之移動，與<code>queue</code>的變化：
</br><br />
<center>
<img alt="construct_4" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/construct4.png?raw=true" />  </p>
<p><strong>圖三(e)：。</strong><br />
</center> </p>
<p><center>
<img alt="construct_5" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/construct5.png?raw=true" />  </p>
<p><strong>圖三(f)：。</strong><br />
</center> </p>
<p><center>
<img alt="construct_6" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/construct6.png?raw=true" />  </p>
<p><strong>圖三(g)：。</strong><br />
</center> </p>
<p><center>
<img alt="construct_7" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/construct7.png?raw=true" />  </p>
<p><strong>圖三(h)：。</strong><br />
</center></p>
<ul>
<li>在建立完C的left child後，從<code>ss</code>讀取到字母<strong>'x'</strong>，因為其並非大寫字母，表示C沒有right child，因此跳過生成新的node之步驟，如圖三(i)。  </li>
</ul>
<p><center>
<img alt="construct_8" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/construct8.png?raw=true" />  </p>
<p><strong>圖三(i)：。</strong><br />
</center> </p>
<ul>
<li>若沒有生成新的node，便沒有新的node進入<code>queue</code>排隊。</li>
<li>接著要繼續將<code>CurrentNode</code>移動到<code>queue</code>的第一個元素，也就是D，並把D從<code>queue</code>中移除，如圖三(j)。</li>
</ul>
<p><center>
<img alt="construct_9" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/construct9.png?raw=true" />  </p>
<p><strong>圖三(j)：。</strong><br />
</center></p>
<ul>
<li>當<code>CurrentNode</code>移動到D之後，<code>ss</code>連續放兩個<strong>'x'</strong>進入<code>data</code>，表示D的兩個child pointer皆指向<code>NULL</code>。</li>
<li>由於沒有新的node產生，<code>queue</code>的隊伍便沒有更新，如圖三(k)。</li>
</ul>
<p><center>
<img alt="construct_10" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/construct10.png?raw=true" /></p>
<p><strong>圖三(k)：。</strong><br />
</center> </p>
<p>接著，重複步驟：</p>
<ul>
<li>移動<code>CurrentNode</code>至<code>queue</code>的第一個元素所指示的node。</li>
<li>從<code>ss</code>讀取字母，判斷其為大寫字母，生成新的node接在<code>CurrentNode</code>的child pointer上。</li>
<li>若有生成新的node，則將該node推入<code>queue</code>的隊伍。</li>
</ul>
<p><center>
<img alt="construct_11" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/construct11.png?raw=true" />  </p>
<p><strong>圖三(l)：。</strong><br />
</center> </p>
<ul>
<li>直到<code>ss</code>輸出最後一個字母<strong>'I'</strong>後，這棵樹便建立完成。</li>
<li>由於，<code>ss</code>已全數讀取完畢，敘述句：<code>ss &gt;&gt; data</code>不成立，因此結束迴圈。</li>
</ul>
<p><center>
<img alt="construct_12" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/construct12.png?raw=true" />  </p>
<p><strong>圖三(m)：。</strong><br />
</center> </p>
<p></br>  </p>
<div class="highlight"><pre><span class="code-line"><span class="c1">// C++ code</span></span>
<span class="code-line"><span class="kt">void</span> <span class="n">BinaryTree</span><span class="o">::</span><span class="n">LevelorderConstruct</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">stringstream</span> <span class="o">&amp;</span><span class="n">ss</span><span class="p">){</span></span>
<span class="code-line">    <span class="n">std</span><span class="o">::</span><span class="n">queue</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*&gt;</span> <span class="n">q</span><span class="p">;</span></span>
<span class="code-line">    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">current</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span></span>
<span class="code-line">    <span class="kt">char</span> <span class="n">data</span> <span class="o">=</span> <span class="sc">&#39;x&#39;</span><span class="p">;</span></span>
<span class="code-line">    <span class="k">while</span> <span class="p">(</span><span class="n">ss</span> <span class="o">&gt;&gt;</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span></span>
<span class="code-line">        <span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">&gt;=</span> <span class="mi">65</span> <span class="o">&amp;&amp;</span> <span class="n">data</span> <span class="o">&lt;=</span> <span class="mi">90</span><span class="p">){</span></span>
<span class="code-line">            <span class="n">TreeNode</span> <span class="o">*</span><span class="n">new_node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>  <span class="c1">// call constructor TreeNode(char s)</span></span>
<span class="code-line">            <span class="n">new_node</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span></span>
<span class="code-line">            <span class="n">current</span><span class="o">-&gt;</span><span class="n">leftchild</span> <span class="o">=</span> <span class="n">new_node</span><span class="p">;</span></span>
<span class="code-line">            <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">new_node</span><span class="p">);</span></span>
<span class="code-line">        <span class="p">}</span></span>
<span class="code-line">        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ss</span> <span class="o">&gt;&gt;</span> <span class="n">data</span><span class="p">))</span></span>
<span class="code-line">            <span class="k">break</span><span class="p">;</span></span>
<span class="code-line"></span>
<span class="code-line">        <span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">&gt;=</span> <span class="mi">65</span> <span class="o">&amp;&amp;</span> <span class="n">data</span> <span class="o">&lt;=</span> <span class="mi">90</span><span class="p">){</span></span>
<span class="code-line">            <span class="n">TreeNode</span> <span class="o">*</span><span class="n">new_node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">;</span>        <span class="c1">// call constructor TreeNode()</span></span>
<span class="code-line">            <span class="n">new_node</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span></span>
<span class="code-line">            <span class="n">current</span><span class="o">-&gt;</span><span class="n">rightchild</span> <span class="o">=</span> <span class="n">new_node</span><span class="p">;</span></span>
<span class="code-line">            <span class="n">new_node</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span></span>
<span class="code-line">            <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">new_node</span><span class="p">);</span></span>
<span class="code-line">        <span class="p">}</span></span>
<span class="code-line">        <span class="n">current</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span></span>
<span class="code-line">        <span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span></span>
<span class="code-line">    <span class="p">}</span></span>
<span class="code-line"><span class="p">}</span></span>
</pre></div>


<p></br>
<a name="func2"></a></p>
<h4><strong>Function：insertLevelorder()</strong></h4>
<p>函式<code>insertLevelorder()</code>的功能是，能夠按照Complete Binary Tree的位置順序放置新增的node，例如，若要在圖三之樹上新增帶有字母<strong>'K'</strong>的node，則<code>T.insertLevelorder('K')</code>便會將<strong>'K'</strong>建成C的right child，如圖四(a)：</p>
<p><center>
<img alt="insertK" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/insertK.png?raw=true" />  </p>
<p><strong>圖四(a)：。</strong><br />
</center> </p>
<p>再依序新增L、M、N：</p>
<ul>
<li><code>T.insertLevelorder('L')</code>  </li>
<li><code>T.insertLevelorder('M')</code>  </li>
<li><code>T.insertLevelorder('N')</code></li>
</ul>
<p>即會得到如圖四(b)的樹：</p>
<p><center>
<img alt="insertLMN" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/insertLMN.png?raw=true" />  </p>
<p><strong>圖四(b)：。</strong><br />
</center> </p>
<p>程式碼之邏輯與<code>LevelorderConstruct</code>大同小異，最主要的部分就是利用<code>queue</code>來記錄<code>CurrentNode</code>移動的順序：</p>
<ul>
<li>首先，將<code>current</code>設成<code>root</code>，若樹存在，則進入<code>while</code>迴圈。</li>
<li>接著判斷，若<code>current</code>之left child已經有node，則將之放入<code>queue</code>中，再下次迴圈將以此node作為<code>current</code>，若left child還沒有node，便產生帶有<code>data</code>之新node，並將其建立成<code>current</code>之left child。<br />
pointer連接完成後，結束迴圈。</li>
<li>對<code>current</code>之right child進行相同之步驟。</li>
</ul>
<p>如此便能有效控制Binary Tree之樹高(height)，使pointer所配置之記憶體空間有效利用，亦能夠減少traversal(以及其他操作)所需的時間。</p>
<div class="highlight"><pre><span class="code-line"><span class="c1">// C++ code</span></span>
<span class="code-line"><span class="kt">void</span> <span class="n">BinaryTree</span><span class="o">::</span><span class="n">insertLevelorder</span><span class="p">(</span><span class="kt">char</span> <span class="n">data</span><span class="p">){</span>    </span>
<span class="code-line">    <span class="n">std</span><span class="o">::</span><span class="n">queue</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*&gt;</span> <span class="n">q</span><span class="p">;</span></span>
<span class="code-line">    <span class="n">TreeNode</span> <span class="o">*</span><span class="n">current</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span></span>
<span class="code-line"></span>
<span class="code-line">    <span class="k">while</span> <span class="p">(</span><span class="n">current</span><span class="p">)</span> <span class="p">{</span></span>
<span class="code-line">        <span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">leftchild</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span></span>
<span class="code-line">            <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">leftchild</span><span class="p">);</span></span>
<span class="code-line">        <span class="k">else</span><span class="p">{</span></span>
<span class="code-line">            <span class="n">TreeNode</span> <span class="o">*</span><span class="n">new_node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">data</span><span class="p">);</span></span>
<span class="code-line">            <span class="n">new_node</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span></span>
<span class="code-line">            <span class="n">current</span><span class="o">-&gt;</span><span class="n">leftchild</span> <span class="o">=</span> <span class="n">new_node</span><span class="p">;</span></span>
<span class="code-line">            <span class="k">break</span><span class="p">;</span></span>
<span class="code-line">        <span class="p">}</span></span>
<span class="code-line">        <span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">rightchild</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span></span>
<span class="code-line">            <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">rightchild</span><span class="p">);</span></span>
<span class="code-line">        <span class="k">else</span><span class="p">{</span></span>
<span class="code-line">            <span class="n">TreeNode</span> <span class="o">*</span><span class="n">new_node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">data</span><span class="p">);</span></span>
<span class="code-line">            <span class="n">new_node</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span></span>
<span class="code-line">            <span class="n">current</span><span class="o">-&gt;</span><span class="n">rightchild</span> <span class="o">=</span> <span class="n">new_node</span><span class="p">;</span></span>
<span class="code-line">            <span class="k">break</span><span class="p">;</span></span>
<span class="code-line">        <span class="p">}</span></span>
<span class="code-line">        <span class="n">current</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span></span>
<span class="code-line">        <span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span></span>
<span class="code-line">    <span class="p">}</span></span>
<span class="code-line"><span class="p">}</span></span>
</pre></div>


<p></br><br />
以上便是利用<code>queue</code>執行level-order方式建立Binary Tree之範例。<br />
另外，<a href="http://www.geeksforgeeks.org/level-order-tree-traversal/">有些方法是利用遞迴的方式，外帶一個迴圈來進行level-order traversal</a>，也能夠完成相同的功能。</p>
<p></br>
<a name="ref"></a></p>
<h6><strong>參考資料</strong>：</h6>
<ul>
<li><a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844">Introduction to Algorithms</a> </li>
<li><a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376">Fundamentals of Data Structures in C++</a></li>
<li><a href="http://www3.ntu.edu.sg/home/ehchua/programming/cpp/cp10_io.html">C++ Programming Language：Stream IO and File IO</a></li>
<li><a href="http://www.geeksforgeeks.org/level-order-tree-traversal/">GeeksforGeeks：Level Order Tree Traversal</a></li>
</ul>
<p></br></p>
  </div>
  <div class="tag-cloud">
    <p>
      <a href="http://alrightchiu.github.io/SecondRound/tag/jin-tian-bu-xie-ming-tian-jiu-wang-liao.html">今天不寫明天就忘了</a>
    </p>
  </div>
</article>

    <footer>
<p>
  &copy; Chiu CC  - This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>
</p>
<p>Built using <a href="http://getpelican.com" target="_blank">Pelican</a> - <a href="https://github.com/alexandrevicenzi/flex" target="_blank">Flex</a> theme by <a href="http://alexandrevicenzi.com" target="_blank">Alexandre Vicenzi</a></p><p>
  <a rel="license"
     href="http://creativecommons.org/licenses/by-sa/4.0/"
     target="_blank">
    <img alt="Creative Commons License"
         title="Creative Commons License"
         style="border-width:0"
         src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png"
         width="80"
         height="15"/>
  </a>
</p>    </footer>
  </main>





<script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "BlogPosting",
  "name": "Binary Tree: Construct Binary Tree from char array",
  "headline": "Binary Tree: Construct Binary Tree from char array",
  "datePublished": "2015-12-19 20:27:00+08:00",
  "dateModified": "",
  "author": {
    "@type": "Person",
    "name": "Chiu CC",
    "url": "http://alrightchiu.github.io/SecondRound/author/chiu-cc.html"
  },
  "image": "http://alrightchiu.github.io/SecondRound/fig/antiwar.jpg",
  "url": "http://alrightchiu.github.io/SecondRound/binary-tree-construct-binary-tree-from-char-array.html",
  "description": "介紹Binary Tree中的Traversal(尋訪)。"
}
</script></body>
</html>