<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Second Round</title><link href="http://alrightchiu.github.io/SecondRound/" rel="alternate"></link><link href="http://alrightchiu.github.io/SecondRound/feeds/all.atom.xml" rel="self"></link><id>http://alrightchiu.github.io/SecondRound/</id><updated>2016-02-23T12:36:00+08:00</updated><entry><title>Minimum Spanning Tree：Intro(簡介)</title><link href="http://alrightchiu.github.io/SecondRound/minimum-spanning-treeintrojian-jie.html" rel="alternate"></link><updated>2016-02-23T12:36:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2016-02-23:SecondRound/minimum-spanning-treeintrojian-jie.html</id><summary type="html">&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;先備知識與注意事項&lt;/h3&gt;
&lt;p&gt;本篇文章旨在介紹Graph中常見的應用：Minimum Spanning Tree(MST，最小生成樹)。&lt;/p&gt;
&lt;p&gt;在介紹演算法時，繼續會用上Set(集合)的概念，如果對Set有基本概念，相信讀者一定可以躺著讀完這篇。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#mst"&gt;Minimum Spanning Tree(MST，最小生成樹)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#algorithm"&gt;演算法概念(Generic Algorithm)&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#theorem"&gt;Theorom1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#proof"&gt;證明：Theorem1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#corollary"&gt;Corollary2&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#ref"&gt;參考資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#series"&gt;Graph系列文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="mst"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Minimum Spanning Tree(MST，最小生成樹)&lt;/h2&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/MST_intro/f1.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(a)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;考慮一個connected、weighted的undirected graph，如圖一(a)，在Graph上能夠定義&lt;strong&gt;Spanning Tree&lt;/strong&gt;為：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;連結所有Graph中的vertex的樹，見圖一(b)。&lt;/li&gt;
&lt;li&gt;因為是樹，所以&lt;strong&gt;沒有cycle&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;因為是樹，若Graph有&lt;span class="math"&gt;\(V\)&lt;/span&gt;個vertex，Spanning Tree只有&lt;span class="math"&gt;\(|V|-1\)&lt;/span&gt;條edge。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/MST_intro/f2.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(b)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;由於Graph具有weight，因此，不同的Spanning Tree，可能有不同的&lt;strong&gt;weight總和&lt;/strong&gt;，而其中，具有&lt;strong&gt;最小weight總和&lt;/strong&gt;的樹，稱為&lt;strong&gt;Minimum Spanning Tree(MST)&lt;/strong&gt;，如圖一(c)。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/MST_intro/f3.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(c)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;小小提醒：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由於Graph的weight只要求要是實數(real value)，而且不要求每一條edge的weight必須唯一，因此，Graph中的MST可能不唯一。&lt;/li&gt;
&lt;li&gt;由於MST的定義只要求「最小weight總和」，因此&lt;code&gt;root&lt;/code&gt;是哪個vertex、樹是否平衡、height(樹高)是否夠小等等問題，皆不在必要的考慮範圍內。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="algorithm"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;演算法概念(Generic Algorithm)&lt;/h2&gt;
&lt;p&gt;根據MST的定義，MST一定要包含Graph中的所有vertex，而且要使得連結所有vertex的edge之&lt;strong&gt;weight總和最小&lt;/strong&gt;，所以，關鍵便是「如何挑選edge」。&lt;/p&gt;
&lt;p&gt;尋找MST的演算法之大方向如下：&lt;br /&gt;
(此即為下兩篇文章將介紹的&lt;strong&gt;Kruskal's Algorithm&lt;/strong&gt;與&lt;strong&gt;Prim's Algorithm&lt;/strong&gt;的心法口訣)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;建立一個用來收集/表示「所有MST中的edge」之集合，稱為Set A。見圖二(a)。&lt;/li&gt;
&lt;li&gt;Set A起初是空集合，演算法將逐一挑選出「滿足MST」之edge，並利用Union(聯集)把edge視為element放進Set A中。見圖二(b)。&lt;/li&gt;
&lt;li&gt;因此，Set A會是一個逐漸長大的MST之edge的subset(子集合)，&lt;span class="math"&gt;\(A\subseteq E(MST)\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;演算法完成後，Set A就包含了所有MST的edge。見圖二(c)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/MST_intro/f4.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(a)。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/MST_intro/f5.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(b)。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/MST_intro/f6.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(c)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;接著將介紹一個定理(theorem)與其等價的推論(corollary)，來說明怎麼樣的edge對Set A來說是&lt;strong&gt;安全的(safe)&lt;/strong&gt;，使得「該edge加入Set A後，Set A仍然滿足&lt;span class="math"&gt;\(A\subseteq E(MST)\)&lt;/span&gt;」。&lt;/p&gt;
&lt;p&gt;先定義四個名詞概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Cut&lt;/strong&gt;：Cut是一種將Graph(&lt;span class="math"&gt;\(G=(V,E)\)&lt;/span&gt;)的V(vertex set)分成兩部分(以&lt;span class="math"&gt;\((S,V-S)\)&lt;/span&gt;表示)的&lt;strong&gt;partition(分割)&lt;/strong&gt;。&lt;ul&gt;
&lt;li&gt;圖三(a)左，Cut &lt;span class="math"&gt;\((S,V-S)\)&lt;/span&gt;將Graph中的vertex分割出兩個Set，&lt;span class="math"&gt;\(S=\)&lt;/span&gt;{&lt;span class="math"&gt;\(1,4\)&lt;/span&gt;}，&lt;span class="math"&gt;\(V-S=\)&lt;/span&gt;{&lt;span class="math"&gt;\(0,2,3,5,6\)&lt;/span&gt;}。&lt;/li&gt;
&lt;li&gt;圖三(a)右，Cut &lt;span class="math"&gt;\((S,V-S)\)&lt;/span&gt;將Graph中的vertex分割出兩個Set，&lt;span class="math"&gt;\(S=\)&lt;/span&gt;{&lt;span class="math"&gt;\(1,4,6,0,5\)&lt;/span&gt;}，&lt;span class="math"&gt;\(V-S=\)&lt;/span&gt;{&lt;span class="math"&gt;\(2,3\)&lt;/span&gt;}。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/MST_intro/f7.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(a)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;cross&lt;/strong&gt;：若存在一條edge(X,Y)，其中&lt;span class="math"&gt;\(X\subseteq S\)&lt;/span&gt;，&lt;span class="math"&gt;\(Y\subseteq V-S\)&lt;/span&gt;，則稱這條edge「&lt;strong&gt;crosses&lt;/strong&gt;」Cut &lt;span class="math"&gt;\((S,V-S)\)&lt;/span&gt;。&lt;ul&gt;
&lt;li&gt;把圖三(a)左圖調整成圖三(b)，觀察出edge(1,0)、edge(1,2)、edge(1,6)、edge(4,3)、edge(4,5)、edge(4,6)對Cut而言，都是crossing edge。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/MST_intro/f8.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(b)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;respect&lt;/strong&gt;：若Set A中沒有任何一條edge是Cut的crossing edge，則稱這個Cut「&lt;strong&gt;respect&lt;/strong&gt;」Set A。(因為尊敬，所以不切開。)&lt;ul&gt;
&lt;li&gt;以圖三(b)為例，Set A&lt;span class="math"&gt;\(=\)&lt;/span&gt;{&lt;span class="math"&gt;\(edge(1,4)\)&lt;/span&gt;}，vertex(1)與vertex(4)都在&lt;span class="math"&gt;\(S=\)&lt;/span&gt;{&lt;span class="math"&gt;\(1,4\)&lt;/span&gt;}裡，因此edge(1,4)不是Cut &lt;span class="math"&gt;\((S,V-S)\)&lt;/span&gt;的crossing edge，則稱Cut &lt;span class="math"&gt;\((S,V-S)\)&lt;/span&gt;「&lt;strong&gt;respect&lt;/strong&gt;」Set A。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;light edge&lt;/strong&gt;：在考慮範圍內，「weight最小」的edge稱為&lt;strong&gt;light edge&lt;/strong&gt;。&lt;ul&gt;
&lt;li&gt;以圖三(b)為例，若考慮所有的crossing edge，則edge(4,6)即為light edge。&lt;/li&gt;
&lt;li&gt;如果有多條edge的weight都相同，並且為極小值，那麼light edge將不止一條。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上專有名詞有點多，最重要的是釐清：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Set A是&lt;strong&gt;edge的集合&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;Cut的兩個Set：&lt;span class="math"&gt;\((S,V-S)\)&lt;/span&gt;是&lt;strong&gt;vertex的集合&lt;/strong&gt;。&lt;br /&gt;
&lt;/br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name="theorem"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Theorom1&lt;/h3&gt;
&lt;p&gt;(對應&lt;a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844"&gt;Introduction to Algorithms第23章，Theorem23.1&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Theorem1&lt;/strong&gt;要說的是，給定：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Graph &lt;span class="math"&gt;\(G=(V,E)\)&lt;/span&gt;是一個connected、weighted、undirected graph；&lt;/li&gt;
&lt;li&gt;Set A是MST之edge的subset，&lt;span class="math"&gt;\(A\subseteq E(MST)\)&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;Cut &lt;span class="math"&gt;\((S,V-S)\)&lt;/span&gt; 必須「respect」Set A；&lt;/li&gt;
&lt;li&gt;edge(X,Y)是crossing edge，也是light edge；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;那麼，edge(X,Y)對Set A即為&lt;strong&gt;安全的(safe)&lt;/strong&gt;，將edge(X,Y)加入Set A後，Set A必定能夠滿足&lt;span class="math"&gt;\(A\subseteq E(MST)\)&lt;/span&gt;。&lt;br /&gt;
換句話說，edge(X,Y)一定會是MST的edge。&lt;/p&gt;
&lt;p&gt;以圖四(a)為例，確認&lt;strong&gt;前三項條件皆滿足&lt;/strong&gt;，並且找到所有crossing edge中weight最小的edge為edge(4,6)，則edge(4,6)必定是MST的edge。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/MST_intro/f9.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四(a)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="proof"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;證明：Theorem1&lt;/h3&gt;
&lt;p&gt;如圖五(a)，考慮一個connected、weighted、undirected graph上的MST：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MST以T表示，&lt;span class="math"&gt;\(T=(V(T),E(T))\)&lt;/span&gt;；&lt;ul&gt;
&lt;li&gt;以圖五(a)為例，&lt;span class="math"&gt;\(E(T)=A\cup edge(Z,W)\cup edge(A,C)\)&lt;/span&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Set A為T的edge之subset；&lt;ul&gt;
&lt;li&gt;以圖五(a)為例，&lt;span class="math"&gt;\(A=\)&lt;/span&gt;{&lt;span class="math"&gt;\(edge(X,Z),edge(Y,W),edge(W,B),edge(W,C)\)&lt;/span&gt;}；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Cut &lt;span class="math"&gt;\((S,V-S)\)&lt;/span&gt;可以是任意「respect」Set A的Cut，並假設edge(X,Y)是Cut上所有crossing edge中的light edge，而且&lt;strong&gt;edge(X,Y)不屬於T&lt;/strong&gt;；&lt;ul&gt;
&lt;li&gt;圖五(a)中，找到Cut &lt;span class="math"&gt;\((S,V-S)\)&lt;/span&gt;，其中&lt;span class="math"&gt;\(S=\)&lt;/span&gt;{&lt;span class="math"&gt;\(X,Z\)&lt;/span&gt;}，&lt;span class="math"&gt;\(V-S=\)&lt;/span&gt;{&lt;span class="math"&gt;\(Y,W,B,C,A\)&lt;/span&gt;}，edge(X,Y)為light edge；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;由於Cut「respect」Set A，因此&lt;strong&gt;edge(X,Y)不在Set A裡面&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/MST_intro/f11.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五(a)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;因為MST是一個Tree，所以T上的各個vertex之間&lt;strong&gt;只存在唯一的path&lt;/strong&gt;，因此，vertex(Y)到vertex(X)之間，必定在T上存在一條path，而且這條path中，&lt;strong&gt;將有一條edge會是Cut的crossing edge&lt;/strong&gt;，令這條crossing edge為edge(Z,W)。&lt;br /&gt;
同樣地，由於Cut「respect」Set A，&lt;strong&gt;edge(Z,W)也不會在Set A裡面&lt;/strong&gt;。 &lt;/p&gt;
&lt;p&gt;又因為edge(X,Y)是所有crossing edge中的light edge，所以：&lt;span class="math"&gt;\(weight(X,Y)\leq weight(Z,W)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;此時，如果把edge(Z,W)從T中移除，T將分成兩個connected component，見圖五(b)。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;因為edge(Z,W)不在Set A裡面，這兩個connected component的全部edge所形成之集合必定包含Set A。  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;再將這兩個connected component接上edge(X,Y)，形成一棵新的Tree，稱為T'，其中&lt;span class="math"&gt;\(E(T')=E(T)-edge(Z,W)+edge(X,Y)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/MST_intro/f12.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五(b)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;因為&lt;span class="math"&gt;\(weight(X,Y)\leq weight(Z,W)\)&lt;/span&gt;，便得到：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class="math"&gt;\(weight(T')\leq weight(T)-weight(Z,W)+weight(X,Y)\)&lt;/span&gt;；&lt;br /&gt;
&lt;span class="math"&gt;\(weight(T')\leq weight(T)\)&lt;/span&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，若T是MST，那麼T'也會是一棵MST。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以圖五(b)為例，經過&lt;span class="math"&gt;\(E(T')=E(T)-edge(Z,W)+edge(X,Y)\)&lt;/span&gt;後，新的&lt;span class="math"&gt;\(E(T')=\)&lt;/span&gt;{&lt;span class="math"&gt;\(A+edge(X,Y)+edge(A,C)\)&lt;/span&gt;}。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因為Set A與edge(X,Y)同屬於MST的edge之集合，因此edge(X,Y)對Set A會是&lt;strong&gt;安全的(safe)&lt;/strong&gt;，使得edge(X,Y)加入Set A後，Set A仍然能夠滿足&lt;span class="math"&gt;\(A\subseteq E(MST)\)&lt;/span&gt;。(證明完畢)&lt;br /&gt;
&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="corollary"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Corollary2&lt;/h3&gt;
&lt;p&gt;與&lt;strong&gt;Theorem1&lt;/strong&gt;等價的&lt;strong&gt;Corollary2&lt;/strong&gt;要說的是，給定：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Graph &lt;span class="math"&gt;\(G=(V,E)\)&lt;/span&gt;是一個connected、weighted、undirected graph；&lt;/li&gt;
&lt;li&gt;Set A是MST之edge的subset，&lt;span class="math"&gt;\(A\subseteq E(MST)\)&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;subgraph &lt;span class="math"&gt;\(C=(V_C,E_C)\)&lt;/span&gt;為「Forest &lt;span class="math"&gt;\(G_A=(V,A)\)&lt;/span&gt;」中的connected component，C可以視為一棵Tree；&lt;/li&gt;
&lt;li&gt;edge(X,Y)是所有在「Forest &lt;span class="math"&gt;\(G_A=(V,A)\)&lt;/span&gt;」中，連結各個connected component的light edge；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;那麼，edge(X,Y)對Set A也會是&lt;strong&gt;安全的(safe)&lt;/strong&gt;，將edge(X,Y)加入Set A後，Set A必定能夠滿足&lt;span class="math"&gt;\(A\subseteq E(MST)\)&lt;/span&gt;。    &lt;/p&gt;
&lt;p&gt;以圖四(b)為例，&lt;span class="math"&gt;\(G_A=(V,A)\)&lt;/span&gt;裡有兩個connected component，分別為：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class="math"&gt;\(C_1=(V_1,E_1)\)&lt;/span&gt;，其中&lt;span class="math"&gt;\(V_1=\)&lt;/span&gt;{&lt;span class="math"&gt;\(0,5\)&lt;/span&gt;}，&lt;span class="math"&gt;\(E_1=\)&lt;/span&gt;{&lt;span class="math"&gt;\(edge(0,5)\)&lt;/span&gt;}；&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(C_2=(V_2,E_2)\)&lt;/span&gt;，其中&lt;span class="math"&gt;\(V_2=\)&lt;/span&gt;{&lt;span class="math"&gt;\(1,4,6\)&lt;/span&gt;}，&lt;span class="math"&gt;\(E_2=\)&lt;/span&gt;{&lt;span class="math"&gt;\(edge(1,4), edge(4,6)\)&lt;/span&gt;}。  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根據&lt;strong&gt;Theorem1&lt;/strong&gt;，若Cut &lt;span class="math"&gt;\((C_1,V-C_1)\)&lt;/span&gt;「respect」Set A，那麼Cut上的「crossing light edge」，一定也是MST的edge。&lt;/p&gt;
&lt;p&gt;觀察圖四(b)，顯然，Set A中的edge都沒有「cross」Cut &lt;span class="math"&gt;\((C_1,V-C_1)\)&lt;/span&gt;，而所有crossing edge中的light edge為edge(0,1)，因此，能夠將edge(0,1)加入Set A。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/MST_intro/f10.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四(b)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;br /&gt;
關於MST的應用，筆者也還在摸索，這裡就放上兩個連結供讀者參考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.geeksforgeeks.org/applications-of-minimum-spanning-tree/"&gt;GeeksforGeeks：Applications of Minimum Spanning Tree Problem&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;&lt;a href="http://courses.cs.vt.edu/cs5114/spring2009/lectures/lecture08-mst-applications.pdf"&gt;T. M. Murali：Applications of Minimum Spanning Tree Problem&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下來，將以兩篇文章的篇幅介紹尋找MST的演算法：&lt;strong&gt;Kruskal's Algorithm&lt;/strong&gt;與&lt;strong&gt;Prim's Algorithm&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a name="ref"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;參考資料：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844"&gt;Introduction to Algorithms, Ch23&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376"&gt;Fundamentals of Data Structures in C++, Ch6&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.personal.kent.edu/~rmuhamma/Algorithms/MyAlgorithms/GraphAlgor/genericMST.htm"&gt;Rashid Bin Muhammad：Generic-Minimum Spanning Tree&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.geeksforgeeks.org/applications-of-minimum-spanning-tree/"&gt;GeeksforGeeks：Applications of Minimum Spanning Tree Problem&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://courses.cs.vt.edu/cs5114/spring2009/lectures/lecture08-mst-applications.pdf"&gt;T. M. Murali：Applications of Minimum Spanning Tree Problem&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name="series"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h2&gt;Graph系列文章&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/graph-introjian-jie.html"&gt;Graph: Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/graph-breadth-first-searchbfsguang-du-you-xian-sou-xun.html"&gt;Graph: Breadth-First Search(BFS，廣度優先搜尋)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/graph-depth-first-searchdfsshen-du-you-xian-sou-xun.html"&gt;Graph: Depth-First Search(DFS，深度優先搜尋)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/graph-li-yong-dfshe-bfsxun-zhao-connected-component.html"&gt;Graph: 利用DFS和BFS尋找Connected Component&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/grpah-li-yong-dfsxun-zhao-strongly-connected-componentscc.html"&gt;Grpah: 利用DFS尋找Strongly Connected Component(SCC)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/grpah-li-yong-dfsxun-zhao-dagde-topological-sorttuo-pu-pai-xu.html"&gt;Grpah: 利用DFS尋找DAG的Topological Sort(拓撲排序)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="C++"></category><category term="Graph"></category><category term="MST"></category><category term="Intro"></category></entry><entry><title>Grpah: 利用DFS尋找DAG的Topological Sort(拓撲排序)</title><link href="http://alrightchiu.github.io/SecondRound/grpah-li-yong-dfsxun-zhao-dagde-topological-sorttuo-pu-pai-xu.html" rel="alternate"></link><updated>2016-02-18T18:01:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2016-02-18:SecondRound/grpah-li-yong-dfsxun-zhao-dagde-topological-sorttuo-pu-pai-xu.html</id><summary type="html">&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;先備知識與注意事項&lt;/h3&gt;
&lt;p&gt;有些事件具有絕對的「先後關係」，例如，襪子要在鞋子之前穿上，否則穿上鞋子後要再穿襪子需要一點奇蹟。&lt;/p&gt;
&lt;p&gt;若以Graph來表示，vertex(穿襪子)、vertex(穿鞋子)與edge(先後關係)如圖一(a)：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/TS_fig/f1.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(a)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;在&lt;a href="http://alrightchiu.github.io/SecondRound/graph-introjian-jie.html"&gt;Graph: Intro(簡介)&lt;/a&gt;曾經提過的「課程與其先修課程」亦具有這樣的「先後關係」。&lt;br /&gt;
例如，學生一定要先修過「資料結構」，才能選修「演算法分析」，否則選課系統會生氣。&lt;/p&gt;
&lt;p&gt;那麼要如何確保在選修「演算法分析」之前，已經先選修「資料結構」，而在選修「資料結構」之前，已經先修完「程式(一)」與「離散數學」？&lt;/p&gt;
&lt;p&gt;本篇文章將要介紹的Topological Sort(拓撲排序)就是要解決這項煩惱。&lt;br /&gt;
如果找到了圖一(b)的Topological Sort(拓撲排序)，就能知道可行的修課順序，以確保在選修「演算法分析」之前，一定已經修過「資料結構」與「線性代數」。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/TS_fig/f2.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(b)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#ts"&gt;Topological Sort(拓撲排序)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#algorithm"&gt;演算法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#code"&gt;程式碼&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#ref"&gt;參考資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#series"&gt;Graph系列文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="ts"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Topological Sort(拓撲排序)&lt;/h2&gt;
&lt;p&gt;所謂的Topological Sort(拓撲排序)要求，若&lt;strong&gt;directed acyclic graph(DAG)&lt;/strong&gt;中存在一條edge(X,Y)，那麼序列中，vertex(X)一定要在vertex(Y)之前出現。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以圖二(a)為例，存在edge(2,6)、edge(6,9)，那麼Topological Sort中，vertex(2)一定要出現在vertex(6)之前，vertex(6)一定要在vertex(9)之前。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/TS_fig/f3.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(a)：將圖一(b)以符號表示。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;根據圖一(b)，選修「資料結構」與「線性代數」的先後順序顯然無所謂，「數值分析」與「離散數學」的修課順序也互相沒有影響，因為兩者之間沒有必然的先後關係。&lt;br /&gt;
因此，正確的Topological Sort可能不止一種，以下兩種排序皆為圖二(a)的可能結果：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Topological&lt;/span&gt; &lt;span class="nl"&gt;Sort&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
  &lt;span class="mi"&gt;3&lt;/span&gt;  &lt;span class="mi"&gt;4&lt;/span&gt;  &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="mi"&gt;14&lt;/span&gt;  &lt;span class="mi"&gt;1&lt;/span&gt;  &lt;span class="mi"&gt;0&lt;/span&gt;  &lt;span class="mi"&gt;2&lt;/span&gt;  &lt;span class="mi"&gt;7&lt;/span&gt;  &lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="mi"&gt;12&lt;/span&gt; &lt;span class="mi"&gt;13&lt;/span&gt; &lt;span class="mi"&gt;11&lt;/span&gt;  &lt;span class="mi"&gt;9&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;  &lt;span class="mi"&gt;8&lt;/span&gt;
&lt;span class="n"&gt;Topological&lt;/span&gt; &lt;span class="nl"&gt;Sort&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
  &lt;span class="mi"&gt;3&lt;/span&gt;  &lt;span class="mi"&gt;1&lt;/span&gt;  &lt;span class="mi"&gt;0&lt;/span&gt;  &lt;span class="mi"&gt;2&lt;/span&gt;  &lt;span class="mi"&gt;7&lt;/span&gt;  &lt;span class="mi"&gt;4&lt;/span&gt;  &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="mi"&gt;14&lt;/span&gt;  &lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="mi"&gt;12&lt;/span&gt; &lt;span class="mi"&gt;13&lt;/span&gt; &lt;span class="mi"&gt;11&lt;/span&gt;  &lt;span class="mi"&gt;9&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;  &lt;span class="mi"&gt;8&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;最重要的一點：只有&lt;strong&gt;directed acyclic graph(DAG)&lt;/strong&gt;的Topological Sort(拓撲排序)才有意義。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以圖二(b)為例，若根據Topological Sort的定義：「若存在一條edge(X,Y)，則序列中，vertex(X)一定要在vertex(Y)之前出現」，那麼，存在edge(fish,rice)，序列可能是「魚、飯、肉、菜」，但是卻也同時存在edge(rice,pork)，序列可能是「飯、肉、菜、魚」，而第二個序列卻違反「存在edge(fish,rice)，魚要在飯之前吃」的限制。&lt;br /&gt;
因此，若directed graph中存在cycle，討論Topological Sort其實沒有什麼幫助。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/TS_fig/f4.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(b)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="algorithm"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;演算法&lt;/h2&gt;
&lt;p&gt;在&lt;a href="http://alrightchiu.github.io/SecondRound/grpah-li-yong-dfsxun-zhao-strongly-connected-componentscc.html"&gt;Grpah: 利用DFS尋找Strongly Connected Component(SCC)&lt;/a&gt;曾經提過DAG的性質：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在DAG上執行一次&lt;code&gt;DFS()&lt;/code&gt;，若存在一條path從vertex(X)到vertex(Y)，那麼&lt;code&gt;finish[X]&lt;/code&gt;一定比&lt;code&gt;finish[Y]&lt;/code&gt;還大。(&lt;a href="http://www.personal.kent.edu/~rmuhamma/Algorithms/MyAlgorithms/GraphAlgor/topoSort.htm"&gt;證明請點這裡&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，只要進行一次&lt;code&gt;DFS()&lt;/code&gt;，並且依照&lt;code&gt;finish[]&lt;/code&gt;由大到小印出vertex，就是Topological Sort(拓撲排序)了。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/TS_fig/f5.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="code"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;程式碼&lt;/h2&gt;
&lt;p&gt;是的，只要把&lt;a href="http://alrightchiu.github.io/SecondRound/grpah-li-yong-dfsxun-zhao-strongly-connected-componentscc.html"&gt;上一篇文章&lt;/a&gt;介紹過的&lt;code&gt;PrintSCCs()&lt;/code&gt;的前半部照抄，就能夠找到&lt;code&gt;finish&lt;/code&gt;由大到小的順序。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;vector&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;list&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;queue&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;iomanip&amp;gt;      &lt;/span&gt;&lt;span class="c1"&gt;// for setw()&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Graph&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;AdjList&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;             &lt;span class="c1"&gt;// 0:white, 1:gray, 2:black&lt;/span&gt;
        &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;distance&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;discover&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;finish&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;Graph&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;){};&lt;/span&gt;
    &lt;span class="n"&gt;Graph&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="c1"&gt;// initialize Adj List&lt;/span&gt;
        &lt;span class="n"&gt;AdjList&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;resize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;};&lt;/span&gt;

    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;GetColor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];};&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;GetFinish&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;finish&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];};&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;GetPredecessor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];};&lt;/span&gt;

    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;BFS&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Start&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;DFS&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Start&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;DFSVisit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;vertex&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;VariableInitializeDFS&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;CCDFS&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;vertex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;     &lt;span class="c1"&gt;// 吃一個int, 表示起點vertex, 若沒給就從0開始&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;CCBFS&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;vertex&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;SetCollapsing&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;vertex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;PrintDataArray&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;PrintFinish&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;PrintPredecessor&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="n"&gt;Graph&lt;/span&gt; &lt;span class="nf"&gt;GraphTranspose&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;PrintSCCs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Start&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;friend&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;QuickSort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;vec&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;front&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;vec2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;friend&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;Partition&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;vec&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;front&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;vec2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;friend&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;TopologicalSort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Start&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Graph&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;TopologicalSort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Start&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;

    &lt;span class="n"&gt;DFS&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Start&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;         &lt;span class="c1"&gt;// 進行一次DFS用來取得 finish[]&lt;/span&gt;

    &lt;span class="c1"&gt;// 矩陣 finishLargetoSmall[] 用來儲存 finish[] 由大至小的vertex順序&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;finishLargetoSmall&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;finishLargetoSmall&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="c1"&gt;// QuickSort()會更新 finishLargetoSmall[] 成 finish[] 由大至小的vertex順序&lt;/span&gt;
    &lt;span class="n"&gt;QuickSort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;finish&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;finishLargetoSmall&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Topological Sort:&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;setw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;finishLargetoSmall&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
    &lt;span class="n"&gt;Graph&lt;/span&gt; &lt;span class="n"&gt;g5&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;            &lt;span class="c1"&gt;// 建立如圖二(a)的DAG&lt;/span&gt;
    &lt;span class="n"&gt;g5&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g5&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g5&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g5&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g5&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g5&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g5&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g5&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;14&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g5&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g5&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g5&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;11&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g5&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g5&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g5&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g5&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;13&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;g5&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;TopologicalSort&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;g5&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;TopologicalSort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;output:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Topological&lt;/span&gt; &lt;span class="nl"&gt;Sort&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
  &lt;span class="mi"&gt;3&lt;/span&gt;  &lt;span class="mi"&gt;4&lt;/span&gt;  &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="mi"&gt;14&lt;/span&gt;  &lt;span class="mi"&gt;1&lt;/span&gt;  &lt;span class="mi"&gt;0&lt;/span&gt;  &lt;span class="mi"&gt;2&lt;/span&gt;  &lt;span class="mi"&gt;7&lt;/span&gt;  &lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="mi"&gt;12&lt;/span&gt; &lt;span class="mi"&gt;13&lt;/span&gt; &lt;span class="mi"&gt;11&lt;/span&gt;  &lt;span class="mi"&gt;9&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;  &lt;span class="mi"&gt;8&lt;/span&gt;
&lt;span class="n"&gt;Topological&lt;/span&gt; &lt;span class="nl"&gt;Sort&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
  &lt;span class="mi"&gt;3&lt;/span&gt;  &lt;span class="mi"&gt;1&lt;/span&gt;  &lt;span class="mi"&gt;0&lt;/span&gt;  &lt;span class="mi"&gt;2&lt;/span&gt;  &lt;span class="mi"&gt;7&lt;/span&gt;  &lt;span class="mi"&gt;4&lt;/span&gt;  &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="mi"&gt;14&lt;/span&gt;  &lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="mi"&gt;12&lt;/span&gt; &lt;span class="mi"&gt;13&lt;/span&gt; &lt;span class="mi"&gt;11&lt;/span&gt;  &lt;span class="mi"&gt;9&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;  &lt;span class="mi"&gt;8&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;以上的做法是另外呼叫一個修改過的&lt;code&gt;QuickSort()&lt;/code&gt;，對額外的矩陣&lt;code&gt;finishLargetoSmall[]&lt;/code&gt;進行排序，優點是不需要更動&lt;code&gt;DFS()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;還有些常見的方法就是修改&lt;code&gt;DFS()&lt;/code&gt;，主要有兩種，發生在當vertex要被標記為「已讀(visited)」或者「塗黑」時：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;把剛剛塗黑的vertex放進&lt;code&gt;stack&lt;/code&gt;中，那麼按照順序，最先被塗黑的vertex就最先被放入&lt;code&gt;stack&lt;/code&gt;的vertex，也就最後被&lt;code&gt;pop()&lt;/code&gt;出&lt;code&gt;stack&lt;/code&gt;。&lt;br /&gt;
因此，對&lt;code&gt;stack&lt;/code&gt;依序進行&lt;code&gt;pop()&lt;/code&gt;便能夠維持&lt;code&gt;finish&lt;/code&gt;由大到小的順序。(&lt;a href="http://www.geeksforgeeks.org/topological-sorting/"&gt;詳見GeeksforGeeks：Topological Sorting&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;或者，把剛剛塗黑的vertex推進(push)一串Linked list，那麼，只要每次都是在Linked list的前端(front)加入vertex，當有下一個vertex被推入Linked list時，先前&lt;code&gt;finish&lt;/code&gt;較小的vertex就被往後挪。&lt;br /&gt;
最後，對Linked list進行一次traversal，得到的vertex順序就會是&lt;code&gt;finish&lt;/code&gt;由大到小。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;以上便是利用&lt;code&gt;DFS()&lt;/code&gt;來尋找DAG的Topological sort(拓撲排序)的介紹。&lt;br /&gt;
基本上是&lt;code&gt;DFS()&lt;/code&gt;的變形/延伸，再一次&lt;code&gt;finish&lt;/code&gt;又扮演關鍵角色拯救了世界。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a name="ref"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;參考資料：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844"&gt;Introduction to Algorithms, Ch22&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376"&gt;Fundamentals of Data Structures in C++, Ch6&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.personal.kent.edu/~rmuhamma/Algorithms/MyAlgorithms/GraphAlgor/topoSort.htm"&gt;Rashid Bin Muhammad：Topological Sort&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.geeksforgeeks.org/topological-sorting/"&gt;GeeksforGeeks：Topological Sorting&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name="series"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h2&gt;Graph系列文章&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/graph-introjian-jie.html"&gt;Graph: Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/graph-breadth-first-searchbfsguang-du-you-xian-sou-xun.html"&gt;Graph: Breadth-First Search(BFS，廣度優先搜尋)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/graph-depth-first-searchdfsshen-du-you-xian-sou-xun.html"&gt;Graph: Depth-First Search(DFS，深度優先搜尋)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/graph-li-yong-dfshe-bfsxun-zhao-connected-component.html"&gt;Graph: 利用DFS和BFS尋找Connected Component&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/grpah-li-yong-dfsxun-zhao-strongly-connected-componentscc.html"&gt;Grpah: 利用DFS尋找Strongly Connected Component(SCC)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/grpah-li-yong-dfsxun-zhao-dagde-topological-sorttuo-pu-pai-xu.html"&gt;Grpah: 利用DFS尋找DAG的Topological Sort(拓撲排序)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;</summary><category term="C++"></category><category term="Graph"></category><category term="DFS"></category><category term="DAG"></category></entry><entry><title>Grpah: 利用DFS尋找Strongly Connected Component(SCC)</title><link href="http://alrightchiu.github.io/SecondRound/grpah-li-yong-dfsxun-zhao-strongly-connected-componentscc.html" rel="alternate"></link><updated>2016-02-17T21:49:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2016-02-17:SecondRound/grpah-li-yong-dfsxun-zhao-strongly-connected-componentscc.html</id><summary type="html">&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;先備知識與注意事項&lt;/h3&gt;
&lt;p&gt;在一個directed graph中，若對於任意兩個vertex(A)與vertex(B)之間，不是同時存在「從vertex(A)走到vertex(B)」以及「從vertex(B)走到vertex(A)」的path，那麼此directed graph就不是strongly connected，裡面一定包含了兩個以上的strongly connected component(SCC)。  &lt;/p&gt;
&lt;p&gt;如圖一(a)，經由path:0-1-2-5，可以從vertex(0)走到vertex(5)，但是無論經過任何vertex，都沒有辦法從vertex(5)走到vertex(0)，因此，圖一(a)的directed graph並不是strongly connected，其中包含了兩個以上的SCC(答案是三個)。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/SCC_fig/f1.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(a)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;那麼，要如何分辨一個directed graph中的strongly connected component(SCC)，並列出每一個SCC中的所有vertex呢？&lt;/p&gt;
&lt;p&gt;本篇文章的目的就是要回應此問題。&lt;/p&gt;
&lt;p&gt;演算法將會用到&lt;strong&gt;Transpose of Graph&lt;/strong&gt;，如圖一(b)，把G中所有vertex維持不變，&lt;strong&gt;edge的方向顛倒&lt;/strong&gt;，就得到G&lt;sup&gt;T&lt;/sup&gt;，例如，原本的edge(0,1)改為edge(1,0)，edge(5,6)改為edge(6,5)。  &lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/SCC_fig/f2.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(b)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;最重要的是：&lt;strong&gt;G與G&lt;sup&gt;T&lt;/sup&gt;的SCC完全相同&lt;/strong&gt;。  &lt;/p&gt;
&lt;p&gt;原因在於，觀察G中包含在同一個SCC裡的vertex(2)與vertex(3)。G中同時存在「從vertex(2)走到vertex(3)」的path，以及「從vertex(3)走到vertex(2)」的path。在G進行「Transpose」得到G&lt;sup&gt;T&lt;/sup&gt;後，這兩條path分別變成與原方向之相反方向，但是存在於vertex(2)與vertex(3)之間的&lt;strong&gt;cycle&lt;/strong&gt;仍然存在。&lt;br /&gt;
因此，在G裡面屬於同一個SCC的vertex，在G&lt;sup&gt;T&lt;/sup&gt;裡將形成相同的SCC。 &lt;/p&gt;
&lt;p&gt;最後一點溫馨小提醒：一如往常，本篇文章將不會有嚴謹證明，不過在&lt;a href="#ref"&gt;參考資料&lt;/a&gt;會附上內有嚴謹證明的網站連結，請讀者務必前往一窺究竟。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#if_dfs_only"&gt;如果只有一次DFS()不行嗎？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#algorithm"&gt;演算法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#code"&gt;程式碼&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#ref"&gt;參考資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#series"&gt;Graph系列文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="if_dfs_only"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;如果只有一次DFS()不行嗎？&lt;/h2&gt;
&lt;p&gt;在&lt;a href="http://alrightchiu.github.io/SecondRound/graph-li-yong-dfshe-bfsxun-zhao-connected-component.html"&gt;上一篇文章&lt;/a&gt;提到，只用一次&lt;code&gt;DFS()&lt;/code&gt;或&lt;code&gt;BFS()&lt;/code&gt;得到&lt;code&gt;predecessor&lt;/code&gt;後，便能夠找到undirected graph中的connected component。&lt;/p&gt;
&lt;p&gt;那如果用來找SCC？&lt;/p&gt;
&lt;p&gt;以下示範兩次&lt;code&gt;DFS()&lt;/code&gt;來說明，一次是按照「&lt;span class="math"&gt;\(8、7、...、2、1\)&lt;/span&gt;」之順序把vertex設為搜尋起點，另一次則是按照「&lt;span class="math"&gt;\(1、2、...、7、8\)&lt;/span&gt;」之順序。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/SCC_fig/f3.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(a)：以vertex(8)作為起點，接著是vertex(5)、vertex(3)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;圖二(a)，首先以vertex(8)作為&lt;code&gt;DFS()&lt;/code&gt;的第一次起點，在搜尋完以vertex(8)作為&lt;code&gt;root&lt;/code&gt;的Depth-First Tree後，再以vertex(5)作為新的起點。同樣的，在搜尋完以vertex(5)作為&lt;code&gt;root&lt;/code&gt;的Depth-First Tree後，再以vertex(3)作為新的起點。&lt;br /&gt;
從圖二(a)的「時間軸」可以看出，此次&lt;code&gt;DFS()&lt;/code&gt;找到了一個Depth-First Forest，其中包含三棵Depth-First Tree，而這三棵Depth-First Tree分別就是Graph中的三個SCC。&lt;/p&gt;
&lt;p&gt;問題不就解決了嗎？&lt;br /&gt;
透過一次&lt;code&gt;DFS()&lt;/code&gt;就找到了directed graph中的SCC。&lt;/p&gt;
&lt;p&gt;再接著看圖二(b)，以vertex(0)作為&lt;code&gt;DFS()&lt;/code&gt;的起點。&lt;br /&gt;
很遺憾，「時間軸」裡形成了一整棵Depth-First Tree，directed graph中的三個SCC沒有被分開。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/SCC_fig/f4.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(b)：以vertex(0)作為起點。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;由於SCC需要兩個方向的path(「vertex(X)到vertex(Y)」和「vertex(Y)到vertex(X)」)都成立，但是&lt;code&gt;DFS()&lt;/code&gt;只在意「單方向」的edge，只要存在edge(X,Y)，便把&lt;code&gt;predecessor[Y]&lt;/code&gt;更新成vertex(X)，在Predecessor Subgraph裡，vertex(X)與vertex(Y)便在同一棵Depth-First Tree中。  &lt;/p&gt;
&lt;p&gt;因此，只有一次&lt;code&gt;DFS()&lt;/code&gt;的&lt;code&gt;predecessor&lt;/code&gt;是不夠的，圖二(a)只是運氣好。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;
以下便開始本次的「拒絕運氣好大作戰」。&lt;br /&gt;
&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="algorithm"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;演算法&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;若考慮具有多個SCC的directed graph，為了方便起見，定義其&lt;strong&gt;Component Graph&lt;/strong&gt;為&lt;span class="math"&gt;\(G^{SCC}=(V^{SCC},E^{SCC})\)&lt;/span&gt;，其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class="math"&gt;\(V^{SCC}\)&lt;/span&gt;：把每個SCC視為一個元素，並以該元素作為&lt;span class="math"&gt;\(V^{SCC}\)&lt;/span&gt;的vertex。&lt;ul&gt;
&lt;li&gt;例如圖三(a)，令&lt;span class="math"&gt;\(C_1=\)&lt;/span&gt;{&lt;span class="math"&gt;\(0,1,2,3\)&lt;/span&gt;}，&lt;span class="math"&gt;\(C_2=\)&lt;/span&gt;{&lt;span class="math"&gt;\(4,5\)&lt;/span&gt;}，&lt;span class="math"&gt;\(C_3=\)&lt;/span&gt;{&lt;span class="math"&gt;\(6,7,8\)&lt;/span&gt;}，則&lt;span class="math"&gt;\(V^{SCC}=\)&lt;/span&gt;{&lt;span class="math"&gt;\(C_1,C_2,C_3\)&lt;/span&gt;}。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(E^{SCC}\)&lt;/span&gt;：考慮vertex(X)屬於&lt;span class="math"&gt;\(C_1\)&lt;/span&gt;，vertex(Y)屬於&lt;span class="math"&gt;\(C_2\)&lt;/span&gt;，若存在「連結兩個不同SCC」的edge(X,Y)，則edge(X,Y)便屬於&lt;span class="math"&gt;\(E^{SCC}\)&lt;/span&gt;。&lt;ul&gt;
&lt;li&gt;以圖三(a)為例，vertex(1)屬於&lt;span class="math"&gt;\(C_1\)&lt;/span&gt;，vertex(4)屬於&lt;span class="math"&gt;\(C_2\)&lt;/span&gt;，則edge(1,4)屬於&lt;span class="math"&gt;\(E^{SCC}\)&lt;/span&gt;，依此類推，便得到&lt;span class="math"&gt;\(E^{SCC}=\)&lt;/span&gt;{&lt;span class="math"&gt;\((1,4),(2,5),(4,6),(5,6),(5,7)\)&lt;/span&gt;}。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/SCC_fig/f5.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(a)：每一個directed graph，只要「以SCC作為基本元素(vertex)」，都會有其相對應的component graph。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;由上述定義可以觀察出，每一個directed graph，只要「以SCC作為基本元素(vertex)」，都會有其相對應的component graph。&lt;/p&gt;
&lt;p&gt;而使用component graph的優點是：「component graph一定是&lt;strong&gt;directed acyclic graph(DAG)&lt;/strong&gt;」。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;因為SCC的定義&lt;a href="http://alrightchiu.github.io/SecondRound/graph-introjian-jie.html"&gt;(請參閱：Graph: Intro(簡介))&lt;/a&gt;，若C&lt;sub&gt;1&lt;/sub&gt;與C&lt;sub&gt;2&lt;/sub&gt;之前存在&lt;strong&gt;cycle&lt;/strong&gt;，那就表示C&lt;sub&gt;1&lt;/sub&gt;和C&lt;sub&gt;2&lt;/sub&gt;都不應該自稱為SCC，而要合併C&lt;sub&gt;1&lt;/sub&gt;與C&lt;sub&gt;2&lt;/sub&gt;成為一個更大集合的SCC。因此，不同的SCC之間，一定不存在&lt;strong&gt;cycle&lt;/strong&gt;。  &lt;/li&gt;
&lt;li&gt;等價的性質：若directed graph中存在兩個SCC，分別為C&lt;sub&gt;1&lt;/sub&gt;與C&lt;sub&gt;2&lt;/sub&gt;，若存在一條path從C&lt;sub&gt;1&lt;/sub&gt;中的vertex(X)走到C&lt;sub&gt;2&lt;/sub&gt;中的vertex(Y)，就不可能同時存在一條path從C&lt;sub&gt;2&lt;/sub&gt;中的vertex(Z)走到C&lt;sub&gt;1&lt;/sub&gt;中的vertex(W)，否則即出現&lt;strong&gt;cycle&lt;/strong&gt;，應該合併成更大的SCC(C&lt;sub&gt;3&lt;/sub&gt;)，如圖三(b)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/SCC_fig/f6.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(b)：SCC。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;考慮如圖三(c)的DAG(directed acyclic graph)，若&lt;code&gt;DFS()&lt;/code&gt;在每次尋找「新的搜尋起點時」，能夠按照「一條path上，從尾端至開頭」的vertex順序，那麼&lt;strong&gt;Predecessor Subgraph&lt;/strong&gt;就能長成「能夠分辨出SCC」的&lt;strong&gt;Depth-First Forest&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;圖三(c)中，由於從C&lt;sub&gt;3&lt;/sub&gt;無法往回走到C&lt;sub&gt;2&lt;/sub&gt;，從C&lt;sub&gt;2&lt;/sub&gt;無法往回走到C&lt;sub&gt;1&lt;/sub&gt;，因此，&lt;code&gt;DFS()&lt;/code&gt;的起點順序若為：C&lt;sub&gt;3&lt;/sub&gt;、C&lt;sub&gt;2&lt;/sub&gt;、C&lt;sub&gt;1&lt;/sub&gt;，就能夠把這三個component graph中的vertex(也就是directed graph的SCC)給分開。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/SCC_fig/f7.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(c)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;那麼，該如何確保每一次都能找到「一條path上，從尾端至開頭的vertex順序」？&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/SCC_fig/f8.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(d)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;再觀察圖三(d)，分別以起點順序「C&lt;sub&gt;2&lt;/sub&gt;、C&lt;sub&gt;3&lt;/sub&gt;、C&lt;sub&gt;1&lt;/sub&gt;」與起點順序「C&lt;sub&gt;1&lt;/sub&gt;、C&lt;sub&gt;2&lt;/sub&gt;、C&lt;sub&gt;3&lt;/sub&gt;」進行&lt;code&gt;DFS()&lt;/code&gt;，配合圖三(c)，將發現，不論以哪個vertex作為起點，「&lt;code&gt;finish&lt;/code&gt;的大小順序一定是C&lt;sub&gt;1&lt;/sub&gt;、C&lt;sub&gt;2&lt;/sub&gt;、C&lt;sub&gt;3&lt;/sub&gt;」。&lt;/p&gt;
&lt;p&gt;更廣義地，假設現有C&lt;sub&gt;1&lt;/sub&gt;與C&lt;sub&gt;2&lt;/sub&gt;分別為directed graph中兩個互斥(disjoint)的SCC，並且vertex(X)屬於C&lt;sub&gt;1&lt;/sub&gt;，vertex(Y)屬於C&lt;sub&gt;2&lt;/sub&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若directed graph中存在edge(X,Y)，那麼，C&lt;sub&gt;1&lt;/sub&gt;集合中所有vertex的「最大&lt;code&gt;finish&lt;/code&gt;」一定比C&lt;sub&gt;2&lt;/sub&gt;集合中所有vertex的「最大&lt;code&gt;finish&lt;/code&gt;」還要大。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以圖三(e)為例，component graph的&lt;span class="math"&gt;\(E^{SCC}\)&lt;/span&gt;存在「從C&lt;sub&gt;1&lt;/sub&gt;指向C&lt;sub&gt;2&lt;/sub&gt;」以及「從C&lt;sub&gt;2&lt;/sub&gt;指向C&lt;sub&gt;3&lt;/sub&gt;」的edge，因此，若以SCC中vertex的「最大&lt;code&gt;finish&lt;/code&gt;」代表&lt;code&gt;finish[SCC]&lt;/code&gt;，&lt;code&gt;finish&lt;/code&gt;的大小順序應為：&lt;code&gt;finish[C1]&lt;/code&gt;&amp;gt;&lt;code&gt;finish[C2]&lt;/code&gt;&amp;gt;&lt;code&gt;finish[C3]&lt;/code&gt;，其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class="math"&gt;\(C_1=\)&lt;/span&gt;{&lt;span class="math"&gt;\(0,1,2,3\)&lt;/span&gt;}，&lt;code&gt;finish[C1]&lt;/code&gt;&lt;span class="math"&gt;\(=\)&lt;/span&gt;&lt;code&gt;finish[3]&lt;/code&gt;&lt;span class="math"&gt;\(=18\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(C_2=\)&lt;/span&gt;{&lt;span class="math"&gt;\(4,5\)&lt;/span&gt;}，&lt;code&gt;finish[C2]&lt;/code&gt;&lt;span class="math"&gt;\(=\)&lt;/span&gt;&lt;code&gt;finish[5]&lt;/code&gt;&lt;span class="math"&gt;\(=10\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(C_3=\)&lt;/span&gt;{&lt;span class="math"&gt;\(6,7,8\)&lt;/span&gt;}，&lt;code&gt;finish[C3]&lt;/code&gt;&lt;span class="math"&gt;\(=\)&lt;/span&gt;&lt;code&gt;finish[8]&lt;/code&gt;&lt;span class="math"&gt;\(=6\)&lt;/span&gt;。  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/SCC_fig/f9.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(e)：。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;考慮圖三(f)，仍然符合：&lt;code&gt;finish[C1]&lt;/code&gt;&amp;gt;&lt;code&gt;finish[C2]&lt;/code&gt;&amp;gt;&lt;code&gt;finish[C3]&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;finish[C1]&lt;/code&gt;&lt;span class="math"&gt;\(=\)&lt;/span&gt;&lt;code&gt;finish[0]&lt;/code&gt;&lt;span class="math"&gt;\(=18\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;finish[C2]&lt;/code&gt;&lt;span class="math"&gt;\(=\)&lt;/span&gt;&lt;code&gt;finish[5]&lt;/code&gt;&lt;span class="math"&gt;\(=15\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;finish[C3]&lt;/code&gt;&lt;span class="math"&gt;\(=\)&lt;/span&gt;&lt;code&gt;finish[6]&lt;/code&gt;&lt;span class="math"&gt;\(=13\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/SCC_fig/f10.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(f)：。&lt;/strong&gt; 
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;由以上推論，可以更新在圖三(c)時的說明至更廣義的結論：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只要按照「&lt;code&gt;finish&lt;/code&gt;小到大」的順序選取SCC中的vertex作為&lt;code&gt;DFS()&lt;/code&gt;的起點，就能夠在&lt;strong&gt;Predecessor Subgraph&lt;/strong&gt;中以&lt;strong&gt;Depth-First Forest&lt;/strong&gt;分辨出所有SCC。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;到這裡為止，可以確認：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;需要第一次&lt;code&gt;DFS()&lt;/code&gt;先取得&lt;code&gt;finish&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;再根據剛取得的&lt;code&gt;finish&lt;/code&gt;之「順序」來判斷「第二次&lt;code&gt;DFS()&lt;/code&gt;」的起點順序。&lt;/li&gt;
&lt;li&gt;進行第二次&lt;code&gt;DFS()&lt;/code&gt;來取得&lt;code&gt;predecessor&lt;/code&gt;，並利用Predecessor Subgraph分辨出SCC。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;但是問題又來了。&lt;br /&gt;
如果真的是按照「第一次&lt;code&gt;finish&lt;/code&gt;由小到大」的順序選取SCC中的vertex作為第二次&lt;code&gt;DFS()&lt;/code&gt;的起點，還是有可能失敗，因為第一次&lt;code&gt;DFS()&lt;/code&gt;在選取起點時，並沒有對SCC的先備知識，可以視為隨機選取：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若第一次&lt;code&gt;DFS()&lt;/code&gt;結果如圖三(e)，則按照「&lt;code&gt;finish&lt;/code&gt;由小到大」的順序選取起點，將依序選中「vertex(7)、vertex(4)、vertex(1)」作為起點進行第二次&lt;code&gt;DFS()&lt;/code&gt;，那麼將得到如圖三(g)之結果，順利區分三個SCC。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/SCC_fig/f11.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(g)：。&lt;/strong&gt; 
&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;但是如果第一次&lt;code&gt;DFS()&lt;/code&gt;結果如圖三(f)，按照「&lt;code&gt;finish&lt;/code&gt;由小到大」的順序選取起點，只會選中vertex(3)作為起點，便把整個Graph搜尋完畢，最後Predecessor Subgraph又形成一整棵Depth-First Tree，如圖三(h)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/SCC_fig/f12.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(h)：。&lt;/strong&gt; 
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;所以，先在Graph:G上執行第一次&lt;code&gt;DFS()&lt;/code&gt;，得到&lt;code&gt;finish&lt;/code&gt;後，按照&lt;code&gt;finish&lt;/code&gt;由小到大的順序，作為第二次在Graph:G上執行&lt;code&gt;DFS()&lt;/code&gt;的起點之方法，宣告失敗。&lt;/p&gt;
&lt;p&gt;不過，還好有&lt;strong&gt;Transpose of Graph: G&lt;sup&gt;T&lt;/sup&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/SCC_fig/f13.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(i)：。&lt;/strong&gt; 
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;觀察圖三(i)中的G與G&lt;sup&gt;T&lt;/sup&gt;，發現：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;兩個Graph的SCC完全相同，皆為C&lt;sub&gt;1&lt;/sub&gt;、C&lt;sub&gt;2&lt;/sub&gt;、C&lt;sub&gt;3&lt;/sub&gt;。&lt;/li&gt;
&lt;li&gt;SCC的&lt;code&gt;finish&lt;/code&gt;順序完全相反。&lt;ul&gt;
&lt;li&gt;在G上，從C&lt;sub&gt;3&lt;/sub&gt;無法往回走到C&lt;sub&gt;2&lt;/sub&gt;，從C&lt;sub&gt;2&lt;/sub&gt;無法往回走到C&lt;sub&gt;1&lt;/sub&gt;。&lt;/li&gt;
&lt;li&gt;在G&lt;sup&gt;T&lt;/sup&gt;上，從C&lt;sub&gt;1&lt;/sub&gt;無法往回走到C&lt;sub&gt;2&lt;/sub&gt;，從C&lt;sub&gt;2&lt;/sub&gt;無法往回走到C&lt;sub&gt;3&lt;/sub&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根據以上特徵，若先在Graph:G上執行第一次&lt;code&gt;DFS()&lt;/code&gt;，得到&lt;code&gt;finish&lt;/code&gt;後，按照&lt;code&gt;finish&lt;/code&gt;由大到小的順序，會是「C&lt;sub&gt;1&lt;/sub&gt;、C&lt;sub&gt;2&lt;/sub&gt;、C&lt;sub&gt;3&lt;/sub&gt;」，而&lt;strong&gt;這個順序在Transpose of Graph: G&lt;sup&gt;T&lt;/sup&gt;，就正好是「&lt;/strong&gt;&lt;code&gt;finish&lt;/code&gt;&lt;strong&gt;小到大」的順序&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;因此，以「第一次&lt;code&gt;DFS()&lt;/code&gt;所得到的&lt;code&gt;finish&lt;/code&gt;之由大到小順序」選取起點，在G&lt;sup&gt;T&lt;/sup&gt;上進行第二次&lt;code&gt;DFS()&lt;/code&gt;，就可以先選到C&lt;sub&gt;1&lt;/sub&gt;，由於無法從C&lt;sub&gt;1&lt;/sub&gt;走回C&lt;sub&gt;2&lt;/sub&gt;，因此&lt;code&gt;DFS()&lt;/code&gt;在搜尋完C&lt;sub&gt;1&lt;/sub&gt;內的所有vertex後，便形成自己的Depth-First Tree。接著再依序挑選C&lt;sub&gt;2&lt;/sub&gt;、C&lt;sub&gt;3&lt;/sub&gt;為起點進行搜尋，並且建立起各自SCC的Depth-First Tree。&lt;/p&gt;
&lt;p&gt;如此一來，便找到了directed graph中的SCC。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="code"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;程式碼&lt;/h2&gt;
&lt;p&gt;根據以上說明，演算法分成四個步驟：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;對G執行&lt;code&gt;DFS()&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;產生G&lt;sup&gt;T&lt;/sup&gt;。&lt;/li&gt;
&lt;li&gt;按照第一次&lt;code&gt;DFS()&lt;/code&gt;所得到的&lt;code&gt;finish&lt;/code&gt;由大到小的順序選取起點，對G&lt;sup&gt;T&lt;/sup&gt;執行&lt;code&gt;DFS()&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;從第二次&lt;code&gt;DFS()&lt;/code&gt;的&lt;code&gt;predecessor&lt;/code&gt;找到Predecessor Subgraph。若directed graph有多個SCC，那麼Predecessor Subgraph就會是Depth-First Forest，其中的每一棵Depth-First Tree都是一個SCC。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;範例程式碼延續上一篇文章定義的&lt;code&gt;class Graph&lt;/code&gt;，主要多了幾個函式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;GetColor()&lt;/code&gt;、&lt;code&gt;GetFinish()&lt;/code&gt;、&lt;code&gt;GetPredecessor&lt;/code&gt;：用來取得&lt;code&gt;color&lt;/code&gt;、&lt;code&gt;finish&lt;/code&gt;、&lt;code&gt;predecessor&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GraphTranspose()&lt;/code&gt;：產生G&lt;sup&gt;T&lt;/sup&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;VariableInitializeDFS()&lt;/code&gt;：把原先&lt;code&gt;DFS()&lt;/code&gt;主函式中，「配置記憶體」與「初始化」資料的部分獨立出來。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;QuickSort()&lt;/code&gt;等三個函式：用來得到&lt;code&gt;finish&lt;/code&gt;由大致小的vertex順序。&lt;ul&gt;
&lt;li&gt;若共有6個vertex，經過一次&lt;code&gt;DFS()&lt;/code&gt;後得到&lt;code&gt;finish&lt;/code&gt;如圖四，那麼&lt;code&gt;QuickSort()&lt;/code&gt;將會對&lt;code&gt;finish&lt;/code&gt;進行排序，並且在排序的過程，一併將&lt;code&gt;finish&lt;/code&gt;原先對應的vertex排序後，放入&lt;code&gt;finishLargetoSmall&lt;/code&gt;。之後再利用&lt;code&gt;finishLargetoSmall&lt;/code&gt;的順序，進行第二次&lt;code&gt;DFS()&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PrintSCCs()&lt;/code&gt;：尋找SCC最主要的函式，主要包含上述的四個步驟。(其中有許多用以顯示資料項的指令，與尋找SCC無關)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/SCC_fig/f18.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四：。&lt;/strong&gt; 
&lt;/center&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;vector&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;list&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;queue&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;iomanip&amp;gt;      &lt;/span&gt;&lt;span class="c1"&gt;// for std::setw()&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Graph&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;AdjList&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;             &lt;span class="c1"&gt;// 0:white, 1:gray, 2:black&lt;/span&gt;
        &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;distance&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;          &lt;span class="c1"&gt;// for BFS()&lt;/span&gt;
        &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;discover&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;          &lt;span class="c1"&gt;// for DFS()&lt;/span&gt;
        &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;finish&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;Graph&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;){};&lt;/span&gt;
    &lt;span class="n"&gt;Graph&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="c1"&gt;// initialize Adj List&lt;/span&gt;
        &lt;span class="n"&gt;AdjList&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;resize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;};&lt;/span&gt;

    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;GetColor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];};&lt;/span&gt;              &lt;span class="c1"&gt;// 取得private data: color&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;GetFinish&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;finish&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];};&lt;/span&gt;            &lt;span class="c1"&gt;// 取得private data: finish&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;GetPredecessor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];};&lt;/span&gt;  &lt;span class="c1"&gt;// 取得private data: predecessor&lt;/span&gt;

    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;BFS&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Start&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;DFS&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Start&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;DFSVisit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;vertex&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;VariableInitializeDFS&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;     &lt;span class="c1"&gt;// 對DFS()需要的資料：color, discover, finish, predecessor&lt;/span&gt;
                                      &lt;span class="c1"&gt;// 進行「配置記憶體」與「初始化」&lt;/span&gt;

    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;CCDFS&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;vertex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;           &lt;span class="c1"&gt;// 吃一個int, 表示起點vertex, 若沒給就從0開始&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;CCBFS&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;vertex&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;SetCollapsing&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;vertex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;PrintDataArray&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  &lt;span class="c1"&gt;// 列印出array[]&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;PrintFinish&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;               &lt;span class="c1"&gt;// 列印出 finish[]&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;PrintPredecessor&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;          &lt;span class="c1"&gt;// 列印出 predecessor[]&lt;/span&gt;

    &lt;span class="n"&gt;Graph&lt;/span&gt; &lt;span class="nf"&gt;GraphTranspose&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;           &lt;span class="c1"&gt;// 產生Transpose of Graph&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;PrintSCCs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Start&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;    &lt;span class="c1"&gt;// 吃一個int, 表示起點vertex, 若沒給就從0開始&lt;/span&gt;

    &lt;span class="c1"&gt;// 利用QuickSort()得到 finish[] 由大致小的vertex順序&lt;/span&gt;
    &lt;span class="k"&gt;friend&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;QuickSort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;vec&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;front&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;vec2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;friend&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;Partition&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;vec&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;front&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;vec2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;friend&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;temp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;Partition&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;vec&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;front&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;vec2&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;pivot&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;vec&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;front&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;front&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vec&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;pivot&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;vec&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;vec&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
            &lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;vec2&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;vec2&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;vec&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;vec&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
    &lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;vec2&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;vec2&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="c1"&gt;// 把 i + 1 當成下一個 recurrsive call 的 中間斷點&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;QuickSort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;vec&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;front&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;vec2&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;front&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;pivot&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Partition&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vec&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;front&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;vec2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;QuickSort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vec&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;front&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pivot&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;vec2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;QuickSort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vec&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pivot&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;vec2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Graph&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;PrintSCCs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Start&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="c1"&gt;// 第一次DFS(), 目的是取得finish[]&lt;/span&gt;
    &lt;span class="n"&gt;DFS&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Start&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="c1"&gt;// 顯示 第一次DFS()後的finish[]&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;First DFS() on G, finish time:&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;PrintFinish&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="c1"&gt;// gT代表Transpose of Graph&lt;/span&gt;
    &lt;span class="n"&gt;Graph&lt;/span&gt; &lt;span class="nf"&gt;gT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;gT&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;GraphTranspose&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="c1"&gt;// 矩陣 finishLargetoSmall[] 用來儲存 finish[] 由大至小的vertex順序&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;finishLargetoSmall&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;finishLargetoSmall&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="c1"&gt;// QuickSort()會更新 finishLargetoSmall[] 成 finish[] 由大至小的vertex順序&lt;/span&gt;
    &lt;span class="n"&gt;QuickSort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;finish&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;finishLargetoSmall&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="c1"&gt;// 列印出 finish[] 由大至小的vertex順序&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;finish time Large to Small:&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;PrintDataArray&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;finishLargetoSmall&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="c1"&gt;// 第二次DFS(), 執行在gT上, 先對四個資料「配置記憶體」且「初始化」&lt;/span&gt;
    &lt;span class="n"&gt;gT&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;VariableInitializeDFS&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;time&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gT&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;GetColor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;finishLargetoSmall&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;gT&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DFSVisit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;finishLargetoSmall&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="c1"&gt;// 顯示 第二次DFS()後的finish[]&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Second DFS() on gT, finish time:&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;gT&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PrintFinish&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="c1"&gt;// 顯示 第二次DFS()後的predecessor[]&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;predecessor[] before SetCollapsing:&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;gT&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PrintPredecessor&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;gT&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SetCollapsing&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="c1"&gt;// 顯示 SetCollapsing後的predecessor[]&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;predecessor after SetCollapsing:&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;gT&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PrintPredecessor&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="c1"&gt;// 如同在undirected graph中尋找connected component&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;num_cc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gT&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;GetPredecessor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;SCC#&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;num_cc&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot; &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gT&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;GetPredecessor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot; &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="p"&gt;}&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
            &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Graph&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;VariableInitializeDFS&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
    &lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="n"&gt;discover&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="n"&gt;finish&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="n"&gt;predecessor&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;discover&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;finish&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;Graph&lt;/span&gt; &lt;span class="n"&gt;Graph&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;GraphTranspose&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
    &lt;span class="n"&gt;Graph&lt;/span&gt; &lt;span class="n"&gt;gT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;iterator&lt;/span&gt; &lt;span class="n"&gt;itr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;AdjList&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="n"&gt;itr&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;AdjList&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="n"&gt;itr&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;gT&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;itr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;gT&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Graph&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;PrintDataArray&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;setw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;setw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Graph&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;PrintFinish&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;setw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;setw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;finish&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Graph&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;PrintPredecessor&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;setw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;setw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
    &lt;span class="n"&gt;Graph&lt;/span&gt; &lt;span class="n"&gt;g4&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g4&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g4&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g4&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g4&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g4&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g4&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g4&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g4&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g4&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g4&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g4&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g4&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g4&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g4&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g4&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Vertex(0) as starting point for the First DFS():&lt;/span&gt;&lt;span class="se"&gt;\n\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;g4&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PrintSCCs&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Vertex(3) as starting point for the First DFS():&lt;/span&gt;&lt;span class="se"&gt;\n\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;g4&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PrintSCCs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;output:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Vertex&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="n"&gt;starting&lt;/span&gt; &lt;span class="n"&gt;point&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;First&lt;/span&gt; &lt;span class="n"&gt;DFS&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;

&lt;span class="n"&gt;First&lt;/span&gt; &lt;span class="n"&gt;DFS&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="n"&gt;on&lt;/span&gt; &lt;span class="n"&gt;G&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;finish&lt;/span&gt; &lt;span class="nl"&gt;time&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;2&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;   &lt;span class="mi"&gt;4&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt;   &lt;span class="mi"&gt;6&lt;/span&gt;   &lt;span class="mi"&gt;7&lt;/span&gt;   &lt;span class="mi"&gt;8&lt;/span&gt;
  &lt;span class="mi"&gt;18&lt;/span&gt;  &lt;span class="mi"&gt;17&lt;/span&gt;  &lt;span class="mi"&gt;16&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt;  &lt;span class="mi"&gt;14&lt;/span&gt;  &lt;span class="mi"&gt;15&lt;/span&gt;  &lt;span class="mi"&gt;13&lt;/span&gt;  &lt;span class="mi"&gt;12&lt;/span&gt;  &lt;span class="mi"&gt;11&lt;/span&gt;
&lt;span class="n"&gt;finish&lt;/span&gt; &lt;span class="n"&gt;time&lt;/span&gt; &lt;span class="n"&gt;Large&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="nl"&gt;Small&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;2&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;   &lt;span class="mi"&gt;4&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt;   &lt;span class="mi"&gt;6&lt;/span&gt;   &lt;span class="mi"&gt;7&lt;/span&gt;   &lt;span class="mi"&gt;8&lt;/span&gt;
   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;2&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt;   &lt;span class="mi"&gt;4&lt;/span&gt;   &lt;span class="mi"&gt;6&lt;/span&gt;   &lt;span class="mi"&gt;7&lt;/span&gt;   &lt;span class="mi"&gt;8&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;
&lt;span class="n"&gt;Second&lt;/span&gt; &lt;span class="n"&gt;DFS&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="n"&gt;on&lt;/span&gt; &lt;span class="n"&gt;gT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;finish&lt;/span&gt; &lt;span class="nl"&gt;time&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;2&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;   &lt;span class="mi"&gt;4&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt;   &lt;span class="mi"&gt;6&lt;/span&gt;   &lt;span class="mi"&gt;7&lt;/span&gt;   &lt;span class="mi"&gt;8&lt;/span&gt;
   &lt;span class="mi"&gt;8&lt;/span&gt;   &lt;span class="mi"&gt;4&lt;/span&gt;   &lt;span class="mi"&gt;7&lt;/span&gt;   &lt;span class="mi"&gt;6&lt;/span&gt;  &lt;span class="mi"&gt;11&lt;/span&gt;  &lt;span class="mi"&gt;12&lt;/span&gt;  &lt;span class="mi"&gt;18&lt;/span&gt;  &lt;span class="mi"&gt;16&lt;/span&gt;  &lt;span class="mi"&gt;17&lt;/span&gt;
&lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;before&lt;/span&gt; &lt;span class="nl"&gt;SetCollapsing&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;2&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;   &lt;span class="mi"&gt;4&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt;   &lt;span class="mi"&gt;6&lt;/span&gt;   &lt;span class="mi"&gt;7&lt;/span&gt;   &lt;span class="mi"&gt;8&lt;/span&gt;
  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;2&lt;/span&gt;   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;2&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt;  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;8&lt;/span&gt;   &lt;span class="mi"&gt;6&lt;/span&gt;
&lt;span class="n"&gt;predecessor&lt;/span&gt; &lt;span class="n"&gt;after&lt;/span&gt; &lt;span class="nl"&gt;SetCollapsing&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;2&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;   &lt;span class="mi"&gt;4&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt;   &lt;span class="mi"&gt;6&lt;/span&gt;   &lt;span class="mi"&gt;7&lt;/span&gt;   &lt;span class="mi"&gt;8&lt;/span&gt;
  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt;  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;6&lt;/span&gt;   &lt;span class="mi"&gt;6&lt;/span&gt;
&lt;span class="n"&gt;SCC&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; 
&lt;span class="n"&gt;SCC&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; 
&lt;span class="n"&gt;SCC&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt; 

&lt;span class="n"&gt;Vertex&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="n"&gt;starting&lt;/span&gt; &lt;span class="n"&gt;point&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;First&lt;/span&gt; &lt;span class="n"&gt;DFS&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;

&lt;span class="n"&gt;First&lt;/span&gt; &lt;span class="n"&gt;DFS&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="n"&gt;on&lt;/span&gt; &lt;span class="n"&gt;G&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;finish&lt;/span&gt; &lt;span class="nl"&gt;time&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;2&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;   &lt;span class="mi"&gt;4&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt;   &lt;span class="mi"&gt;6&lt;/span&gt;   &lt;span class="mi"&gt;7&lt;/span&gt;   &lt;span class="mi"&gt;8&lt;/span&gt;
  &lt;span class="mi"&gt;16&lt;/span&gt;  &lt;span class="mi"&gt;15&lt;/span&gt;  &lt;span class="mi"&gt;17&lt;/span&gt;  &lt;span class="mi"&gt;18&lt;/span&gt;  &lt;span class="mi"&gt;14&lt;/span&gt;  &lt;span class="mi"&gt;13&lt;/span&gt;  &lt;span class="mi"&gt;12&lt;/span&gt;  &lt;span class="mi"&gt;11&lt;/span&gt;  &lt;span class="mi"&gt;10&lt;/span&gt;
&lt;span class="n"&gt;finish&lt;/span&gt; &lt;span class="n"&gt;time&lt;/span&gt; &lt;span class="n"&gt;Large&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="nl"&gt;Small&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;2&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;   &lt;span class="mi"&gt;4&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt;   &lt;span class="mi"&gt;6&lt;/span&gt;   &lt;span class="mi"&gt;7&lt;/span&gt;   &lt;span class="mi"&gt;8&lt;/span&gt;
   &lt;span class="mi"&gt;3&lt;/span&gt;   &lt;span class="mi"&gt;2&lt;/span&gt;   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;4&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt;   &lt;span class="mi"&gt;6&lt;/span&gt;   &lt;span class="mi"&gt;7&lt;/span&gt;   &lt;span class="mi"&gt;8&lt;/span&gt;
&lt;span class="n"&gt;Second&lt;/span&gt; &lt;span class="n"&gt;DFS&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="n"&gt;on&lt;/span&gt; &lt;span class="n"&gt;gT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;finish&lt;/span&gt; &lt;span class="nl"&gt;time&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;2&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;   &lt;span class="mi"&gt;4&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt;   &lt;span class="mi"&gt;6&lt;/span&gt;   &lt;span class="mi"&gt;7&lt;/span&gt;   &lt;span class="mi"&gt;8&lt;/span&gt;
   &lt;span class="mi"&gt;5&lt;/span&gt;   &lt;span class="mi"&gt;6&lt;/span&gt;   &lt;span class="mi"&gt;7&lt;/span&gt;   &lt;span class="mi"&gt;8&lt;/span&gt;  &lt;span class="mi"&gt;12&lt;/span&gt;  &lt;span class="mi"&gt;11&lt;/span&gt;  &lt;span class="mi"&gt;18&lt;/span&gt;  &lt;span class="mi"&gt;16&lt;/span&gt;  &lt;span class="mi"&gt;17&lt;/span&gt;
&lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;before&lt;/span&gt; &lt;span class="nl"&gt;SetCollapsing&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;2&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;   &lt;span class="mi"&gt;4&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt;   &lt;span class="mi"&gt;6&lt;/span&gt;   &lt;span class="mi"&gt;7&lt;/span&gt;   &lt;span class="mi"&gt;8&lt;/span&gt;
   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;2&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;4&lt;/span&gt;  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;8&lt;/span&gt;   &lt;span class="mi"&gt;6&lt;/span&gt;
&lt;span class="n"&gt;predecessor&lt;/span&gt; &lt;span class="n"&gt;after&lt;/span&gt; &lt;span class="nl"&gt;SetCollapsing&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;2&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;   &lt;span class="mi"&gt;4&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt;   &lt;span class="mi"&gt;6&lt;/span&gt;   &lt;span class="mi"&gt;7&lt;/span&gt;   &lt;span class="mi"&gt;8&lt;/span&gt;
   &lt;span class="mi"&gt;3&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;4&lt;/span&gt;  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;6&lt;/span&gt;   &lt;span class="mi"&gt;6&lt;/span&gt;
&lt;span class="n"&gt;SCC&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; 
&lt;span class="n"&gt;SCC&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; 
&lt;span class="n"&gt;SCC&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;結果如圖五(a)與圖五(b)：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="scc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/SCC_fig/f14.png?raw=true" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;img alt="scc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/SCC_fig/f15.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五(a)：第一次&lt;/strong&gt;&lt;code&gt;DFS()&lt;/code&gt;&lt;strong&gt;以vertex(0)作為起點。&lt;/strong&gt; 
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="scc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/SCC_fig/f16.png?raw=true" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;img alt="scc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/SCC_fig/f17.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五(b)：第一次&lt;/strong&gt;&lt;code&gt;DFS()&lt;/code&gt;&lt;strong&gt;以vertex(3)作為起點。&lt;/strong&gt; 
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;以上便是利用&lt;code&gt;DFS()&lt;/code&gt;來尋找directed graph中的strongly connected component之應用。&lt;br /&gt;
其中，&lt;code&gt;finish&lt;/code&gt;之順序在DAG(directed acyclic graph)中扮演了關鍵角色。&lt;/p&gt;
&lt;p&gt;下一篇將介紹如何利用&lt;code&gt;DFS()&lt;/code&gt;尋找DAG的Topological sort(拓撲排序)，敬請期待。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a name="ref"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;參考資料：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844"&gt;Introduction to Algorithms, Ch22&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376"&gt;Fundamentals of Data Structures in C++, Ch6&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.personal.kent.edu/~rmuhamma/Algorithms/MyAlgorithms/GraphAlgor/strongComponent.htm"&gt;Rashid Bin Muhammad：Strongly Connected Components&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.geeksforgeeks.org/strongly-connected-components/"&gt;GeeksforGeeks：Strongly Connected Components&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name="series"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h2&gt;Graph系列文章&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/graph-introjian-jie.html"&gt;Graph: Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/graph-breadth-first-searchbfsguang-du-you-xian-sou-xun.html"&gt;Graph: Breadth-First Search(BFS，廣度優先搜尋)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/graph-depth-first-searchdfsshen-du-you-xian-sou-xun.html"&gt;Graph: Depth-First Search(DFS，深度優先搜尋)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/graph-li-yong-dfshe-bfsxun-zhao-connected-component.html"&gt;Graph: 利用DFS和BFS尋找Connected Component&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/grpah-li-yong-dfsxun-zhao-strongly-connected-componentscc.html"&gt;Grpah: 利用DFS尋找Strongly Connected Component(SCC)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/grpah-li-yong-dfsxun-zhao-dagde-topological-sorttuo-pu-pai-xu.html"&gt;Grpah: 利用DFS尋找DAG的Topological Sort(拓撲排序)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="C++"></category><category term="Graph"></category><category term="DFS"></category><category term="DAG"></category></entry><entry><title>Graph: 利用DFS和BFS尋找Connected Component</title><link href="http://alrightchiu.github.io/SecondRound/graph-li-yong-dfshe-bfsxun-zhao-connected-component.html" rel="alternate"></link><updated>2016-02-12T22:55:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2016-02-12:SecondRound/graph-li-yong-dfshe-bfsxun-zhao-connected-component.html</id><summary type="html">&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;先備知識與注意事項&lt;/h3&gt;
&lt;p&gt;在一個undirected graph中，若存在任意兩個vertex之間不具有path連結，那麼此undirected graph就不是connected，裡面一定包含了兩個以上的connected component。  &lt;/p&gt;
&lt;p&gt;如圖一(a)，vertex(0)與vertex(1)不論經過Graph中其他任何vertex都沒有辦法產生一條path連結，則此Graph就不是connected。&lt;br /&gt;
並且觀察，vertex(0)、vertex(2)、vertex(4)彼此皆有path能夠互相連結，因此subgraph：&lt;span class="math"&gt;\(G(V_1,E_1)\)&lt;/span&gt;，其中&lt;span class="math"&gt;\(V_1=\)&lt;/span&gt;{&lt;span class="math"&gt;\(0,2,4\)&lt;/span&gt;}與&lt;span class="math"&gt;\(E_1=\)&lt;/span&gt;{&lt;span class="math"&gt;\((0,2),(0,4)\)&lt;/span&gt;}即為一個connected component；subgraph：&lt;span class="math"&gt;\(G(V_2,E_2)\)&lt;/span&gt;，其中&lt;span class="math"&gt;\(V_2=\)&lt;/span&gt;{&lt;span class="math"&gt;\(1,3\)&lt;/span&gt;}與&lt;span class="math"&gt;\(E_2=\)&lt;/span&gt;{&lt;span class="math"&gt;\((1,3)\)&lt;/span&gt;}是另一個connected component。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/CC_fig/f1.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(a)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;再看圖一(b)，Graph中的任何vertex皆能經由一條path通往其餘vertex，因此，整個Graph所形成的集合即為一個connected component。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/CC_fig/f2.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(b)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;本篇文章要示範強大的&lt;code&gt;DFS()&lt;/code&gt;與&lt;code&gt;BFS()&lt;/code&gt;的小小應用：尋找undirected graph中的&lt;strong&gt;connected component&lt;/strong&gt;。&lt;br /&gt;
若不太熟悉&lt;strong&gt;connected&lt;/strong&gt;的定義，可以先閱讀&lt;a href="http://alrightchiu.github.io/SecondRound/graph-introjian-jie.html"&gt;Graph: Intro(簡介)&lt;/a&gt;稍稍複習。&lt;br /&gt;
此外，為了集中火力，&lt;code&gt;DFS()&lt;/code&gt;與&lt;code&gt;BFS()&lt;/code&gt;的程式碼就留在&lt;a href="http://alrightchiu.github.io/SecondRound/graph-depth-first-searchdfsshen-du-you-xian-sou-xun.html"&gt;Graph: Depth-First Search(DFS，深度優先搜尋)&lt;/a&gt;與&lt;a href="http://alrightchiu.github.io/SecondRound/graph-breadth-first-searchbfsguang-du-you-xian-sou-xun.html"&gt;Graph: Breadth-First Search(BFS，廣度優先搜尋)&lt;/a&gt;裡面，如果還沒有對兩個演算法送出交友邀請，千萬不要客氣。&lt;/p&gt;
&lt;p&gt;最後一點溫馨小提醒：Graph與connected component的本質上是Set(集合)，因此，以下將會用到Set的觀點做說明。如果不熟悉Set也沒關係，只要知道Set是「一團不在意次序(order)的資料」就可以了。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#how"&gt;DFS與BFS何德何能？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#algorithm"&gt;演算法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#code"&gt;程式碼&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#scc"&gt;如果是Strongly Connected Component呢？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#ref"&gt;參考資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#series"&gt;Graph系列文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="how"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;DFS與BFS何德何能？&lt;/h2&gt;
&lt;p&gt;關鍵就是，兩個演算法都能產生&lt;code&gt;predecessor&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;若vertex(Y)的&lt;code&gt;predecessor[Y]&lt;/code&gt;是vertex(X)，表示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;vertex(Y)是被vertex(X)給找到。&lt;/li&gt;
&lt;li&gt;也就表示，在undirected graph中，存在edge(X,Y)。&lt;/li&gt;
&lt;li&gt;又因為是undirected graph，若存在edge(X,Y)，就能從vertex(X)走到vertex(Y)，也能從vertex(Y)走到vertex(X)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，若vertex(Y)的&lt;code&gt;predecessor[Y]&lt;/code&gt;是vertex(X)，就表示vertex(X)與vertex(Y)一定在同一個connected component裡面。&lt;/p&gt;
&lt;p&gt;這也就是為什麼&lt;code&gt;DFS()&lt;/code&gt;與&lt;code&gt;BFS()&lt;/code&gt;都能夠用來尋找undirected graph中的connected component的原因。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="algorithm"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;演算法&lt;/h2&gt;
&lt;p&gt;尋找connected component的演算法很直觀，只要三步驟：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在Graph上執行&lt;code&gt;DFS()&lt;/code&gt;或&lt;code&gt;BFS()&lt;/code&gt;得到&lt;code&gt;predecessor&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;進行&lt;code&gt;SetCollapsing()&lt;/code&gt;。（蛤？）&lt;/li&gt;
&lt;li&gt;印出共有幾個connected component，以及各個connected component中的vertex。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以上步驟，顯然有個傢伙很突兀。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="sc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/CC_fig/f3.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SetCollapsing()&lt;/code&gt;是稍後會用到的函式，其功能可以拆成兩個部分理解：一個是「Set」，一個是「Collapsing」：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Set(集合)：&lt;code&gt;SetCollapsing()&lt;/code&gt;處理的對象是Set，也就是不具「次序(order)」的資料，如圖二左，共有三個Set，分別是&lt;span class="math"&gt;\(S_1=\)&lt;/span&gt;{&lt;span class="math"&gt;\(0,1,4,5,7\)&lt;/span&gt;}、&lt;span class="math"&gt;\(S_2=\)&lt;/span&gt;{&lt;span class="math"&gt;\(3,6,8\)&lt;/span&gt;}、&lt;span class="math"&gt;\(S_3=\)&lt;/span&gt;{&lt;span class="math"&gt;\(2\)&lt;/span&gt;}。&lt;ul&gt;
&lt;li&gt;在Set上，時常要做的操作便是「查看某個元素(element)在哪一個Set裡面」，而Set通常是用&lt;code&gt;root&lt;/code&gt;代表，因此，若如圖二左的方式，以element(0)作為「存取(access)點」(也就是這個Set的&lt;code&gt;root&lt;/code&gt;)，那麼要判斷element(7)是在element(0)所代表的Set內(而不是element(3)所代表的Set)，就需要&lt;span class="math"&gt;\(O(N)\)&lt;/span&gt;的搜尋時間(&lt;span class="math"&gt;\(N\)&lt;/span&gt;為Set內的元素數量)，從element(7)一路找到element(0)，才能判斷。&lt;/li&gt;
&lt;li&gt;如果能夠以圖二右的資料結構表示Set，那麼以element(0)、element(2)、element(3)代表Set，要判斷任何一個元素(element)是屬於哪一個Set，便只要&lt;span class="math"&gt;\(O(1)\)&lt;/span&gt;的時間。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Collapsing(塌陷)：讓Set「塌陷」，使得所有element皆能直接指向其所在的Set之&lt;code&gt;root&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(以下先以&lt;code&gt;DFS()&lt;/code&gt;為例，稍後在程式碼的部分將會同步展示以&lt;code&gt;BFS()&lt;/code&gt;進行之結果)&lt;/p&gt;
&lt;p&gt;考慮圖三(a)的undirected graph：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/CC_fig/f4.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(a)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;首先，對Graph進行&lt;code&gt;DFS()&lt;/code&gt;，取得&lt;code&gt;predecessor&lt;/code&gt;，以及圖三(b)的Depth-First Forest：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由於是undirected graph，由任意vertex作為&lt;code&gt;DFS()&lt;/code&gt;起點，結果都會相同。此處以vertex(0)作為起點。&lt;/li&gt;
&lt;li&gt;圖三(b)中，vertex(0)、vertex(2)、vertex(3)的&lt;code&gt;predecessor&lt;/code&gt;皆為&lt;span class="math"&gt;\(-1\)&lt;/span&gt;，表示這三者皆為Depth-First Tree的&lt;code&gt;root&lt;/code&gt;，也就是Set的&lt;code&gt;root&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;而其餘的vertex，皆能透過&lt;code&gt;predecessor&lt;/code&gt;回溯到&lt;code&gt;root&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="sc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/CC_fig/f5.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(b)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;接下來要進行&lt;code&gt;SetCollapsing()&lt;/code&gt;。&lt;br /&gt;
在此先以&lt;span class="math"&gt;\(Set\)&lt;/span&gt;:{&lt;span class="math"&gt;\(0,1,4,5,7\)&lt;/span&gt;}為例作說明，目標是從圖三(c)左轉換成圖三(c)右。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="sc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/CC_fig/f6.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(c)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;先觀察：&lt;code&gt;SetCollapsing()&lt;/code&gt;什麼時候完成？&lt;br /&gt;
就是當Set中，除了&lt;code&gt;root&lt;/code&gt;之外的所有vertex(等義於element)的&lt;code&gt;predecessor&lt;/code&gt;都指向&lt;code&gt;root&lt;/code&gt;時，也就是當要被「塌陷」的vertex剩下&lt;code&gt;root&lt;/code&gt;的時候，&lt;code&gt;SetCollapsing()&lt;/code&gt;便完成。&lt;/p&gt;
&lt;p&gt;若現在要對vertex(7)進行&lt;code&gt;SetCollapsing()&lt;/code&gt;，見圖三(d)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;把vertex(7)標記上&lt;code&gt;current&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;找到vertex(7)所在的Set的&lt;code&gt;root&lt;/code&gt;，也就是vertex(0)，標記上&lt;code&gt;root&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;找到vertex(7)的&lt;code&gt;predecessor&lt;/code&gt;，也就是vertex(5)，標記上&lt;code&gt;parent&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接著判斷，若&lt;code&gt;current&lt;/code&gt;不等於&lt;code&gt;root&lt;/code&gt;(表示除了&lt;code&gt;root&lt;/code&gt;之外，還有vertex還沒有「塌陷」，因此&lt;code&gt;SetCollapsing()&lt;/code&gt;還沒有完成)，那麼就把：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;current&lt;/code&gt;的&lt;code&gt;predecessor&lt;/code&gt;更新成&lt;code&gt;root&lt;/code&gt;：&lt;code&gt;predecessor[7]&lt;/code&gt;更新成vertex(0)。&lt;/li&gt;
&lt;li&gt;並且把原先的&lt;code&gt;parent&lt;/code&gt;當成新的&lt;code&gt;current&lt;/code&gt;：&lt;code&gt;current&lt;/code&gt;移動到vertex(5)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="sc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/CC_fig/f7.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(d)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;現在&lt;code&gt;current&lt;/code&gt;變成了vertex(5)，不等於&lt;code&gt;root&lt;/code&gt;vertex(0)，因此繼續：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;把&lt;code&gt;parent&lt;/code&gt;標記成vertex(4)。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;current&lt;/code&gt;的&lt;code&gt;predecessor&lt;/code&gt;更新成&lt;code&gt;root&lt;/code&gt;：&lt;code&gt;predecessor[5]&lt;/code&gt;更新成vertex(0)。&lt;/li&gt;
&lt;li&gt;並且把原先的&lt;code&gt;parent&lt;/code&gt;當成新的&lt;code&gt;current&lt;/code&gt;：&lt;code&gt;current&lt;/code&gt;移動到vertex(4)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="sc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/CC_fig/f8.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(e)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;接下來的&lt;code&gt;current&lt;/code&gt;依序會是vertex(4)、vertex(1)，因為&lt;code&gt;current&lt;/code&gt;還不是vertex(0)，便按照上述步驟「塌陷」。直到&lt;code&gt;current&lt;/code&gt;移到vertex(0)後，&lt;code&gt;SetCollapsing()&lt;/code&gt;便完成，見圖三(f)。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="sc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/CC_fig/f9.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(f9)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;比較一下經過&lt;code&gt;SetCollapsing()&lt;/code&gt;處立前後的&lt;code&gt;predecessor&lt;/code&gt;，如圖四。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="sc" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/CC_fig/f10.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;只要先找到&lt;code&gt;predecessor&lt;/code&gt;為「負值」的vertex，就找到了代表某一connected component的Set之&lt;code&gt;root&lt;/code&gt;，再尋找哪些vertex的&lt;code&gt;predecessor&lt;/code&gt;指向該&lt;code&gt;root&lt;/code&gt;，便能找出該connected component所包含的所有vertex。&lt;/p&gt;
&lt;p&gt;大功告成。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="code"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;程式碼&lt;/h2&gt;
&lt;p&gt;範例程式碼除了已經介紹過的&lt;code&gt;class Graph&lt;/code&gt;、&lt;code&gt;DFS()&lt;/code&gt;以及&lt;code&gt;BFS()&lt;/code&gt;之外，還多了四個函式。&lt;br /&gt;
其中，在undirected graph中尋找connected component的主要函式：&lt;code&gt;CCDFS(int vertex)&lt;/code&gt;與&lt;code&gt;CCBFS(int vertex)&lt;/code&gt;共包含三個部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;DFS()&lt;/code&gt;或者&lt;code&gt;BFS()&lt;/code&gt;，取得&lt;code&gt;predecessor&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SetCollapsing&lt;/code&gt;是為了讓尋找connected component變得更簡單。&lt;/li&gt;
&lt;li&gt;最後，是利用「塌陷」過後的&lt;code&gt;predecessor&lt;/code&gt;找到connected component。&lt;br /&gt;
(&lt;code&gt;PrintPredecessor()&lt;/code&gt;是為了印出&lt;code&gt;predecessor&lt;/code&gt;以驗證&lt;code&gt;SetCollapsing&lt;/code&gt;的正確性，非必要。)&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;vector&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;list&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;queue&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;iomanip&amp;gt;      &lt;/span&gt;&lt;span class="c1"&gt;// for std::setw()&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Graph&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;AdjList&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;             &lt;span class="c1"&gt;// 0:white, 1:gray, 2:black&lt;/span&gt;
        &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;distance&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;          &lt;span class="c1"&gt;// for BFS()&lt;/span&gt;
        &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;discover&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;          &lt;span class="c1"&gt;// for DFS()&lt;/span&gt;
        &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;finish&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;Graph&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;){};&lt;/span&gt;
    &lt;span class="n"&gt;Graph&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="c1"&gt;// initialize Adj List&lt;/span&gt;
        &lt;span class="n"&gt;AdjList&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;resize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;};&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;BFS&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Start&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;    
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;DFS&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Start&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;DFSVisit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;vertex&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;CCDFS&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;vertex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;                &lt;span class="c1"&gt;// 利用DFS &lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;CCBFS&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;vertex&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;            &lt;span class="c1"&gt;// 利用BFS, 兩者邏輯完全相同&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;SetCollapsing&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;vertex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;PrintPredecessor&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;               &lt;span class="c1"&gt;// 印出predecessor, 供驗証用, 非必要&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Graph&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;SetCollapsing&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;// root&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;

    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
        &lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Graph&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;CCDFS&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;vertex&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;

    &lt;span class="n"&gt;DFS&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vertex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;      &lt;span class="c1"&gt;// &lt;/span&gt;
    &lt;span class="n"&gt;PrintPredecessor&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;SetCollapsing&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;PrintPredecessor&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;num_cc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Component#&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;num_cc&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot; &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot; &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="p"&gt;}&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
            &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Graph&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;CCBFS&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;vertex&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;

    &lt;span class="n"&gt;BFS&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vertex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;PrintPredecessor&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;SetCollapsing&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;PrintPredecessor&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;num_cc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Component#&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;num_cc&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot; &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot; &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="p"&gt;}&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
            &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Graph&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;PrintPredecessor&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;predecessor:&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;setw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;setw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
    &lt;span class="n"&gt;Graph&lt;/span&gt; &lt;span class="n"&gt;g3&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g3&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g3&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g3&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g3&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="c1"&gt;// AdjList[2] empty&lt;/span&gt;
    &lt;span class="n"&gt;g3&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g3&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g3&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g3&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g3&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g3&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g3&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g3&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g3&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g3&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;g3&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CCDFS&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;g3&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CCBFS&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;output:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nl"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;2&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;   &lt;span class="mi"&gt;4&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt;   &lt;span class="mi"&gt;6&lt;/span&gt;   &lt;span class="mi"&gt;7&lt;/span&gt;   &lt;span class="mi"&gt;8&lt;/span&gt;
  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;0&lt;/span&gt;  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;4&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt;   &lt;span class="mi"&gt;6&lt;/span&gt;
&lt;span class="nl"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;2&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;   &lt;span class="mi"&gt;4&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt;   &lt;span class="mi"&gt;6&lt;/span&gt;   &lt;span class="mi"&gt;7&lt;/span&gt;   &lt;span class="mi"&gt;8&lt;/span&gt;
  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;0&lt;/span&gt;  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;
&lt;span class="n"&gt;Component&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt; 
&lt;span class="n"&gt;Component&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; 
&lt;span class="n"&gt;Component&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt; 

&lt;span class="nl"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;2&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;   &lt;span class="mi"&gt;4&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt;   &lt;span class="mi"&gt;6&lt;/span&gt;   &lt;span class="mi"&gt;7&lt;/span&gt;   &lt;span class="mi"&gt;8&lt;/span&gt;
  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;0&lt;/span&gt;  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt;   &lt;span class="mi"&gt;6&lt;/span&gt;
&lt;span class="nl"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;2&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;   &lt;span class="mi"&gt;4&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt;   &lt;span class="mi"&gt;6&lt;/span&gt;   &lt;span class="mi"&gt;7&lt;/span&gt;   &lt;span class="mi"&gt;8&lt;/span&gt;
  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;0&lt;/span&gt;  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;
&lt;span class="n"&gt;Component&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt; 
&lt;span class="n"&gt;Component&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; 
&lt;span class="n"&gt;Component&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;聰明的讀者們一定已經發現了，不進行&lt;code&gt;SetCollapsing()&lt;/code&gt;，單單只靠&lt;code&gt;predecessor&lt;/code&gt;一樣可以找出connected component。  &lt;/p&gt;
&lt;p&gt;不過筆者認為使用&lt;code&gt;SetCollapsing()&lt;/code&gt;處理&lt;code&gt;predecessor&lt;/code&gt;，雖然不見得是最有效率的方法，但是概念上比較直觀，因為connected component就是Set。&lt;/p&gt;
&lt;p&gt;事實上，這兩種Set表示法(「塌陷」前後的&lt;code&gt;predecessor&lt;/code&gt;)，正好是在Set問題中永恆的兩難(trade-off)：「要&lt;strong&gt;Union&lt;/strong&gt;方便」還是「&lt;strong&gt;Find&lt;/strong&gt;方便」，有興趣的讀者可以看看這篇：&lt;a href="https://www.hackerearth.com/notes/disjoint-set-union-union-find/"&gt;Disjoint Set Union (Union Find)&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="scc"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;如果是Strongly Connected Component呢？&lt;/h2&gt;
&lt;p&gt;以上處理的是「在undirected graph中尋找connected component」，那如果要在「directed graph中尋找strongly connected component」呢？&lt;/p&gt;
&lt;p&gt;顯然，光是只有&lt;code&gt;predecessor&lt;/code&gt;是不夠的，因為在directed graph中，&lt;code&gt;predecessor&lt;/code&gt;能夠保證的是一個「有方向性」的edge，例如edge(X,Y)表示，從vertex(X)能夠走到vertex(Y)，卻不能打包票從vertex(Y)也能走回vertex(X)。因此，要找到strongly connected component需要更高級的方法才行。&lt;/p&gt;
&lt;p&gt;不過到這裡，是時候&lt;a href="https://www.youtube.com/watch?v=NrGxru6nqeQ"&gt;該說再見了朋友們&lt;/a&gt;。&lt;br /&gt;
更高級的方法，請待下回分曉。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a name="ref"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;參考資料：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844"&gt;Introduction to Algorithms, Ch22&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376"&gt;Fundamentals of Data Structures in C++, Ch6&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.hackerearth.com/notes/disjoint-set-union-union-find/"&gt;Hackerearth：Disjoint Set Union(Union Find)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Set_%28abstract_data_type%29"&gt;Wikipedia：Set (abstract data type)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name="series"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h2&gt;Graph系列文章&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/graph-introjian-jie.html"&gt;Graph: Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/graph-breadth-first-searchbfsguang-du-you-xian-sou-xun.html"&gt;Graph: Breadth-First Search(BFS，廣度優先搜尋)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/graph-depth-first-searchdfsshen-du-you-xian-sou-xun.html"&gt;Graph: Depth-First Search(DFS，深度優先搜尋)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/graph-li-yong-dfshe-bfsxun-zhao-connected-component.html"&gt;Graph: 利用DFS和BFS尋找Connected Component&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/grpah-li-yong-dfsxun-zhao-strongly-connected-componentscc.html"&gt;Grpah: 利用DFS尋找Strongly Connected Component(SCC)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/grpah-li-yong-dfsxun-zhao-dagde-topological-sorttuo-pu-pai-xu.html"&gt;Grpah: 利用DFS尋找DAG的Topological Sort(拓撲排序)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="C++"></category><category term="Graph"></category><category term="BFS"></category><category term="DFS"></category></entry><entry><title>Graph: Depth-First Search(DFS，深度優先搜尋)</title><link href="http://alrightchiu.github.io/SecondRound/graph-depth-first-searchdfsshen-du-you-xian-sou-xun.html" rel="alternate"></link><updated>2016-02-11T22:36:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2016-02-11:SecondRound/graph-depth-first-searchdfsshen-du-you-xian-sou-xun.html</id><summary type="html">&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;先備知識與注意事項&lt;/h3&gt;
&lt;p&gt;在&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-traversalxun-fang.html#pre"&gt;Binary Tree: Traversal(尋訪)&lt;/a&gt;中介紹過Pre-Order Traversal，其Visiting順序：「Current(V)-left(L)-right(R)」可以解讀成「先遇到的node就先Visiting」，因此，每一組「Current-left-right」必定是&lt;code&gt;CurrentNode&lt;/code&gt;先Visiting，接著是&lt;code&gt;leftchild&lt;/code&gt;，最後才是&lt;code&gt;rightchild&lt;/code&gt;。&lt;br /&gt;
若對圖一中的Binary Tree進行Pre-Order Traversal，定義Visiting為印出(print)資料，將得到：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt; &lt;span class="n"&gt;D&lt;/span&gt; &lt;span class="n"&gt;E&lt;/span&gt; &lt;span class="n"&gt;G&lt;/span&gt; &lt;span class="n"&gt;H&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt; &lt;span class="n"&gt;F&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;center&gt;
&lt;img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/DFS_fig/f_1.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;Depth-First Search(DFS，深度優先搜尋)的核心精神便如同Pre-Order Traversal：「先遇到的vertex就先Visiting」，並且以先遇到的vertex作為新的搜尋起點，直到所有「有edge相連的vertex」都被探索過。&lt;/p&gt;
&lt;p&gt;以圖二的迷宮為例，把迷宮矩陣中的每一格定義成一個vertex，若兩個vertex之間有路，則建立edge相連。若要在迷宮中尋找抵達終點的路線，通常會先選擇其中一條路線，&lt;strong&gt;只要有路就繼續往前走&lt;/strong&gt;。有可能一路走到終點，也有可能遇到死路。若遇到死路則回到上一個岔路，往另一條路探索路線。依此類推，直到走出迷宮。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/DFS_fig/maze.gif?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二：迷宮問題(maze problem)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#dfs"&gt;Depth-First Search(DFS，深度優先搜尋)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#algorithm"&gt;演算法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#code"&gt;程式碼&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#discuss"&gt;討論&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#dff_dft"&gt;Depth-First Tree&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#4edge"&gt;4種edge&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#ref"&gt;參考資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#series"&gt;Graph系列文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="dfs"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Depth-First Search(DFS，深度優先搜尋)&lt;/h2&gt;
&lt;p&gt;考慮圖三(a)的Graph(沒有weight的directed graph)：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/DFS_fig/f_2.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(a)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;若以vertex(A)為起點進行&lt;code&gt;DFS()&lt;/code&gt;，可以得到：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若Graph中的vertex與vertex(A)之間存在至少一條path，則&lt;code&gt;DFS()&lt;/code&gt;必定能找到其中一條path從vertex(A)抵達該vertex。但是這條path未必保證是最短路徑(shortest path)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;看起來好像沒有&lt;code&gt;BFS()&lt;/code&gt;這麼殺手級，雖然找到一條路卻不保證是最短路徑。&lt;br /&gt;
但其實&lt;code&gt;DFS()&lt;/code&gt;還是很有用的，因為經過一次&lt;code&gt;DFS()&lt;/code&gt;後，將得到一項資料稱作&lt;code&gt;finish&lt;/code&gt;，而&lt;code&gt;finish&lt;/code&gt;竟然可以用來...！？&lt;/p&gt;
&lt;p&gt;別轉台，看下去。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="algorithm"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;演算法&lt;/h2&gt;
&lt;p&gt;以下介紹的&lt;code&gt;DFS()&lt;/code&gt;需要資料項目共有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;time&lt;/code&gt;：在整個&lt;code&gt;DFS()&lt;/code&gt;的過程會有一條「時間軸」，若Graph中有&lt;span class="math"&gt;\(N\)&lt;/span&gt;個vertex，「時間軸」上一共會有&lt;span class="math"&gt;\(2N\)&lt;/span&gt;個「時間點」。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;discover&lt;/code&gt;與&lt;code&gt;finish&lt;/code&gt; array：每個vertex會被標記上兩個「時間點」，分別是「被發現(&lt;code&gt;discover&lt;/code&gt;)」的時間與「結束(&lt;code&gt;finish&lt;/code&gt;)」的時間：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;discover&lt;/code&gt;：例如，vertex(B)被vertex(A)找到，則&lt;code&gt;discover[B]&lt;/code&gt;會是&lt;code&gt;discover[A]&lt;/code&gt;加一，表示vertex(B)在整個時間軸上是在vertex(A)之後被找到(這其中便存在「ancestor-descendant」的關係)。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;finish&lt;/code&gt;：若vertex(B)已經經由有效edge探索過所有與之相連的vertex，表示以vertex(B)為起點的探索已經結束，便標上&lt;code&gt;finish[B]&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;color&lt;/code&gt; array：利用color標記哪些vertex已經「被發現」與「結束」。&lt;ul&gt;
&lt;li&gt;白色表示該vertex還沒有「被發現」；&lt;/li&gt;
&lt;li&gt;灰色表示該vertex已經「被發現」，但是還沒有「結束」。&lt;/li&gt;
&lt;li&gt;黑色表示該vertex已經「結束」。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;predecessor&lt;/code&gt; array：記錄某個vertex是被哪一個vertex找到的，如此便能回溯路徑(如同&lt;code&gt;BFS()&lt;/code&gt;，&lt;code&gt;DFS()&lt;/code&gt;亦能生成一個&lt;strong&gt;Predecessor Subgraph&lt;/strong&gt;)。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;DFS()&lt;/code&gt;的方法如下：&lt;/p&gt;
&lt;p&gt;初始化(initialization)，見圖三(b)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先把&lt;code&gt;time&lt;/code&gt;設為&lt;code&gt;0&lt;/code&gt;，表示還沒有任何vertex「被發現」。&lt;/li&gt;
&lt;li&gt;把所有vertex塗成白色。&lt;/li&gt;
&lt;li&gt;把所有vertex的&lt;code&gt;predecessor&lt;/code&gt;清除(或者設成&lt;code&gt;NULL&lt;/code&gt;、&lt;code&gt;-1&lt;/code&gt;，視資料形態(data type)而定)。&lt;/li&gt;
&lt;li&gt;把所有vertex的&lt;code&gt;discover&lt;/code&gt;與&lt;code&gt;finish&lt;/code&gt;設成&lt;code&gt;0&lt;/code&gt;，表示還沒有開始進行&lt;code&gt;DFS()&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/DFS_fig/f_19.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(b)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;以vertex(A)作為起點，見圖三(c)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;將vertex(A)塗成灰色，表示已經「被發現」。&lt;/li&gt;
&lt;li&gt;由於vertex(A)已經「被發現」，便把&lt;code&gt;discover[A]&lt;/code&gt;設為&lt;code&gt;++time&lt;/code&gt;。原本&lt;code&gt;time=0&lt;/code&gt;，而vertex(A)是&lt;code&gt;DFS()&lt;/code&gt;的起點，所以&lt;code&gt;++time&lt;/code&gt;之後&lt;code&gt;distance[A]=1&lt;/code&gt;便表示vertex(A)是第一個被發現。&lt;/li&gt;
&lt;li&gt;接著尋找所有與vertex(A)相連之vertex，只要遇到第一個&lt;strong&gt;仍為白色&lt;/strong&gt;的vertex，便把該vertex設為新的搜尋起點，並將該vertex之&lt;code&gt;predecessor&lt;/code&gt;設為vertex(A)。  &lt;ul&gt;
&lt;li&gt;圖三(a)之&lt;code&gt;Adjacency List&lt;/code&gt;中，第一個與vertex(A)相連的vertex為vertex(B)，接著便&lt;strong&gt;以vertex(B)為起點&lt;/strong&gt;，繼續尋找與vertex(B)相連之「最近的」vertex。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;由於從vertex(A)找到了vertex(B)，便表示「從vertex(A)出發的path」還在更新，於是vertex(A)便還沒有「結束」，所以&lt;code&gt;finish[A]&lt;/code&gt;不需要更新。  &lt;ul&gt;
&lt;li&gt;那麼，什麼時候會更新&lt;code&gt;finish[A]&lt;/code&gt;呢？&lt;br /&gt;
在&lt;code&gt;Adjacency List&lt;/code&gt;中，與vertex(A)相連之vertex有vertex(B)與vertex(C)，要在這兩個vertex都「作為搜尋起點」，並且「探索完所有相連的vertex」後(也就是更新完&lt;code&gt;finish[B]&lt;/code&gt;與&lt;code&gt;finish[C]&lt;/code&gt;後)，才會更新到&lt;code&gt;finish[A]&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;圖三(c)中的「Time Stamp(時間戳記)」即為「時間軸」。&lt;br /&gt;
此時進入「剛發現vertex(A)」，並且尚未結束「以vertex(A)作為搜尋起點」的階段。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/DFS_fig/f_3.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(c)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;從vertex(A)作為探索起點，「最先發現」的是vertex(B)，便以其作為新的起點：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;把vertex(B)塗成灰色，表示已經「被發現」。&lt;/li&gt;
&lt;li&gt;由於vertex(B)已經「被發現」，便把&lt;code&gt;discover[B]&lt;/code&gt;設為&lt;code&gt;++time&lt;/code&gt;，也就是&lt;code&gt;distance[B]=2&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;接著，找到&lt;code&gt;Adjacency List&lt;/code&gt;中第一個與vertex(B)相連，且為&lt;strong&gt;白色&lt;/strong&gt;的vertex(D)，將vertex(D)視為新的搜尋起點。&lt;/li&gt;
&lt;li&gt;此時圖三(d)的「時間軸」表示，「以vertex(A)作為起點」之搜尋尚未結束(vertex(A)還沒有被塗黑)，而且「以vertex(B)作為起點」之搜尋剛剛開始。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/DFS_fig/f_4.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(d)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;來到「以vertex(D)作為起點」之搜尋，大致上與「以vertex(B)作為起點」之搜尋相同：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;把vertex(D)塗成灰色，表示已經「被發現」。&lt;/li&gt;
&lt;li&gt;由於vertex(D)已經「被發現」，便把&lt;code&gt;discover[D]&lt;/code&gt;設為&lt;code&gt;++time&lt;/code&gt;，也就是&lt;code&gt;distance[D]=3&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;接著，找到&lt;code&gt;Adjacency List&lt;/code&gt;中第一個與vertex(D)相連，且為&lt;strong&gt;白色&lt;/strong&gt;的vertex(E)，將vertex(E)視為新的搜尋起點。&lt;/li&gt;
&lt;li&gt;此時圖三(e)的「時間軸」表示，「以vertex(A)與vertex(B)作為起點」之搜尋都還沒結束(vertex(A)、vertex(B)還沒有被塗黑)，而且「以vertex(D)作為起點」之搜尋剛剛開始。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/DFS_fig/f_5.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(e)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;來到「以vertex(E)作為起點」之搜尋，與前兩個步驟相同，不再贅述，見圖三(f)。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/DFS_fig/f_6.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(f)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;關鍵是圖三(g)。&lt;br /&gt;
當vertex(E)再也找不到任何「能夠抵達、且為白色」的vertex時(見圖三(g)中Graph的箭頭方向，並對照圖三(a)之&lt;code&gt;Adjacency List&lt;/code&gt;)，就表示「以vertex(E)作為起點」之搜尋已經「結束」，此時：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;把vertex(E)塗成黑色，表示「以vertex(E)作為起點」之搜尋已經「結束」。&lt;/li&gt;
&lt;li&gt;把&lt;code&gt;finish[E]&lt;/code&gt;設成&lt;code&gt;++time&lt;/code&gt;。  &lt;ul&gt;
&lt;li&gt;原先在vertex(E)「被發現」時&lt;code&gt;time=4&lt;/code&gt;，更新後，表示vertex(E)之搜尋在&lt;code&gt;time=5&lt;/code&gt;時「結束」。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;當vertex(E)「結束」後，便回到vertex(E)的&lt;code&gt;predecessor&lt;/code&gt;，也就是「發現vertex(E)」的vertex(D)，繼續探索其他vertex(D)能夠走到的vertex。&lt;/li&gt;
&lt;li&gt;此時，圖三(g)的「時間軸」表示，&lt;code&gt;discover[E]=4&lt;/code&gt;，&lt;code&gt;finish[E]=5&lt;/code&gt;，往後搜尋過程就不會再有vertex(E)出現。而以vertex(A)、vertex(B)、vertex(D)作為起點的搜尋則持續進行。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/DFS_fig/f_7.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(g)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;接著，從vertex(E)退回到vertex(D)，並從vertex(D)繼續發現vertex(F)還是白色，於是便以「vertex(F)作為起點」進行搜尋：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;把vertex(F)塗成灰色。&lt;/li&gt;
&lt;li&gt;把&lt;code&gt;discover[F]&lt;/code&gt;設為&lt;code&gt;++time&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;繼續尋找所有從vertex(F)能夠走到，且為白色的vertex。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/DFS_fig/f_8.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(h)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;觀察圖三(i)的Graph與圖三(a)的&lt;code&gt;Adjacency List&lt;/code&gt;，發現從vertex(F)能夠走到vertex(B)，但是由於vertex(B)已經是「灰色」，表示「以vertex(B)為起點」之搜尋已經開始且尚未結束，於是vertex(F)無法「發現」vertex(B)，也無法走到其餘vertex，所以，vertex(F)便宣告「結束」：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;把vertex(F)塗成黑色，表示「以vertex(F)作為起點」之搜尋已經「結束」。&lt;/li&gt;
&lt;li&gt;把&lt;code&gt;finish[F]&lt;/code&gt;設成&lt;code&gt;++time&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;當vertex(F)「結束」後，便回到vertex(F)的&lt;code&gt;predecessor&lt;/code&gt;，也就是「發現vertex(F)」的vertex(D)，繼續探索其他vertex(D)能夠走到的vertex。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/DFS_fig/f_9.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(i)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;如圖三(j)，所有vertex(D)能夠抵達的vertex都已經變成黑色，於是「以vertex(D)作為起點」之搜尋便結束：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;把vertex(D)塗成黑色，表示「以vertex(D)作為起點」之搜尋已經「結束」。&lt;/li&gt;
&lt;li&gt;把&lt;code&gt;finish[D]&lt;/code&gt;設成&lt;code&gt;++time&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;當vertex(D)「結束」後，便回到vertex(D)的&lt;code&gt;predecessor&lt;/code&gt;，也就是「發現vertex(D)」的vertex(B)，繼續探索其他vertex(B)能夠走到的vertex。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/DFS_fig/f_10.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(j)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;接著便以上述邏輯重複步驟，直到vertex(A)被塗成黑色，見圖三(k)-(n)。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/DFS_fig/f_11.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(k)：。&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt;&lt;img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/DFS_fig/f_12.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(l)：。&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt;&lt;img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/DFS_fig/f_13.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(m)：。&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt;&lt;img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/DFS_fig/f_14.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(n)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;在「以vertex(A)為起點」之搜尋結束後，必須確認Graph中還有沒有白色的vertex，如圖三(n)，Graph裡還有vertex(G)與vertex(H)仍然是白色，因此挑選其中一個vertex作為新的起點。這裡是按照&lt;code&gt;Adjacency List&lt;/code&gt;的順序，由於vertex(G)在vertex(H)之前，便先挑選vertex(G)，接著重複上述步驟，見圖三(o)-(r)。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/DFS_fig/f_15.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(o)：。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/DFS_fig/f_16.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(p)：。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/DFS_fig/f_17.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(q)：。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/DFS_fig/f_18.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(r)：。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;當Graph中所有vertex都被塗成黑色，便完成&lt;code&gt;DFS()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="code"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;程式碼&lt;/h2&gt;
&lt;p&gt;由以上說明可以觀察出，&lt;code&gt;DFS()&lt;/code&gt;本質上是一種「&lt;strong&gt;遞迴(recursion)結構&lt;/strong&gt;」，而遞迴結構其實是利用了系統的「&lt;strong&gt;堆疊(stack)&lt;/strong&gt;」，因此，這兩種方式皆能實現&lt;code&gt;DFS()&lt;/code&gt;，以下提供的範例程式碼將以遞迴形式完成。&lt;/p&gt;
&lt;p&gt;如同上一篇&lt;a href="http://alrightchiu.github.io/SecondRound/graph-breadth-first-searchbfsguang-du-you-xian-sou-xun.html#code"&gt;Graph: Breadth-First Search(BFS，廣度優先搜尋)&lt;/a&gt;，以下將使用&lt;code&gt;int&lt;/code&gt;處理資料，把&lt;span class="math"&gt;\(9\)&lt;/span&gt;個vertex&lt;code&gt;char A~I&lt;/code&gt;依序對應到&lt;code&gt;int 0~8&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;範例程式碼包含兩個部分&lt;code&gt;main()&lt;/code&gt;與&lt;code&gt;class Graph&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;main()&lt;/code&gt;中，主要兩件事情：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;建立如圖三(a)的&lt;code&gt;Adjacency List&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;進行&lt;code&gt;DFS()&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在&lt;code&gt;class Graph&lt;/code&gt;中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;private member：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;num_vertex&lt;/code&gt;：需要在定義&lt;code&gt;Graph&lt;/code&gt;的object(物件)時，給定vertex的數目，以便建立&lt;code&gt;Adjacency List&lt;/code&gt;(或者&lt;code&gt;Adjacency Matrix&lt;/code&gt;)。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::vector&amp;lt; std::list&amp;lt;int&amp;gt; &amp;gt; AdjList&lt;/code&gt;：利用C++標準函式庫(STL)提供的container(容器):&lt;code&gt;std::vector&lt;/code&gt;與&lt;code&gt;std::list&lt;/code&gt;來實現。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;color&lt;/code&gt;、&lt;code&gt;discover&lt;/code&gt;、&lt;code&gt;finish&lt;/code&gt;、&lt;code&gt;predecessor&lt;/code&gt;：將在&lt;code&gt;DFS()&lt;/code&gt;中使用，功能如上述。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;public member：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Constructor:Graph(int num_vertex)&lt;/code&gt;：在定義Graph的object(物件)時，需要知道vertex的數目，並在&lt;code&gt;constructor&lt;/code&gt;中定義好&lt;code&gt;AdjList&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AddEdgeList(int from, in to)&lt;/code&gt;：功能便是在&lt;code&gt;AdjList&lt;/code&gt;新增從&lt;code&gt;from&lt;/code&gt;到&lt;code&gt;to&lt;/code&gt;的edge。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DFS(int Start)&lt;/code&gt;：需要知道起點vertex。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DFSVisit(int vertex, int &amp;amp;time)&lt;/code&gt;：利用遞迴函式呼叫，進行&lt;code&gt;color&lt;/code&gt;、&lt;code&gt;discover&lt;/code&gt;、&lt;code&gt;finish&lt;/code&gt;與&lt;code&gt;predecessor&lt;/code&gt;等資料更新的主要函式。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;vector&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;list&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;queue&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;iomanip&amp;gt;      &lt;/span&gt;&lt;span class="c1"&gt;// for std::setw()&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Graph&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;AdjList&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;             &lt;span class="c1"&gt;// 0:white, 1:gray, 2:black&lt;/span&gt;
        &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;discover&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;finish&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;Graph&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;){};&lt;/span&gt;
    &lt;span class="n"&gt;Graph&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="c1"&gt;// initialize Adj List&lt;/span&gt;
        &lt;span class="n"&gt;AdjList&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;resize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;};&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;BFS&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Start&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;    &lt;span class="c1"&gt;// 定義見上一篇文章&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;DFS&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Start&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;DFSVisit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;vertex&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Graph&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;DFS&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Start&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;           &lt;span class="c1"&gt;// 配置記憶體位置&lt;/span&gt;
    &lt;span class="n"&gt;discover&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="n"&gt;finish&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="n"&gt;predecessor&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;time&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                          &lt;span class="c1"&gt;// 初始化, 如圖三(b)&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; 
        &lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;discover&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;finish&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Start&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;// 檢查所有Graph中的vertex都要被搜尋到&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;               &lt;span class="c1"&gt;// 若vertex不是白色, 則進行以該vertex作為起點之搜尋&lt;/span&gt;
            &lt;span class="n"&gt;DFSVisit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                             &lt;span class="c1"&gt;// j會把AdjList完整走過一遍, 確保所有vertex都被搜尋過&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Graph&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;DFSVisit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;vertex&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;   &lt;span class="c1"&gt;// 一旦有vertex被發現而且是白色, 便進入DFSVisit()&lt;/span&gt;
    &lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;vertex&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                         &lt;span class="c1"&gt;// 把vertex塗成灰色&lt;/span&gt;
    &lt;span class="n"&gt;discover&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;vertex&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                 &lt;span class="c1"&gt;// 更新vertex的discover時間&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;iterator&lt;/span&gt; &lt;span class="n"&gt;itr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;AdjList&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;vertex&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;   &lt;span class="c1"&gt;// for loop參數太長&lt;/span&gt;
         &lt;span class="n"&gt;itr&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;AdjList&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;vertex&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="n"&gt;itr&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;                    &lt;span class="c1"&gt;// 分成兩段&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;itr&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;                &lt;span class="c1"&gt;// 若搜尋到白色的vertex&lt;/span&gt;
            &lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;itr&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;        &lt;span class="c1"&gt;// 更新其predecessor&lt;/span&gt;
            &lt;span class="n"&gt;DFSVisit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;itr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;              &lt;span class="c1"&gt;// 立刻以其作為新的搜尋起點, 進入新的DFSVisit()&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;vertex&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                         &lt;span class="c1"&gt;// 當vertex已經搜尋過所有與之相連的vertex後, 將其塗黑&lt;/span&gt;
    &lt;span class="n"&gt;finish&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;vertex&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                   &lt;span class="c1"&gt;// 並更新finish時間&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
    &lt;span class="c1"&gt;// 定義一個具有八個vertex的Graph&lt;/span&gt;
    &lt;span class="n"&gt;Graph&lt;/span&gt; &lt;span class="n"&gt;g2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="c1"&gt;// 建立如圖三之Graph&lt;/span&gt;
    &lt;span class="n"&gt;g2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; 
    &lt;span class="n"&gt;g2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="c1"&gt;// AdjList[4] is empty&lt;/span&gt;
    &lt;span class="n"&gt;g2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;g2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DFS&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;    &lt;span class="c1"&gt;// 以vertex(0), 也就是vertex(A作為DFS()的起點&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="discuss"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;討論&lt;/h2&gt;
&lt;p&gt;若在&lt;code&gt;DFS()&lt;/code&gt;函式主體的最後多加入幾行程式來檢查&lt;code&gt;predecessor&lt;/code&gt;、&lt;code&gt;discover&lt;/code&gt;與&lt;code&gt;finish&lt;/code&gt;三項資料是否符合預期：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Graph&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;DFS&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Start&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
 &lt;span class="c1"&gt;// after for loop&lt;/span&gt;
 &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;predecessor:&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;         &lt;span class="c1"&gt;// 印出 A(0) ~ H(7)的predecessor&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;setw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;setw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;discover time:&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;// 印出 A(0) ~ H(7)的discover time&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;setw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;setw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;discover&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;finish time:&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="c1"&gt;// 印出 A(0) ~ H(7)的finish time&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;setw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;setw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;finish&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;便能得到：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nl"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;2&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;   &lt;span class="mi"&gt;4&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt;   &lt;span class="mi"&gt;6&lt;/span&gt;   &lt;span class="mi"&gt;7&lt;/span&gt;
  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;6&lt;/span&gt;
&lt;span class="n"&gt;discover&lt;/span&gt; &lt;span class="nl"&gt;time&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;2&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;   &lt;span class="mi"&gt;4&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt;   &lt;span class="mi"&gt;6&lt;/span&gt;   &lt;span class="mi"&gt;7&lt;/span&gt;
   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;2&lt;/span&gt;  &lt;span class="mi"&gt;10&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;   &lt;span class="mi"&gt;4&lt;/span&gt;   &lt;span class="mi"&gt;6&lt;/span&gt;  &lt;span class="mi"&gt;13&lt;/span&gt;  &lt;span class="mi"&gt;14&lt;/span&gt;
&lt;span class="n"&gt;finish&lt;/span&gt; &lt;span class="nl"&gt;time&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
   &lt;span class="mi"&gt;0&lt;/span&gt;   &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="mi"&gt;2&lt;/span&gt;   &lt;span class="mi"&gt;3&lt;/span&gt;   &lt;span class="mi"&gt;4&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt;   &lt;span class="mi"&gt;6&lt;/span&gt;   &lt;span class="mi"&gt;7&lt;/span&gt;
  &lt;span class="mi"&gt;12&lt;/span&gt;   &lt;span class="mi"&gt;9&lt;/span&gt;  &lt;span class="mi"&gt;11&lt;/span&gt;   &lt;span class="mi"&gt;8&lt;/span&gt;   &lt;span class="mi"&gt;5&lt;/span&gt;   &lt;span class="mi"&gt;7&lt;/span&gt;  &lt;span class="mi"&gt;16&lt;/span&gt;  &lt;span class="mi"&gt;15&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;與預期的結果相同，如圖四。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/DFS_fig/f_20.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="dff_dft"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Depth-First Tree&lt;/h3&gt;
&lt;p&gt;如同&lt;code&gt;BFS()&lt;/code&gt;，在Graph上進行&lt;code&gt;DFS()&lt;/code&gt;同樣可以得到&lt;strong&gt;Predecessor Subgraph&lt;/strong&gt;，又稱為&lt;strong&gt;Depth-First Tree&lt;/strong&gt;。若Graph本身不是&lt;strong&gt;(strongly) connected component&lt;/strong&gt;，則有可能得到&lt;strong&gt;Depth-First Forest&lt;/strong&gt;，如圖五：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/DFS_fig/f_21.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;根據圖五的「時間軸」，可以直接由&lt;code&gt;discover&lt;/code&gt;與&lt;code&gt;finish&lt;/code&gt;觀察出各個vertex之間的「ancestor-descendant」關係(也就包含了&lt;code&gt;predecessor&lt;/code&gt;關係)：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;若&lt;code&gt;discover[X]&lt;/code&gt;比&lt;code&gt;discover[Y]&lt;/code&gt;大，而且&lt;code&gt;finish[X]&lt;/code&gt;比&lt;code&gt;finish[Y]&lt;/code&gt;小，表示vertex(X)比vertex(Y)較晚「被發現」，而且較早「結束」，則vertex(X)必定是vertex(Y)的descendant。&lt;ul&gt;
&lt;li&gt;以vertex(E)與vertex(A)為例，vertex(E)的「搜尋生命週期」完全在vertex(A)的「搜尋生命週期」&lt;strong&gt;之內&lt;/strong&gt;，因此vertex(E)必定是vertex(A)的descendant。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;相反，若&lt;code&gt;discover[X]&lt;/code&gt;比&lt;code&gt;discover[Y]&lt;/code&gt;小，而且&lt;code&gt;finish[X]&lt;/code&gt;比&lt;code&gt;finish[Y]&lt;/code&gt;大，表示vertex(X)比vertex(Y)較早「被發現」，而且較晚「結束」，則vertex(X)必定是vertex(Y)的ancestor。&lt;ul&gt;
&lt;li&gt;以vertex(B)與vertex(F)為例，vertex(B)的「搜尋生命週期」&lt;strong&gt;完全包覆&lt;/strong&gt;住vertex(F)的「搜尋生命週期」，因此vertex(B)必定是vertex(F)的ancestor。 &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;第三種情形，若兩個vertex的「搜尋生命週期」完全沒有重疊，那麼這兩個vertex在Depth-First Forest中：&lt;ol&gt;
&lt;li&gt;有可能在同一棵Depth-First Tree，但是互相沒有「ancestor-descendant」的關係，例如vertex(D)與vertex(C)。此時，&lt;code&gt;discover[D]&lt;/code&gt;&lt;span class="math"&gt;\(&amp;lt;\)&lt;/span&gt;&lt;code&gt;discover[C]&lt;/code&gt;，而且&lt;code&gt;finish[D]&lt;/code&gt;&lt;span class="math"&gt;\(&amp;lt;\)&lt;/span&gt;&lt;code&gt;finish[C]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;也有可能在不同棵Depth-First Tree，例如vertex(C)與vertex(H)。此時，&lt;code&gt;discover[C]&lt;/code&gt;&lt;span class="math"&gt;\(&amp;lt;\)&lt;/span&gt;&lt;code&gt;discover[H]&lt;/code&gt;，而且&lt;code&gt;finish[C]&lt;/code&gt;&lt;span class="math"&gt;\(&amp;lt;\)&lt;/span&gt;&lt;code&gt;finish[H]&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a name="4edge"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;4種edge&lt;/h3&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/DFS_fig/f_22.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖六：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;經過&lt;code&gt;DFS()&lt;/code&gt;後，還可以分類出四種edge：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Tree edge&lt;/strong&gt;：若vertex(Y)是被vertex(X)「發現」，則edge(X,Y)即為Tree edge，也就是Depth-First Tree中的edge。&lt;ul&gt;
&lt;li&gt;透過顏色判斷edge：當vertex(X)搜尋到vertex(Y)，且vertex(Y)為「白色」時，就會建立出Tree edge。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Back edge&lt;/strong&gt;：所有指向ancestor的edge，稱為Back edge。如圖六中，edge(F,B)與edge(H,G)。&lt;ul&gt;
&lt;li&gt;透過顏色判斷edge：當vertex(X)搜尋到vertex(Y)，且vertex(Y)為「灰色」，就會建立起Back edge，見圖三(j)、圖三(q)與圖六。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Forward edge&lt;/strong&gt;：所有指向descendant但不是Tree edge的edge，稱為Forward edge。觀察「時間軸」，若Graph存在例如：edge(A,D)、edge(A,E)或者edge(B,E)，即可稱之為Forward edge。很遺憾的，圖六中，沒有Forward edge。&lt;ul&gt;
&lt;li&gt;透過顏色判斷edge：當vertex(X)搜尋到vertex(Y)時，vertex(Y)為「黑色」，並且&lt;code&gt;discover[X]&lt;/code&gt;&lt;span class="math"&gt;\(&amp;lt;\)&lt;/span&gt;&lt;code&gt;discover[Y]&lt;/code&gt;，edge(X,Y)即為Forward edge。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Cross edge&lt;/strong&gt;：若兩個vertex不在同一棵Depth-First Tree上，例如vertex(C)與vertex(H)，或者兩個vertex在同一棵Depth-First Tree上卻沒有「ancestor-descendant」的關係，例如vertex(C)與vertex(F)，則稱連結此兩個vertex的edge為Cross edge。&lt;ul&gt;
&lt;li&gt;透過顏色判斷edge：當vertex(X)搜尋到vertex(Y)時，vertex(Y)為「黑色」，並且&lt;code&gt;discover[X]&lt;/code&gt;&lt;span class="math"&gt;\(&amp;gt;\)&lt;/span&gt;&lt;code&gt;discover[Y]&lt;/code&gt;，edge(X,Y)即為Cross edge。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;分類出四種edge除了可以作為大腦體操，還可以根據Graph中是否具有/不具有某些edge來區分Graph的性質：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若在undirected graph上執行一次&lt;code&gt;DFS()&lt;/code&gt;，所有的edge不是Tree edge就是Back edge。&lt;/li&gt;
&lt;li&gt;若在directed graph上執行一次&lt;code&gt;DFS()&lt;/code&gt;，沒有產生Back edge，則此directed graph必定是&lt;strong&gt;acyclic&lt;/strong&gt;(沒有迴路)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;諸如此類的，是不是很有趣呢？&lt;br /&gt;
(好像也還好。)&lt;/p&gt;
&lt;p&gt;最後再看一次&lt;code&gt;DFS()&lt;/code&gt;的流程，見圖七：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="dfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/DFS_fig/DFS_Flow.gif?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖七：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;以上便是Depth-First Search(DFS，深度優先搜尋)的介紹。&lt;br /&gt;
在接下來的文章中，將利用&lt;code&gt;DFS()&lt;/code&gt;與神奇的&lt;code&gt;finish&lt;/code&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;進行&lt;strong&gt;Topological Sort(拓撲排序)&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;找到directed graph中的&lt;strong&gt;Strongly Connected Component(SCC)&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;不過在這之前，會先介紹利用&lt;code&gt;BFS()&lt;/code&gt;與&lt;code&gt;DFS()&lt;/code&gt;找到undirected graph中的&lt;strong&gt;connected component&lt;/strong&gt;作為暖身。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a name="ref"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;參考資料：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844"&gt;Introduction to Algorithms, Ch22&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376"&gt;Fundamentals of Data Structures in C++, Ch6&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://codereview.stackexchange.com/questions/82476/depth-first-search-and-breadth-first-search-in-c"&gt;Code Review：Depth First Search and Breadth First Search in C++&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name="series"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h2&gt;Graph系列文章&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/graph-introjian-jie.html"&gt;Graph: Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/graph-breadth-first-searchbfsguang-du-you-xian-sou-xun.html"&gt;Graph: Breadth-First Search(BFS，廣度優先搜尋)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/graph-depth-first-searchdfsshen-du-you-xian-sou-xun.html"&gt;Graph: Depth-First Search(DFS，深度優先搜尋)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/graph-li-yong-dfshe-bfsxun-zhao-connected-component.html"&gt;Graph: 利用DFS和BFS尋找Connected Component&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/grpah-li-yong-dfsxun-zhao-strongly-connected-componentscc.html"&gt;Grpah: 利用DFS尋找Strongly Connected Component(SCC)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/grpah-li-yong-dfsxun-zhao-dagde-topological-sorttuo-pu-pai-xu.html"&gt;Grpah: 利用DFS尋找DAG的Topological Sort(拓撲排序)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="C++"></category><category term="Graph"></category><category term="DFS"></category></entry><entry><title>Graph: Breadth-First Search(BFS，廣度優先搜尋)</title><link href="http://alrightchiu.github.io/SecondRound/graph-breadth-first-searchbfsguang-du-you-xian-sou-xun.html" rel="alternate"></link><updated>2016-02-06T14:15:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2016-02-06:SecondRound/graph-breadth-first-searchbfsguang-du-you-xian-sou-xun.html</id><summary type="html">&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;先備知識與注意事項&lt;/h3&gt;
&lt;p&gt;在&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-traversalxun-fang.html#level"&gt;Binary Tree: Traversal(尋訪)&lt;/a&gt;與&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-jian-li-yi-ke-binary-tree.html"&gt;Binary Tree: 建立一棵Binary Tree&lt;/a&gt;兩篇文章裡，介紹了如何利用&lt;code&gt;queue&lt;/code&gt;在Binary Tree中進行&lt;strong&gt;Level-Order Traversal&lt;/strong&gt;，其概念便是：各個node相對於&lt;code&gt;root&lt;/code&gt;有其對應的level，按照level由小到大依序對node進行Visiting。&lt;br /&gt;
而level便代表了node與&lt;code&gt;root&lt;/code&gt;之「距離」，以Graph的語言來說，「距離」便是path的&lt;strong&gt;length(長度)/distance(距離)&lt;/strong&gt;。如圖一：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Level=2：path(A-B)、path(A-C)之length為&lt;span class="math"&gt;\(1\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;Level=3：path(A-B-D)、path(A-B-E)、path(A-C-F)之length為&lt;span class="math"&gt;\(2\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;Level=4：path(A-B-E-G)、path(A-B-E-H)之length為&lt;span class="math"&gt;\(3\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而Breadth-First Search(BFS，廣度優先搜尋)便是廣義的Level-Order Traversal，將使用情境從Tree推廣至Graph。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="level-order" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/BFS_fig/f1.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;溫馨小提醒：在解釋演算法時，可能會用到Graph中的專有名詞，如&lt;strong&gt;undirected&lt;/strong&gt;、&lt;strong&gt;connected component&lt;/strong&gt;、&lt;strong&gt;weight&lt;/strong&gt;等等，若覺得這些名詞像被打了馬賽克糊糊的，可以先回到&lt;a href="http://alrightchiu.github.io/SecondRound/graph-introjian-jie.html"&gt;Graph: Intro(簡介)&lt;/a&gt;狠狠回憶一番。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#bfs"&gt;Breadth-First Search(BFS，廣度優先搜尋)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#algorithm"&gt;演算法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#code"&gt;程式碼&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#discuss"&gt;討論&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#ref"&gt;參考資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#series"&gt;Graph系列文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="bfs"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Breadth-First Search(BFS，廣度優先搜尋)&lt;/h2&gt;
&lt;p&gt;所以&lt;code&gt;BFS()&lt;/code&gt;的功能有哪些呢？&lt;/p&gt;
&lt;p&gt;考慮圖二(a)的Graph(沒有weight、是connected的undirected graph)：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/BFS_fig/f2.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(a)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;若選定以vertex(A)作為起點，對圖二(a)的G進行&lt;code&gt;BFS()&lt;/code&gt;，可以得到：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;從vertex(A)抵達在Graph裡所有「與vertex(A)在同一個connected component裡」的vertex的最短距離(shortest path)。&lt;br /&gt;
(由於圖二(a)的Graph是connected undirected graph，所以從G中任何一點出發進行&lt;code&gt;BFS()&lt;/code&gt;皆能抵達其餘所有vertex。)&lt;/li&gt;
&lt;li&gt;不僅僅能夠得到vertex(I)與vertex(A)的最短距離為&lt;span class="math"&gt;\(3\)&lt;/span&gt;，還能夠指出一條可能的path，說明要如何從vertex(A)走到vertex(I)，例如path:A-C-F-I，或者path:A-C-G-I。  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="algorithm"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;演算法&lt;/h2&gt;
&lt;p&gt;在正式開始之前，需要先準備四項武器：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;queue&lt;/code&gt;：如同Level-Order Traversal，&lt;code&gt;BFS()&lt;/code&gt;將使用&lt;code&gt;queue&lt;/code&gt;來確保「先被搜尋到的vertex，就先成為新的搜尋起點」。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;color&lt;/code&gt; array：利用color標記哪些vertex已經被「找到」，哪些還沒有。&lt;ul&gt;
&lt;li&gt;白色表示該vertex還沒有被找過；&lt;/li&gt;
&lt;li&gt;灰色表示該vertex已經被某個vertex找過；&lt;/li&gt;
&lt;li&gt;黑色表示該vertex已經從&lt;code&gt;queue&lt;/code&gt;的隊伍中移除。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;distance&lt;/code&gt; array：記錄每一個vertex與起點vertex之距離。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;predecessor&lt;/code&gt; array：記錄某個vertex是被哪一個vertex找到的，如此便能回溯路徑。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;BFS()&lt;/code&gt;的方法如下：&lt;/p&gt;
&lt;p&gt;初始化(initialization)，如圖二(b)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;把所有vertex塗成白色，表示還沒有任何vertex被「找到」。&lt;/li&gt;
&lt;li&gt;把所有vertex的&lt;code&gt;distance&lt;/code&gt;設為無限大，表示從起點vertex走不到，或者還沒有走到。&lt;/li&gt;
&lt;li&gt;把所有vertex的&lt;code&gt;predecessor&lt;/code&gt;清除(或者設成&lt;code&gt;NULL&lt;/code&gt;、&lt;code&gt;-1&lt;/code&gt;，可以辨識出何者為「起點」即可)。&lt;/li&gt;
&lt;li&gt;建立空的&lt;code&gt;queue&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/BFS_fig/f3.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(b)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;把起點vertex(A)推進&lt;code&gt;queue&lt;/code&gt;，如圖二(c)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;將vertex(A)塗成灰色，表示vertex(A)在之後的&lt;code&gt;BFS()&lt;/code&gt;過程中，將不可能再被其他vertex「找到」。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;distance[A]&lt;/code&gt;設為&lt;span class="math"&gt;\(0\)&lt;/span&gt;。換句話說，&lt;code&gt;distance&lt;/code&gt;為&lt;span class="math"&gt;\(0\)&lt;/span&gt;的vertex就是在「一個connected component」上進行&lt;code&gt;BFS()&lt;/code&gt;的起點。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;predecessor[A]&lt;/code&gt;不更動。若將&lt;code&gt;predecessor&lt;/code&gt;初始化成&lt;span class="math"&gt;\(-1\)&lt;/span&gt;，即表示，在&lt;code&gt;BFS()&lt;/code&gt;結束後，&lt;code&gt;predecessor&lt;/code&gt;仍為&lt;span class="math"&gt;\(-1\)&lt;/span&gt;的vertex即為起點。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/BFS_fig/f4.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(c)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;接著，以&lt;code&gt;queue&lt;/code&gt;的&lt;code&gt;front&lt;/code&gt;當作新的起點搜尋。&lt;br /&gt;
新的起點是vertex(A)，便檢查所有與vertex(A)相鄰的vertex(見圖二(a)的&lt;code&gt;Adjacency List&lt;/code&gt;)，修改其&lt;code&gt;color&lt;/code&gt;、&lt;code&gt;distance&lt;/code&gt;、&lt;code&gt;predecessor&lt;/code&gt;。&lt;br /&gt;
如圖二(d)，vertex(B)、vertex(C)、vertex(D)與vertex(A)相鄰，如果vertex的顏色是白色，表示還沒有被其他vertex「找到」，便執行以下步驟：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;將三個vertex的&lt;code&gt;color&lt;/code&gt;塗成灰色。&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;distance[B]、distance[C]、distance[D]&lt;/code&gt;設成&lt;code&gt;distance[A]&lt;/code&gt;&lt;span class="math"&gt;\(+1=1\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;predecessor[B]、predecessor[C]、predecessor[D]&lt;/code&gt;設成vertex(A)。&lt;/li&gt;
&lt;li&gt;把三個vertex按照「找到」的順序，依序推進&lt;code&gt;queue&lt;/code&gt;裡。&lt;/li&gt;
&lt;li&gt;最後，把vertex(A)塗黑，移出&lt;code&gt;queue&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;經過以上步驟，vertex(B)、vertex(C)、vertex(D)便被vertex(A)「找到」，並把&lt;code&gt;predecessor&lt;/code&gt;設成vertex(A)，所以回溯路徑時，任何經過vertex(B)的path，必定是由vertex(A)來。同理，vertex(C)與vertex(D)也是。&lt;/p&gt;
&lt;p&gt;而&lt;code&gt;distance[B]&lt;/code&gt;是vertex(A)的&lt;code&gt;distance[A]&lt;/code&gt;加一，如此一來，只要到達vertex(A)是經由最短路徑，那麼從vertex(A)走到vertex(B)的路徑，也會是最短路徑。&lt;br /&gt;
由於vertex(A)是起點，&lt;code&gt;distance[A]&lt;/code&gt;&lt;span class="math"&gt;\(=0\)&lt;/span&gt;，因此，&lt;code&gt;distance[B]&lt;/code&gt;&lt;span class="math"&gt;\(=1\)&lt;/span&gt;一定是從vertex(A)走到vertex(B)的最短距離。&lt;/p&gt;
&lt;p&gt;由於推進&lt;code&gt;queue&lt;/code&gt;的順序正好是vertex被「找到」的順序，因此，之後要取得&lt;code&gt;queue&lt;/code&gt;的&lt;code&gt;front&lt;/code&gt;作為新的起點做搜尋時，便能確保按照先前被「找到」的順序(如同Tree的Level-Order Traversal)。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/BFS_fig/f5.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(d)：以vertex(A)作為搜尋起點。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;接著，繼續以&lt;code&gt;queue&lt;/code&gt;的&lt;code&gt;front&lt;/code&gt;當作新的起點搜尋。&lt;br /&gt;
新的起點是vertex(B)，檢查所有與其相鄰的vertex，共有vertex(A)與vertex(E)。由於vertex(A)已經被「找到」過(顏色為灰色或黑色)，因此，vertex(B)只能找到vertex(E)，便進行以下步驟：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;將vertex(E)的&lt;code&gt;color&lt;/code&gt;塗成灰色。&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;distance[E]&lt;/code&gt;設成&lt;code&gt;distance[B]&lt;/code&gt;&lt;span class="math"&gt;\(+1=2\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;predecessor[E]&lt;/code&gt;設成vertex(B)。&lt;/li&gt;
&lt;li&gt;將vertex(E)推進&lt;code&gt;queue&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;最後，把vertex(B)塗黑，移出&lt;code&gt;queue&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/BFS_fig/f6.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(e)：以vertex(B)作為搜尋起點。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;由於vertex(B)是第一個&lt;code&gt;distance&lt;/code&gt;為&lt;span class="math"&gt;\(1\)&lt;/span&gt;且被視為搜尋起點的vertex，這就表示，所有&lt;code&gt;distance&lt;/code&gt;為&lt;span class="math"&gt;\(0\)&lt;/span&gt;的vertex都已經&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;被當作搜尋起點。&lt;/li&gt;
&lt;li&gt;搜尋過其相鄰之vertex。&lt;/li&gt;
&lt;li&gt;被塗成黑色。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;往後&lt;code&gt;queue&lt;/code&gt;裡面只會出現&lt;code&gt;distance&lt;/code&gt;&lt;span class="math"&gt;\(\geq 1\)&lt;/span&gt;的vertex。
&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;接下來，繼續以&lt;code&gt;queue&lt;/code&gt;的&lt;code&gt;front&lt;/code&gt;，得到vertex(C)作為新的起點，檢查其相鄰的vertex的顏色，如果是灰色或黑色(vertex(A)與vertex(E)已經被「找到」)則忽略，若是白色(vertex(F)、vertex(G)、vertex(H))，見圖二(f)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;將&lt;code&gt;color&lt;/code&gt;修改成灰色。&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;distance&lt;/code&gt;修改成&lt;code&gt;distance[C]&lt;/code&gt;&lt;span class="math"&gt;\(+1\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;predecessor&lt;/code&gt;修改成vertex(C)。&lt;/li&gt;
&lt;li&gt;將vertex按照被「找到」的順序，推進&lt;code&gt;queue&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;將vertex(C)塗黑，移出&lt;code&gt;queue&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/BFS_fig/f7.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(f)：以vertex(C)作為搜尋起點。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;接著，從&lt;code&gt;queue&lt;/code&gt;的&lt;code&gt;front&lt;/code&gt;找到vertex(D)，可惜所有與vertex(D)相鄰的vertex(A)與vertex(H)不是灰色就是黑色，都已經被「找到」，見圖二(g)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;將vertex(D)塗黑，移出&lt;code&gt;queue&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/BFS_fig/f8.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(g)：以vertex(D)作為搜尋起點。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;接著，重複上述之步驟，直到&lt;code&gt;queue&lt;/code&gt;被清空，即結束&lt;code&gt;BFS()&lt;/code&gt;搜尋，見圖二(h)-(l)。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/BFS_fig/f9.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(h)：以vertex(E)作為搜尋起點。&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt;&lt;img alt="bfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/BFS_fig/f10.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(i)：以vertex(F)作為搜尋起點，將vertex(I)推進&lt;code&gt;queue&lt;/code&gt;。&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;&lt;img alt="bfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/BFS_fig/f11.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(j)：以vertex(G)作為搜尋起點。&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;&lt;img alt="bfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/BFS_fig/f12.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(k)：以vertex(H)作為搜尋起點。&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;&lt;img alt="bfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/BFS_fig/f13.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(l)：以vertex(I)作為搜尋起點。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;當&lt;code&gt;queue&lt;/code&gt;中的vertex都被移除(&lt;code&gt;pop()&lt;/code&gt;)，表示&lt;code&gt;Adjacency List&lt;/code&gt;中的所有vertex都被當作起點搜尋過其相鄰的vertex，此時&lt;code&gt;BFS()&lt;/code&gt;便完成，得到以vertex(A)為起點，所有其餘vertex之相對應&lt;code&gt;distance&lt;/code&gt;與&lt;code&gt;predecessor&lt;/code&gt;，如圖二(m)。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/BFS_fig/f14.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(m)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="code"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;程式碼&lt;/h2&gt;
&lt;p&gt;(為了簡化程式，以下程式將使用&lt;code&gt;int&lt;/code&gt;處理資料，把&lt;span class="math"&gt;\(9\)&lt;/span&gt;個vertex&lt;code&gt;char A~I&lt;/code&gt;依序對應到&lt;code&gt;int 0~8&lt;/code&gt;)&lt;/p&gt;
&lt;p&gt;範例程式碼包含兩個部分&lt;code&gt;main()&lt;/code&gt;與&lt;code&gt;class Graph&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;main()&lt;/code&gt;中，主要有兩件事：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;建立如圖二(a)的&lt;code&gt;Adjacency List&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;進行&lt;code&gt;BFS()&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在&lt;code&gt;class Graph&lt;/code&gt;中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;private member：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;num_vertex&lt;/code&gt;：需要在定義&lt;code&gt;Graph&lt;/code&gt;的object(物件)時，給定vertex的數目，以便建立&lt;code&gt;Adjacency List&lt;/code&gt;(或者&lt;code&gt;Adjacency Matrix&lt;/code&gt;)。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::vector&amp;lt; std::list&amp;lt;int&amp;gt; &amp;gt; AdjList&lt;/code&gt;：利用C++標準函式庫(STL)提供的container(容器):&lt;code&gt;std::vector&lt;/code&gt;與&lt;code&gt;std::list&lt;/code&gt;來實現。這樣的寫法的優點是：不需要使用到&lt;code&gt;new operator&lt;/code&gt;，便能夠將記憶體控管交給STL，不需要自行處理&lt;code&gt;delete operator&lt;/code&gt;，以避免記憶體遺漏(memory leak)，詳細討論請參考&lt;a href="http://codereview.stackexchange.com/questions/82476/depth-first-search-and-breadth-first-search-in-c"&gt;Code Review：Depth First Search and Breadth First Search in C++&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;color&lt;/code&gt;、&lt;code&gt;distance&lt;/code&gt;、&lt;code&gt;predecessor&lt;/code&gt;：將在&lt;code&gt;BFS()&lt;/code&gt;中使用，功能如上述。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;public member：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Constructor:Graph(int num_vertex)&lt;/code&gt;：在定義Graph的object(物件)時，需要知道vertex的數目，並在&lt;code&gt;constructor&lt;/code&gt;中定義好&lt;code&gt;AdjList&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AddEdgeList(int from, in to)&lt;/code&gt;：功能便是在&lt;code&gt;AdjList&lt;/code&gt;新增從&lt;code&gt;from&lt;/code&gt;到&lt;code&gt;to&lt;/code&gt;的edge。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BFS(int Start)&lt;/code&gt;：前面提到的Graph恰好是connected undirected graph，因此只要一次&lt;code&gt;BFS()&lt;/code&gt;就能走到Graph中的所有vertex。然而，有些Graph並不是connected graph，無法以任意vertex作為起點走到其餘所有vertex(Graph中具有多個connected component)，因此，需要再多一個迴圈(以下是用&lt;code&gt;for loop&lt;/code&gt;)確保Graph中的全部vertex都被「找到」。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;vector&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;list&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;queue&amp;gt;&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Graph&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;AdjList&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;             &lt;span class="c1"&gt;// 0:白色, 1:灰色, 2:黑色&lt;/span&gt;
        &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;distance&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;          &lt;span class="c1"&gt;// 0:起點, 無限大:從起點走不到的vertex&lt;/span&gt;
        &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;       &lt;span class="c1"&gt;// -1:沒有predecessor, 表示為起點vertex&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;Graph&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;){};&lt;/span&gt;           &lt;span class="c1"&gt;// default constructor&lt;/span&gt;
    &lt;span class="n"&gt;Graph&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;        &lt;span class="c1"&gt;// constructor with input: number of vertex&lt;/span&gt;
        &lt;span class="c1"&gt;// initialize Adjacency List&lt;/span&gt;
        &lt;span class="n"&gt;AdjList&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;resize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;};&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;BFS&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Start&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Graph&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="n"&gt;AdjList&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;from&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;push_back&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Graph&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;BFS&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Start&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;

    &lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="n"&gt;predecessor&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="n"&gt;distance&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;  &lt;span class="c1"&gt;// 初始化，如圖二(b)&lt;/span&gt;
        &lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                       &lt;span class="c1"&gt;// 0:白色;&lt;/span&gt;
        &lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                &lt;span class="c1"&gt;// -1表示沒有predecessor&lt;/span&gt;
        &lt;span class="n"&gt;distance&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;         &lt;span class="c1"&gt;// num_vertex個vertex, &lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;                                       &lt;span class="c1"&gt;// 最長距離 distance = num_vertex -1條edge&lt;/span&gt;

    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;queue&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Start&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_vertex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;  &lt;span class="c1"&gt;// j從0數到num_vertex-1, 因此j會走過graph中所有vertex&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;                &lt;span class="c1"&gt;// 第一次i會是起點vertex, 如圖二(c)&lt;/span&gt;
            &lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                   &lt;span class="c1"&gt;// 1:灰色&lt;/span&gt;
            &lt;span class="n"&gt;distance&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                &lt;span class="c1"&gt;// 每一個connected component的起點之距離設成0&lt;/span&gt;
            &lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;            &lt;span class="c1"&gt;// 每一個connected component的起點沒有predecessor&lt;/span&gt;
            &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;empty&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;u&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;front&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;                  &lt;span class="c1"&gt;// u 為新的搜尋起點&lt;/span&gt;
                &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;iterator&lt;/span&gt; &lt;span class="n"&gt;itr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;AdjList&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;        &lt;span class="c1"&gt;// for loop 太長&lt;/span&gt;
                     &lt;span class="n"&gt;itr&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;AdjList&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="n"&gt;itr&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;                         &lt;span class="c1"&gt;// 分成兩段&lt;/span&gt;
                    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;itr&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;                &lt;span class="c1"&gt;// 若被「找到」的vertex是白色&lt;/span&gt;
                        &lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;itr&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                   &lt;span class="c1"&gt;// 塗成灰色, 表示已經被「找到」&lt;/span&gt;
                        &lt;span class="n"&gt;distance&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;itr&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;distance&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;// 距離是predecessor之距離加一&lt;/span&gt;
                        &lt;span class="n"&gt;predecessor&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;itr&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;             &lt;span class="c1"&gt;// 更新被「找到」的vertex的predecessor&lt;/span&gt;
                        &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;itr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;                      &lt;span class="c1"&gt;// 把vertex推進queue&lt;/span&gt;
                    &lt;span class="p"&gt;}&lt;/span&gt;
                &lt;span class="p"&gt;}&lt;/span&gt;
                &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pop&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;        &lt;span class="c1"&gt;// 把u移出queue&lt;/span&gt;
                &lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="c1"&gt;// 並且把u塗成黑色&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="c1"&gt;// 若一次回圈沒有把所有vertex走過, 表示graph有多個connected component&lt;/span&gt;
        &lt;span class="c1"&gt;// 就把i另成j, 繼續檢查graph中的其他vertex是否仍是白色, 若是, 重複while loop&lt;/span&gt;
        &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
    &lt;span class="n"&gt;Graph&lt;/span&gt; &lt;span class="n"&gt;g1&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;    
    &lt;span class="c1"&gt;// 建立出圖二(a)的Adjacency List&lt;/span&gt;
    &lt;span class="n"&gt;g1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;g1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;g1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddEdgeList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;g1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;BFS&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;    

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在&lt;code&gt;g1.BFS(0)&lt;/code&gt;後，若觀察&lt;code&gt;distance&lt;/code&gt;與&lt;code&gt;predecessor&lt;/code&gt;，應該能看到如圖二(n)的結果：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/BFS_fig/f15.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(n)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="discuss"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;討論&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;由於&lt;code&gt;BFS()&lt;/code&gt;是用&lt;code&gt;AdjList&lt;/code&gt;來判斷edge的連結狀況，因此，&lt;code&gt;BFS()&lt;/code&gt;對undirected graph或directed graph皆適用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;若將&lt;code&gt;predecessor array&lt;/code&gt;中，所有vertex的「前後關係」以edge連結，可以得到&lt;strong&gt;Predecessor Subgraph&lt;/strong&gt;。以圖三(a)的subgraph為例，因為其connected與acyclic的性質，使得Predecessor Subgraph會是一棵以起點vertex為&lt;code&gt;root&lt;/code&gt;的Tree，又稱為&lt;strong&gt;Breadth-First Tree&lt;/strong&gt;，而所有Predecessor Subgraph出現的edge稱為&lt;strong&gt;tree edge&lt;/strong&gt;。&lt;br /&gt;
(若Graph本身是由多個(strongly) connected component，則有可能得到&lt;strong&gt;Breadth-First Forest&lt;/strong&gt;，詳見&lt;a href="http://alrightchiu.github.io/SecondRound/graph-li-yong-dfshe-bfsxun-zhao-connected-component.html"&gt;Graph: 利用DFS和BFS尋找Connected Component&lt;/a&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/BFS_fig/f16.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(a)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如圖三(a)的&lt;strong&gt;Breadth-First Tree&lt;/strong&gt;可能不止有一種可能，原因在於「建立&lt;code&gt;Adjacency List&lt;/code&gt;時的順序」，將會影響到&lt;code&gt;BFS()&lt;/code&gt;中的&lt;code&gt;for loop&lt;/code&gt;在「找到」vertex時的順序。&lt;ul&gt;
&lt;li&gt;如圖三(b)，若更改圖二(a)之&lt;code&gt;AdjList&lt;/code&gt;，把vertex(A)之Linked list中，vertex(B)與vertex(C)之順序對調，使得&lt;code&gt;BFS()&lt;/code&gt;在搜尋vertex時，vertex(C)會比vertex(B)更早進入&lt;code&gt;queue&lt;/code&gt;，也就更早成為搜尋的新起點，那麼最後得到的Breadth-First Tree就會不同。&lt;/li&gt;
&lt;li&gt;不過，雖然Breadth-First Tree不一樣，但是每個vertex相對於起點vertex的&lt;code&gt;distance&lt;/code&gt;保證相同。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bfs" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/BFS_fig/f17.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(b)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;本篇文章所提供的&lt;code&gt;BFS()&lt;/code&gt;演算法，其&lt;code&gt;color&lt;/code&gt;之灰色與黑色可以合併，換句話說，若只使用白色與黑色，同樣能完成&lt;code&gt;BFS()&lt;/code&gt;。不過在下一篇文章將介紹的&lt;code&gt;DFS()&lt;/code&gt;演算法中，白色、灰色與黑色將分別具有不同功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;以上便是Breadth-First Search(BFS，廣度優先搜尋)之介紹。&lt;br /&gt;
下一篇將介紹另一種在Graph同樣常見的搜尋方法：Depth-First Search(DFS，深度優先搜尋)。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a name="ref"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;參考資料：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844"&gt;Introduction to Algorithms, Ch22&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376"&gt;Fundamentals of Data Structures in C++, Ch6&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://codereview.stackexchange.com/questions/82476/depth-first-search-and-breadth-first-search-in-c"&gt;Code Review：Depth First Search and Breadth First Search in C++&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://theoryofprogramming.com/adjacency-list-using-cpp-stl/"&gt;Theory of Programming：Adjacency List using C++ STL&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.geeksforgeeks.org/detect-cycle-undirected-graph/"&gt;GeeksforGeeks：Detect cycle in an undirected graph&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name="series"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h2&gt;Graph系列文章&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/graph-introjian-jie.html"&gt;Graph: Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/graph-breadth-first-searchbfsguang-du-you-xian-sou-xun.html"&gt;Graph: Breadth-First Search(BFS，廣度優先搜尋)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/graph-depth-first-searchdfsshen-du-you-xian-sou-xun.html"&gt;Graph: Depth-First Search(DFS，深度優先搜尋)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/graph-li-yong-dfshe-bfsxun-zhao-connected-component.html"&gt;Graph: 利用DFS和BFS尋找Connected Component&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/grpah-li-yong-dfsxun-zhao-strongly-connected-componentscc.html"&gt;Grpah: 利用DFS尋找Strongly Connected Component(SCC)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/grpah-li-yong-dfsxun-zhao-dagde-topological-sorttuo-pu-pai-xu.html"&gt;Grpah: 利用DFS尋找DAG的Topological Sort(拓撲排序)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="C++"></category><category term="Graph"></category><category term="BFS"></category></entry><entry><title>Graph: Intro(簡介)</title><link href="http://alrightchiu.github.io/SecondRound/graph-introjian-jie.html" rel="alternate"></link><updated>2016-02-03T23:49:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2016-02-03:SecondRound/graph-introjian-jie.html</id><summary type="html">&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;先備知識與注意事項&lt;/h3&gt;
&lt;p&gt;在經歷過&lt;a href="http://alrightchiu.github.io/SecondRound/treeshu-introjian-jie.html"&gt;Tree系列文章&lt;/a&gt;的洗禮後，接著要介紹的是Graph(圖)。&lt;/p&gt;
&lt;p&gt;Graph比Tree更加廣義，其定義僅僅使用了集合(Set)，並且不限制結構裡的node/vertex只能有唯一的&lt;code&gt;parent field&lt;/code&gt;，因此，更多的問題能夠以Graph建立模型。 &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#course"&gt;初探Graph的美妙：以課程與其先修科目為例&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#graph"&gt;Graph的定義&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#represent"&gt;表示法(representation)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#terminology"&gt;一些名詞解釋&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#app"&gt;預告：Graph的應用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#ref"&gt;參考資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#series"&gt;Graph系列文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="course"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;初探Graph的美妙：以課程與其先修科目為例&lt;/h2&gt;
&lt;p&gt;有一間大學的計算機科學學位之必修課程，以及與該課程相關的先修科目設計如表一：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Course name&lt;/th&gt;
&lt;th&gt;Prerequisites&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Programming I(程式設計 I)&lt;/td&gt;
&lt;td&gt;None&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Discrete Mathematics(離散數學)&lt;/td&gt;
&lt;td&gt;None&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Data Structures(資料結構)&lt;/td&gt;
&lt;td&gt;Programming I, Discrete Mathematics&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Calculus I(微積分 I)&lt;/td&gt;
&lt;td&gt;None&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Calculus II(微積分 II)&lt;/td&gt;
&lt;td&gt;Calculus I&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Linear Algebra(線性代數)&lt;/td&gt;
&lt;td&gt;Calculus II&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Analysis of Algorithm(演算法分析)&lt;/td&gt;
&lt;td&gt;Data Structures, Linear Algebra&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Assembly Language(組合語言)&lt;/td&gt;
&lt;td&gt;Data Structures&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Operating Systems(作業系統)&lt;/td&gt;
&lt;td&gt;Analysis of Algorithm, Assembly Language&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Programming Language(程式語言)&lt;/td&gt;
&lt;td&gt;Analysis of Algorithm&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Compiler Design(編譯器設計)&lt;/td&gt;
&lt;td&gt;Programming Language&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Artificial Intelligence(人工智慧)&lt;/td&gt;
&lt;td&gt;Analysis of Algorithm&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Computational Theory(計算機理論)  &amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;Analysis of Algorithm&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Parallel Algorithms(平行演算法)&lt;/td&gt;
&lt;td&gt;Computational Theory&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Numerical Analysis(數值方法)&lt;/td&gt;
&lt;td&gt;Calculus II&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;表一：某計算機科學學位之必修課程表&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;第一眼或許不太容易立即由表格獲得修課順序的資訊，因為表格受限於上至下、左至右的格式，只能逐項列出資訊，不容易表達資料與資料間的「先後關係」。&lt;/p&gt;
&lt;p&gt;現在換個方式，將具有先後修課順序的課程以線段與箭號連接，若A是B的先修課程，則箭號由A指向B，即可將表一轉換成圖一：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="prerequisites" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/Intro_fig/f_1.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;由圖一，將資料與資料的「先後關係」以「資料節點」與「線段(箭號)」表示，攻讀這門計算機科學學位的修課流程圖便一目了然。&lt;/p&gt;
&lt;p&gt;這樣的想法，不只是將表格轉換成對人類視覺上有意義的「圖」而已，對電腦來說，由於以Graph建立之模型能夠保持資料之間的「關係」，使得各種巧妙的演算法能夠在Graph中完成各種任務。&lt;br /&gt;
(反例：若要把在Graph上實現的各種演算法，如法炮製在以二維陣列表示的表一上，將會非常困難。)&lt;/p&gt;
&lt;p&gt;本篇文章的重點著重在介紹Graph(圖)的定義與實現方式，而接下來的文章將介紹一些基本的與Graph相關之演算法。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="graph"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Graph的定義&lt;/h2&gt;
&lt;p&gt;在圖一中，每一門課程被視為「資料節點」，且課程與課程之間有「線段(箭號)」連結：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;vertex&lt;/strong&gt;：稱每一個「資料節點」為vertex(或是node)，並定義所有的vertex所形成之集合(Set)為&lt;span class="math"&gt;\(V\)&lt;/span&gt;或&lt;span class="math"&gt;\(V(G)\)&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;edge&lt;/strong&gt;：稱每一個「線段(箭號)」為edge(實際上是用一對vertex表示edge，例如&lt;span class="math"&gt;\((V_i,V_j)\)&lt;/span&gt;即為連結V&lt;sub&gt;i&lt;/sub&gt;與V&lt;sub&gt;j&lt;/sub&gt;的edge)，並定義所有的edge所形成之集合(Set)為&lt;span class="math"&gt;\(E\)&lt;/span&gt;或&lt;span class="math"&gt;\(E(G)\)&lt;/span&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;則Graph定義為&lt;span class="math"&gt;\(V\)&lt;/span&gt;與&lt;span class="math"&gt;\(E\)&lt;/span&gt;所形成的集合，表示成&lt;span class="math"&gt;\(G(V,E)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;再根據edge是否具有「方向性」，可以將Graph分成「directed graph(有向圖)」與「undirected graph(無向圖)」：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;directed graph(有向圖)&lt;/strong&gt;：edge的方向性表示資料間的關係，若vertex(A)與vertex(B)之關係是「單向的」，那麼連結vertex(A)與vertex(B)的edge即具有方向性。  &lt;ul&gt;
&lt;li&gt;以圖一中的課程與其先修科目為例，vertex(Data Structures)是vertex(Analysis of Algorithm)的先修課程，相反則否，因此，連結兩個vertex之edge具有方向性，而所有vertex與edge形成之集合即為directed graph；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;undirected graph(無向圖)&lt;/strong&gt;：edge的方向性表示資料間的關係，若vertex(A)與vertex(B)的關係是「雙向的」，那麼連結vertex(A)與vertex(B)之edge就不具有方向性。  &lt;ul&gt;
&lt;li&gt;如圖二中，如果可以開車從玉山抵達太魯閣，就能夠從太魯閣原路折返回到玉山，因此，這兩個地理位置之間的交通路線便不具有方向性。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="google_map" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/Intro_fig/f_2.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二：Google Map路線規劃，開車過去要4小時34分鐘。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;再看幾個Graph的範例。&lt;br /&gt;
圖三(a)中的G&lt;sub&gt;1&lt;/sub&gt;與G&lt;sub&gt;2&lt;/sub&gt;為undirected graph，圖三(b)中的G&lt;sub&gt;3&lt;/sub&gt;與G&lt;sub&gt;4&lt;/sub&gt;為directed graph。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="undirected" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/Intro_fig/f3.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(a)：Tree(樹)也是undirected graph(無向圖)。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="directed" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/Intro_fig/f4.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(b)：directed graph(有向圖)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="represent"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;表示法(representation)&lt;/h3&gt;
&lt;p&gt;那麼該如何表示Graph呢？&lt;br /&gt;
一般有兩種常用的表示法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Adjacency Matrix(相鄰矩陣)&lt;/strong&gt;：一個二維矩陣，若從vertex(A)到vertex(B)有edge，則矩陣位置[A][B]值為&lt;span class="math"&gt;\(1\)&lt;/span&gt;，反之，則為&lt;span class="math"&gt;\(0\)&lt;/span&gt;。  &lt;ul&gt;
&lt;li&gt;以圖四為例，在undireced graph中，vertex(X)與vertex(Y)之間有edge，則矩陣位置[X][Y]與[Y][X]之值皆為&lt;span class="math"&gt;\(1\)&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;在directed graph中，有從vertex(X)指向vertex(Y)的edge，則矩陣位置[X][Y]之值為&lt;span class="math"&gt;\(1\)&lt;/span&gt;，但是沒有反向的edge，因此矩陣位置[Y][X]之值為&lt;span class="math"&gt;\(0\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Adjacency List(相鄰串列)&lt;/strong&gt;：先以一個一維陣列列出所有的vertex，再以Linked list表示所有與vertex相連的vertex。&lt;br /&gt;
(vertex接進Linked list的順序不重要，因為是Graph是定義成Set。)  &lt;ul&gt;
&lt;li&gt;以圖四為例，在undireced graph中，vertex(W)與vertex(Z)、vertex(Y)、vertex(V)具有edge相連，則在一維陣列中表示vertex(W)之位置之後，依序接上vertex(Z)、vertex(Y)、vertex(V)。&lt;/li&gt;
&lt;li&gt;在direced graph中，vertex(W)僅僅剩下指向vertex(Y)與vertex(V)的edge，因此，在一維陣列中表示vertex(W)之位置之後，只要接上vertex(Y)與vertex(V)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="selfloop" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/Intro_fig/f_5.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四：Adjacency Matrix與Adjacency List適用於directed graph與undirected graph。&lt;/strong&gt; 
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;比較兩者的差異：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用記憶體空間：&lt;ol&gt;
&lt;li&gt;Adjacency Matrix：一定會用到&lt;span class="math"&gt;\(O(|V|^2)\)&lt;/span&gt;，因此，若Graph較為「稠密(dense)」，各vertex之間的edge數量較多則適合使用Adjacency Matrix；&lt;/li&gt;
&lt;li&gt;Adjacency List：將使用&lt;span class="math"&gt;\(O(|V|+|E|)\)&lt;/span&gt;，因此，若Graph較為「稀疏(sparse)」，edge數量較少，如圖一的Graph，即適合使用Adjacency List。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;存取資料：&lt;ol&gt;
&lt;li&gt;Adjacency Matrix：由於Matrix是連續記憶體，在存取資料時會稍微快一些；&lt;/li&gt;
&lt;li&gt;Adjacency List：同理，若是使用動態記憶體配置建立Linked list，則資料存取會稍慢(這項缺點可以使用C++的STL::Vector解決，不過STL::Vector不適合用在動態改變的Graph上)。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;新增edge：&lt;ol&gt;
&lt;li&gt;Adjacency Matrix：在Matrix中增加一條edge僅僅是把矩陣中相對應位置的值從&lt;span class="math"&gt;\(0\)&lt;/span&gt;設成&lt;span class="math"&gt;\(1\)&lt;/span&gt;，只需要&lt;span class="math"&gt;\(O(1)\)&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;Adjacency List：若每次都把新的vertex加在List的最前端(front)，也只需要&lt;span class="math"&gt;\(O(1)\)&lt;/span&gt;。不過，最壞情況(worst case)發生在「某個vertex與其他vertex全部相連」，因此需要&lt;span class="math"&gt;\(O(|E|)\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;刪除edge：&lt;ol&gt;
&lt;li&gt;Adjacency Matrix：在Matrix中刪除edge僅僅是把矩陣中相對應位置的值從&lt;span class="math"&gt;\(1\)&lt;/span&gt;設成&lt;span class="math"&gt;\(0\)&lt;/span&gt;，只需要&lt;span class="math"&gt;\(O(1)\)&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;Adjacency List：如同在Linked list中刪除資料，需要&lt;span class="math"&gt;\(O(|E|)\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name="terminology"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;一些名詞解釋&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;adjacent(相鄰)&lt;/strong&gt;：若在vertex(A)與vertex(B)之間有一條edge(不論是否具有方向性)，則稱vertex(A)與vertex(B)為adjacent(相鄰)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;subgraph(子圖)&lt;/strong&gt;：若構成G'的兩個集合滿足&lt;span class="math"&gt;\(V(G')\subseteq V(G), E(G')\subseteq E(G)\)&lt;/span&gt;，則稱G'為G的subgraph，如圖五。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="subgraph" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/Intro_fig/f_6.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五：G與G的subgraph。&lt;/strong&gt; 
&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;path(路徑)&lt;/strong&gt;：若從vertex(V&lt;sub&gt;1&lt;/sub&gt;)到vertex(V&lt;sub&gt;k&lt;/sub&gt;)存在一連串前後相接的edge(&lt;span class="math"&gt;\((V_i,V_{i+1})\subseteq E(G),i=1,2,...,k-1\)&lt;/span&gt;)，則稱這一連串edge為「從vertex(V&lt;sub&gt;1&lt;/sub&gt;)到vertex(V&lt;sub&gt;k&lt;/sub&gt;)的path」。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;length(長度)/distance(距離)&lt;/strong&gt;：length(或distance)即是path中的edge數。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;simple path(簡單路徑)&lt;/strong&gt;：若一條path中，除了起點vertex與終點vertex之外，沒有vertex被重複經過，則稱這條path為simple path。  &lt;ul&gt;
&lt;li&gt;如圖六中，path:X-Y-Z即為simple path，path:W-Y-Z-V-W也是simple path，即使W有重複，但是因為分別是起點與終點，所以仍符合定義。而path:Y-X-Y-W就不是simple path，因為第二次經過Y時，Y不是終點。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="subgraph" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/Intro_fig/f_7.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖六：。&lt;/strong&gt; 
&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;cycle(循環)&lt;/strong&gt;：若有ㄧ條「simple path」的起點vertex與終點vertex相同，則稱這條path為cycle。  &lt;ul&gt;
&lt;li&gt;圖六中的path:W-Y-Z-V-W，稱為directed cycle(有向循環)；&lt;/li&gt;
&lt;li&gt;圖七中的path:Y-V-W-Y與path:X-Y-W-Z-X皆為undirected cycle(無向循環)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;acyclic graph(無循環圖)&lt;/strong&gt;：若graph中不存在cycle，則稱這個graph為acyclic graph，見圖七。  &lt;ul&gt;
&lt;li&gt;在Tree中找不到任何一條simple path的起點與終點是相同vertex(node)，因此Tree一定是acyclic graph。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="subgraph" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/Intro_fig/f_8.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖七：。&lt;/strong&gt; 
&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;weight(權重)&lt;/strong&gt;：若要表示兩個地理位置之間的「距離」或是運送「成本」，可以在edge上加上weight，這樣的graph又稱為weighted graph，如圖八。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="subgraph" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/Intro_fig/f_9.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖八：weight的值可能為正或是負。&lt;/strong&gt; 
&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;connected&lt;/strong&gt;：若存在從vertex(A)指向vertex(B)、以及從vertex(B)指向vertex(A)的edge(若是在directed graph中，需要兩條edge；若是undirected graph只需要一條edge)，則稱vertex(A)與vertex(B)為connected，見圖九(a)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="subgraph" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/Intro_fig/f_10.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖九(a)：。&lt;/strong&gt; 
&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;connected in undirected graph&lt;/strong&gt;：若在undirected graph中，對任意兩個vertex都存在一條path連結這兩個vertex，則稱此undirected graph是connected。  &lt;ul&gt;
&lt;li&gt;圖九(b)中，G&lt;sub&gt;1&lt;/sub&gt;中的所有vertex都可以經過一條path到達其他vertex，因此G&lt;sub&gt;1&lt;/sub&gt;為connected。  &lt;/li&gt;
&lt;li&gt;G&lt;sub&gt;2&lt;/sub&gt;中，vertex:X、S、Z分別與vertex:Y、W、T之間皆不存在path，因此G&lt;sub&gt;2&lt;/sub&gt;不是connected。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;connected component&lt;/strong&gt;：若在一個undirected graph中，存在某一個subgraph是connected，而且沒有任何vertex、edge再加入這個subgraph之集合後仍能使得這個subgraph維持connected特性，則稱此subgraph為connected component(最大集合的connected subgraph)。  &lt;ul&gt;
&lt;li&gt;圖九(b)中，右上方為G&lt;sub&gt;1&lt;/sub&gt;的其中一個subgraph。此subgraph不是connected component，原因在於，再加入vertex:W、T，以及edge:(Y,W)、(Y,T)，也就是變回G&lt;sub&gt;1&lt;/sub&gt;後，仍然維持connected特性，因此這個subgraph並不是「可以維持connected的最大集合」。&lt;br /&gt;
換句話說，在一個connected的undirected graph中，只會有一個connected component，就是graph本身。  &lt;/li&gt;
&lt;li&gt;圖九(b)的G&lt;sub&gt;2&lt;/sub&gt;本身不是connected，而是由兩個connected component組成。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="subgraph" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/Intro_fig/f_11.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖九(b)：。&lt;/strong&gt; 
&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;strongly connected in directed graph&lt;/strong&gt;：若在directed graph中，對任意兩個vertex(A)與vertex(B)同時存在「從vertex(A)走到vertex(B)」以及「從vertex(B)走到vertex(A)」的path，則稱此directed graph是strongly connected。&lt;ul&gt;
&lt;li&gt;圖九(c)，G&lt;sub&gt;3&lt;/sub&gt;中的所有vertex都可以經過一條path到達其他vertex，因此G&lt;sub&gt;3&lt;/sub&gt;為strongly connected。&lt;/li&gt;
&lt;li&gt;G&lt;sub&gt;4&lt;/sub&gt;並非strongly connected，例如，雖然path:S-X-T-Z可以從vertex(S)走到vertex(Z)，但是從vertex(Z)卻無法經由任何一條path到達vertex(S)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;strongly connected component&lt;/strong&gt;：若在一個directed graph中，存在某一個subgraph是strongly connected，而且沒有任何vertex、edge再加入這個subgraph之集合後仍能使得這個subgraph維持strongly connected特性，則稱此subgraph為strongly connected component(最大集合的strongly connected subgraph)。&lt;ul&gt;
&lt;li&gt;圖九(c)中，右上方為G&lt;sub&gt;3&lt;/sub&gt;的其中一個subgraph。此subgraph不是strongly connected component，原因在於，再加入edge:(W,Z)後(也就是變回G&lt;sub&gt;3&lt;/sub&gt;)，仍然維持connected特性，因此這個subgraph並不是「可以維持connected的最大集合」。&lt;br /&gt;
如同undirected graph，若一個directed graph本身是strongly sonnected，則本身也是唯一的strongly connected component。&lt;/li&gt;
&lt;li&gt;G&lt;sub&gt;4&lt;/sub&gt;是由三個strongly connected component組成。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="subgraph" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/Intro_fig/f_12.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖九(c)：。&lt;/strong&gt; 
&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;self-loop(自我迴圈)&lt;/strong&gt;：若有edge從vertex(A)指向vertex(A)，即稱為self-edge或是self-loop。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;multigraph(多邊圖)&lt;/strong&gt;：若在graph中相同的edge重複出現多次，則稱此圖為multigraph，之後要討論的Graph將排除此種情形。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="selfloop" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/Intro_fig/f_13.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖十：self-loop與multigraph在directed graph和undirected graph中定義皆相同。&lt;/strong&gt; 
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="app"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;預告：Graph的應用&lt;/h2&gt;
&lt;p&gt;在接下來的文章，主要將探討以下三個應用的演算法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Minimum Spanning Tree(MST，最小生成樹)&lt;/strong&gt;：給定一個connected、weighted的undirected graph，要在這個graph中，找到(1)連結所有vertex，而且(2)edge上的weight總和最小的「Tree」。&lt;br /&gt;
例如，鄉公所要鋪路，先以鄉公所為中心(&lt;code&gt;root&lt;/code&gt;)，把所有馬路必須到達的地區視為vertex，則路就是edge，那麼，鋪路的目標便是利用最低成本(weight總和最小)將馬路延伸到所有必須抵達的地區，這就是MST的問題。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Shortest Path(最短路徑)&lt;/strong&gt;：顧名思義，最短路徑即是找到vertex(A)與vertex(B)之間lenght最小的path，例如Google Map。&lt;br /&gt;
其中又可以分為：&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Single Source Single Destination&lt;/strong&gt;：從一個vertex，抵達特定的另一個vertex之最短路徑；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Single Source All Destination&lt;/strong&gt;：從一個vertex，抵達graph中其餘所有vertex之最短路徑；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;All Source Single Destination&lt;/strong&gt;：從每一個graph中的vertex抵達特定的vertex之最短路徑；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;All Source All Destination&lt;/strong&gt;：graph中的所有vertex抵達其餘所有vertex之最短路徑。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Network Flow(網路流)&lt;/strong&gt;：若現在有一個複雜的水管系統，水從入水口流入，經過許多互相連結、且孔徑不一的水管後，從出水口流出，目標是一次流入最大量的水。&lt;br /&gt;
其中可能遇到的問題如：由於水管的孔徑各不相同，若先流過一條半徑只有2公分的水管，則接在其後的水管的半徑即使再大，水流量仍會被半徑2公分的水管所限制，因此整體流量也就受限制。&lt;br /&gt;
如何分配水流在水管之間的流法，即是Network Flow要處理的問題。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;不過在介紹以上三項主題之前，下兩篇文章將先介紹在Graph中最基本的搜尋(Search)方法：Breadth-First Search(BFS，廣度優先搜尋)與Depth-First Search(DFS，深度優先搜尋)。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a name="ref"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;參考資料：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844"&gt;Introduction to Algorithms, Ch22&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376"&gt;Fundamentals of Data Structures in C++, Ch6&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.hackerearth.com/notes/graph-theory-part-i/"&gt;Hacker Earth：Graph Theory - Part I &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://theoryofprogramming.com/2014/12/24/graph-theory-basics/"&gt;Theory of Programming：Graph Theory Basics&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Tree_%28graph_theory%29"&gt;Wikipedia：Tree(graph theory)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.google.com.tw/maps/dir/%E7%8E%89%E5%B1%B1%E5%9C%8B%E5%AE%B6%E5%85%AC%E5%9C%92%E7%AE%A1%E7%90%86%E8%99%95+553%E5%8D%97%E6%8A%95%E7%B8%A3%E6%B0%B4%E9%87%8C%E9%84%89%E4%B8%AD%E5%B1%B1%E8%B7%AF%E4%B8%80%E6%AE%B5300%E8%99%9F/%E8%8A%B1%E8%93%AE%E7%B8%A3%E5%A4%AA%E9%AD%AF%E9%96%A3%E5%9C%8B%E5%AE%B6%E5%85%AC%E5%9C%92%E7%AE%A1%E7%90%86%E8%99%95/@23.9945162,121.0278493,10.35z/data=!4m13!4m12!1m5!1m1!1s0x34692ae27ea40fff:0xab9c90d0fc985ac5!2m2!1d120.8504096!2d23.8128448!1m5!1m1!1s0x34688286a79bc241:0x9c0222099dc32245!2m2!1d121.621627!2d24.158708?hl=zh-TW"&gt;Google Map：從玉山國家公園到太魯閣國家公園&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name="series"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h2&gt;Graph系列文章&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/graph-introjian-jie.html"&gt;Graph: Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/graph-breadth-first-searchbfsguang-du-you-xian-sou-xun.html"&gt;Graph: Breadth-First Search(BFS，廣度優先搜尋)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/graph-depth-first-searchdfsshen-du-you-xian-sou-xun.html"&gt;Graph: Depth-First Search(DFS，深度優先搜尋)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/graph-li-yong-dfshe-bfsxun-zhao-connected-component.html"&gt;Graph: 利用DFS和BFS尋找Connected Component&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/grpah-li-yong-dfsxun-zhao-strongly-connected-componentscc.html"&gt;Grpah: 利用DFS尋找Strongly Connected Component(SCC)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/grpah-li-yong-dfsxun-zhao-dagde-topological-sorttuo-pu-pai-xu.html"&gt;Grpah: 利用DFS尋找DAG的Topological Sort(拓撲排序)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="C++"></category><category term="Graph"></category><category term="Intro"></category></entry><entry><title>Red Black Tree: Delete(刪除資料)與Fixup(修正)</title><link href="http://alrightchiu.github.io/SecondRound/red-black-tree-deleteshan-chu-zi-liao-yu-fixupxiu-zheng.html" rel="alternate"></link><updated>2016-01-30T14:11:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2016-01-30:SecondRound/red-black-tree-deleteshan-chu-zi-liao-yu-fixupxiu-zheng.html</id><summary type="html">&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;先備知識與注意事項&lt;/h3&gt;
&lt;p&gt;如同&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-insertxin-zeng-zi-liao-yu-fixupxiu-zheng.html"&gt;Red Black Tree: Insert(新增資料)與Fixup(修正)&lt;/a&gt;，RBT之Delete(刪除資料)方法同樣是先沿用&lt;code&gt;DeleteBST()&lt;/code&gt;，再對顏色利用&lt;code&gt;Rotation&lt;/code&gt;進行修正。&lt;br /&gt;
建議讀者在閱讀本篇文章之前，先復習&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-sortpai-xu-deleteshan-chu-zi-liao.html#delete"&gt;BST::DeleteBST(刪除資料)&lt;/a&gt;與&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-rotationxuan-zhuan.html"&gt;Red Black Tree: Rotation(旋轉)&lt;/a&gt;，會比較容易上手。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#violate"&gt;於RBT中Delete(刪除資料)可能違反RBT之特徵&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#bst"&gt;如同於BST中Delete(刪除資料)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#fixup"&gt;修正：DeleteFixUpRBT()&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#case1"&gt;Case1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#case2"&gt;Case2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#case3"&gt;Case3&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#case4"&gt;Case4&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#example"&gt;範例&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#code"&gt;程式碼&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#ref"&gt;參考資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#tree_series"&gt;Tree系列文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="violate"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;於RBT中Delete(刪除資料)可能違反RBT之特徵&lt;/h2&gt;
&lt;p&gt;在RBT中執行Delete(刪除資料)時，若刪除之node為黑色，有可能違反三點RBT特徵：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;圖一(a)：若要刪除的node恰好為&lt;code&gt;root&lt;/code&gt;，而刪除後恰好是紅色的node遞補成為新的&lt;code&gt;root&lt;/code&gt;，此時便違反RBT之第二點特徵：&lt;code&gt;root&lt;/code&gt;一定要是黑色；&lt;/li&gt;
&lt;li&gt;圖一(b)：若刪除node後，出現紅色與紅色node相連之情形，則違反RBT之第四點特徵：紅色node之&lt;code&gt;child&lt;/code&gt;一定要是黑色；&lt;/li&gt;
&lt;li&gt;圖一(b)：若刪除之node是黑色，則所有包含被刪除node的path上之黑色node數必定會減少，若恰好被刪除之node不是&lt;code&gt;root&lt;/code&gt;，將會違反RBT之第五點特徵：站在任何一個node上，所有從該node走到其任意descendant的path上之黑色node數必定相同。&lt;br /&gt;
圖一(b)左：從&lt;code&gt;root&lt;/code&gt;node(B)出發至任意leaves的path上都有三個黑色node(包含&lt;code&gt;NIL&lt;/code&gt;)；&lt;br /&gt;
圖一(b)右：刪除node(D)後，path(node(B)-node(E)-node(C))上之黑色node數剩下&lt;span class="math"&gt;\(2\)&lt;/span&gt;個(包含&lt;code&gt;NIL&lt;/code&gt;)。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因此，需要對顏色進行修正，以滿足RBT特徵。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="violate" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete1.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(a)：違反RBT之第二點與第四點特徵。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="violate" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete2.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(b)：違反RBT之第四點與第五點特徵。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="bst"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;如同於BST中Delete(刪除資料)&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;RBT::DeleteRBT()&lt;/code&gt;之範例程式碼分成兩個部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第一部分，如同&lt;code&gt;DeleteBST()&lt;/code&gt;，依照欲刪除之node的&lt;code&gt;child&lt;/code&gt;個數分成三種情形處理：&lt;ol&gt;
&lt;li&gt;先確認BST中有沒有要刪除的node；&lt;/li&gt;
&lt;li&gt;把要刪除的node調整成「至多只有一個&lt;code&gt;child&lt;/code&gt;」；&lt;/li&gt;
&lt;li&gt;把要刪除的node的&lt;code&gt;child&lt;/code&gt;指向新的&lt;code&gt;parent&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;把要刪除的node的&lt;code&gt;parent&lt;/code&gt;指向新的&lt;code&gt;child&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;若實際上刪除的是「替身」，再把替身的資料放回BST中；&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;第二部分，若刪除的node是黑色，需要進行修正(Fix-Up)，引進函式：&lt;code&gt;DeleteFixedUpRBT()&lt;/code&gt;。 &lt;br /&gt;
&lt;/br&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;RBT&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;DeleteRBT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;KEY&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;              &lt;span class="c1"&gt;// 要刪除具有KEY的node&lt;/span&gt;

    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;delete_node&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;delete_node&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Search&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;KEY&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;             &lt;span class="c1"&gt;// 先確認BST中是否有具有KEY的node&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;delete_node&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;data not found.&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;     &lt;span class="c1"&gt;// 真正要被刪除並釋放記憶體的node&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;     &lt;span class="c1"&gt;// 要被刪除的node的child&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;delete_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;neel&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;delete_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;neel&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;delete_node&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
        &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Successor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;delete_node&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                                           &lt;span class="c1"&gt;// 經過以上的if-else, y至多只有一個child&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;neel&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;              &lt;span class="c1"&gt;// 將x設成y的child, 可能是實際資料, 也有可能是NIL&lt;/span&gt;
        &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
        &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                 &lt;span class="c1"&gt;// 即使x是NIL也要把x的parent指向有效的記憶體位置&lt;/span&gt;
                                           &lt;span class="c1"&gt;// 因為在FixUp時需要藉由x-&amp;gt;parent判斷x為leftchild或是rightchild&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;neel&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;                 &lt;span class="c1"&gt;// 再將要被刪除的node之parent指向新的child&lt;/span&gt;
        &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                    
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
        &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;delete_node&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;                &lt;span class="c1"&gt;// 若實際上是「替身」被刪除, 要把「替身」的資料放回RBT中&lt;/span&gt;
        &lt;span class="n"&gt;delete_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;SetKey&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;GetKey&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
        &lt;span class="n"&gt;delete_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;SetElement&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;GetElement&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;                   &lt;span class="c1"&gt;// 若刪除的node是黑色, 則要從x進行修正&lt;/span&gt;
        &lt;span class="n"&gt;DeleteFixedUpRBT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="fixup"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;修正：DeleteFixUpRBT()&lt;/h2&gt;
&lt;p&gt;考慮在圖二之RBT中刪除node(B)，由於node(B)是黑色，必定違反RBT之特徵，因此需要修正。&lt;br /&gt;
(以下圖示中，白色的node表示顏色可能為黑色也可能為紅色，而且可能是一棵subtree或是&lt;code&gt;NIL&lt;/code&gt;，需視情況而定。)&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="original" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete3.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二：。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;根據&lt;code&gt;sibling&lt;/code&gt;之顏色與&lt;code&gt;sibling&lt;/code&gt;之&lt;code&gt;child&lt;/code&gt;之顏色，可以分為下列四種情形(Case)，如圖三：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Case1：&lt;code&gt;sibling&lt;/code&gt;為紅色；&lt;/li&gt;
&lt;li&gt;Case2：&lt;code&gt;sibling&lt;/code&gt;為黑色，而且&lt;code&gt;sibling&lt;/code&gt;的兩個&lt;code&gt;child&lt;/code&gt;都是黑色；&lt;/li&gt;
&lt;li&gt;Case3：&lt;code&gt;sibling&lt;/code&gt;為黑色，而且&lt;code&gt;sibling&lt;/code&gt;的&lt;code&gt;rightchild&lt;/code&gt;是黑色；&lt;/li&gt;
&lt;li&gt;Case4：&lt;code&gt;sibling&lt;/code&gt;為黑色，而且&lt;code&gt;sibling&lt;/code&gt;的&lt;code&gt;rightchild&lt;/code&gt;是紅色。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="4cases" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete4.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三：。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;DeleteFixUpRBT()&lt;/code&gt;的情形(Case)較為複雜，圖四是所有情形之循環圖：&lt;br /&gt;
(&lt;code&gt;current&lt;/code&gt;即是被刪除的node之&lt;code&gt;child&lt;/code&gt;)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若&lt;code&gt;current&lt;/code&gt;是黑色的，而且&lt;code&gt;current&lt;/code&gt;不為&lt;code&gt;root&lt;/code&gt;，則依情況進入四個Case；&lt;/li&gt;
&lt;li&gt;若進入Case1，修正後，將進入Case2、Case3或Case4；&lt;/li&gt;
&lt;li&gt;若進入Case2，有可能修正後即符合RBT特徵，也有可能根據新的&lt;code&gt;current&lt;/code&gt;之情形重新判斷起；&lt;/li&gt;
&lt;li&gt;若進入Case3，修正後必定進入Case4；&lt;/li&gt;
&lt;li&gt;若進入Case4，修正後必定符合RBT之特徵。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="flow" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete5.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四：。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="case1"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Case1&lt;/h3&gt;
&lt;p&gt;若&lt;code&gt;sibling&lt;/code&gt;為紅色，修正方法如下，見圖五(a)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;將&lt;code&gt;sibling&lt;/code&gt;塗成黑色：node(E)塗成黑色；&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;current&lt;/code&gt;之&lt;code&gt;parent&lt;/code&gt;塗成紅色：node(C)塗成紅色；&lt;/li&gt;
&lt;li&gt;對&lt;code&gt;current&lt;/code&gt;之&lt;code&gt;parent&lt;/code&gt;做Left Rotation：對node(C)做Left Rotation；&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;sibling&lt;/code&gt;移動到&lt;code&gt;current-&amp;gt;parent&lt;/code&gt;的&lt;code&gt;rightchild&lt;/code&gt;：將&lt;code&gt;sibling&lt;/code&gt;移動至node(D)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="case1" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete6.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五(a)：。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;在上述步驟中，並沒有更改&lt;code&gt;current&lt;/code&gt;之記憶體位置和顏色，&lt;code&gt;current&lt;/code&gt;仍為黑色。不過其&lt;code&gt;sibling&lt;/code&gt;必定會變成黑色，因此將進入Case2、Case3或Case4。&lt;/p&gt;
&lt;p&gt;為什麼Case1經過以上修正還沒有結束？原因要回到刪除node之前的RBT。&lt;br /&gt;
圖五(b)左，展示了刪除node之前，以node(C)為&lt;code&gt;root&lt;/code&gt;的RBT(或是更大的RBT之subtree)的其中一種可能情況。&lt;br /&gt;
從node(C)往任何一個descendant leaf的path上之黑色node數為&lt;span class="math"&gt;\(3\)&lt;/span&gt;，刪除node(B)後，使得其中一條path的黑色node數減少，經過上述方法之調整，仍然無法使得所有path之黑色node數相同，如圖五(b)右。&lt;br /&gt;
不過Case1所提出的修正方法能夠將情況調整成Case2、Case3或Case4，並且修正至滿足RBT之特徵。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="case1" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete7.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五(b)：圖中的「Original」僅代表其中一種可能的情形。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="case2"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Case2&lt;/h3&gt;
&lt;p&gt;若&lt;code&gt;sibling&lt;/code&gt;為黑色，並且&lt;code&gt;sibling&lt;/code&gt;之兩個&lt;code&gt;child&lt;/code&gt;皆為黑色，修正的方法如下，見圖五(c)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;將&lt;code&gt;sibling&lt;/code&gt;塗成紅色：node(E)塗成紅色；&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;current&lt;/code&gt;移至&lt;code&gt;currnet&lt;/code&gt;的&lt;code&gt;parent&lt;/code&gt;：&lt;code&gt;current&lt;/code&gt;移至node(c)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="case2" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete8.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五(c)：。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;經過上述步驟，根據新的&lt;code&gt;current&lt;/code&gt;node(C)之顏色，可以分成兩種情形：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若node(C)為紅色，則跳出迴圈，把node(C)塗黑，即可滿足RBT之特徵，如圖五(d)，其邏輯便是：將從node(C)出發往&lt;code&gt;leftchild&lt;/code&gt;與&lt;code&gt;rightchild&lt;/code&gt;path的黑色數目調整成與刪除之前(Original)相同；&lt;/li&gt;
&lt;li&gt;若node(C)為黑色，且node(C)不是&lt;code&gt;root&lt;/code&gt;，則繼續下一輪迴圈，重新判斷其屬於四種情況之何者並修正，如圖五(e)，從node(G)出發至任意descendant leaf之path上的黑色node數並不完全相同。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="case2" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete9.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五(d)：圖中的「Original」僅代表其中一種可能的情形。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="case2" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete10.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五(e)：圖中的「Original」僅代表其中一種可能的情形。此時的RBT還要繼續修正，見Case3。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="case3"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Case3&lt;/h3&gt;
&lt;p&gt;若&lt;code&gt;sibling&lt;/code&gt;為黑色，並且&lt;code&gt;sibling&lt;/code&gt;之&lt;code&gt;rightchild&lt;/code&gt;為黑色，修正的方法如下，見圖五(f)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;將&lt;code&gt;sibling&lt;/code&gt;之&lt;code&gt;leftchild&lt;/code&gt;塗成黑色：node(D)塗成黑色；&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;sibling&lt;/code&gt;塗成紅色：node(E)塗成紅色；&lt;/li&gt;
&lt;li&gt;對&lt;code&gt;sibling&lt;/code&gt;進行Right Rotation：對node(E)進行Right Rotation；&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;sibling&lt;/code&gt;移至&lt;code&gt;current-&amp;gt;parent&lt;/code&gt;的&lt;code&gt;rightchild&lt;/code&gt;：將&lt;code&gt;sibling&lt;/code&gt;移至node(D)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="case3" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete11.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五(f)：。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;經過以上修正步驟，&lt;code&gt;sibling&lt;/code&gt;之&lt;code&gt;rightchild&lt;/code&gt;成為紅色，便進入Case4。&lt;/p&gt;
&lt;p&gt;&lt;a name="case4"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Case4&lt;/h3&gt;
&lt;p&gt;若&lt;code&gt;sibling&lt;/code&gt;為黑色，並且&lt;code&gt;sibling&lt;/code&gt;之&lt;code&gt;rightchild&lt;/code&gt;為紅色，修正的方法如下，見圖五(g)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;將&lt;code&gt;sibling&lt;/code&gt;塗成&lt;code&gt;current&lt;/code&gt;之&lt;code&gt;parent&lt;/code&gt;的顏色：若node(C)是紅色，則將node(E)塗成紅色，若node(C)是黑色，則將node(E)塗成黑色；&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;parent&lt;/code&gt;塗成黑色：node(C)塗成黑色；&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;sibling&lt;/code&gt;之&lt;code&gt;rightchild&lt;/code&gt;塗成黑色：node(F)塗成黑色；&lt;/li&gt;
&lt;li&gt;對&lt;code&gt;parent&lt;/code&gt;進行Left Rotation：對node(C)做Left Rotation；&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;current&lt;/code&gt;移至&lt;code&gt;root&lt;/code&gt;，把&lt;code&gt;root&lt;/code&gt;塗黑。&lt;br /&gt;
(注意：圖五(d)之node(E)未必是RBT之&lt;code&gt;root&lt;/code&gt;。)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="case4" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete12.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五(g)：。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;如圖五(h)所示，Case4修正方法的邏輯便是：在刪除node(B)之後的RBT(或是subtree)中，將所有從&lt;code&gt;root&lt;/code&gt;位置(調整前是node(C)，調整後是node(E))出發往任意descendant leaf之path上的黑色數目調整成與刪除之前(Original)相同，因此，經過Case4的修正一定能夠滿足RBT之特徵。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="case4" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete13.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五(h)：圖中的「Original」僅代表其中一種可能的情形。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="example"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;範例&lt;/h3&gt;
&lt;p&gt;接著以一個簡單的範例(圖六(a)之RBT)操作上述四種Case的修正方法。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="example" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete14.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖六(a)：。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;若考慮刪除node(19)，由於node(19)是黑色，需要修正。&lt;br /&gt;
接著判斷，node(19)的&lt;code&gt;child&lt;/code&gt;(為黑色的&lt;code&gt;NIL&lt;/code&gt;)之&lt;code&gt;sibling&lt;/code&gt;為黑色，且&lt;code&gt;sibling&lt;/code&gt;之&lt;code&gt;rightchild&lt;/code&gt;為黑色，符合Case3的描述，因此利用Case3之修正方法，見圖六(b)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;將&lt;code&gt;sibling&lt;/code&gt;之&lt;code&gt;leftchild&lt;/code&gt;塗成黑色：node(24)塗成黑色；&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;sibling&lt;/code&gt;塗成紅色：node(27)塗成紅色；&lt;/li&gt;
&lt;li&gt;對&lt;code&gt;sibling&lt;/code&gt;進行Right Rotation：對node(27)進行Right Rotation；&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;sibling&lt;/code&gt;移至&lt;code&gt;current-&amp;gt;parent&lt;/code&gt;的&lt;code&gt;rightchild&lt;/code&gt;：將&lt;code&gt;sibling&lt;/code&gt;移至node(24)；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接著進入Case4：&lt;code&gt;subling&lt;/code&gt;為黑色，而且&lt;code&gt;sibling&lt;/code&gt;之&lt;code&gt;rightchild&lt;/code&gt;為紅色，進行修正：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;將&lt;code&gt;sibling&lt;/code&gt;塗成&lt;code&gt;current&lt;/code&gt;之&lt;code&gt;parent&lt;/code&gt;的顏色：node(22)是黑色，則將node(24)塗成黑色；&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;parent&lt;/code&gt;塗成黑色：node(22)塗成黑色；&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;sibling&lt;/code&gt;之&lt;code&gt;rightchild&lt;/code&gt;塗成黑色：node(27)塗成黑色；&lt;/li&gt;
&lt;li&gt;對&lt;code&gt;parent&lt;/code&gt;進行Left Rotation：對node(22)做Left Rotation；&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;current&lt;/code&gt;移至&lt;code&gt;root&lt;/code&gt;，把&lt;code&gt;root&lt;/code&gt;塗黑。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="example" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete15.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖六(b)：。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;如此一來便再次滿足RBT之特徵限制，如圖六(c)。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="example" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete16.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖六(c)：。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;再考慮刪除黑色的node(45)，判斷：node(45)之&lt;code&gt;child&lt;/code&gt;(為黑色的&lt;code&gt;NIL&lt;/code&gt;)之&lt;code&gt;sibling&lt;/code&gt;為黑色，且&lt;code&gt;sibling&lt;/code&gt;之&lt;code&gt;rightchild&lt;/code&gt;為紅色，符合Case4的描述，並利用Case4方法修正，見圖六(d)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;將&lt;code&gt;sibling&lt;/code&gt;塗成&lt;code&gt;current&lt;/code&gt;之&lt;code&gt;parent&lt;/code&gt;的顏色：node(22)是黑色，則將node(24)塗成黑色；&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;parent&lt;/code&gt;塗成黑色：node(22)塗成黑色；&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;sibling&lt;/code&gt;之&lt;code&gt;rightchild&lt;/code&gt;塗成黑色：node(27)塗成黑色；&lt;/li&gt;
&lt;li&gt;對&lt;code&gt;parent&lt;/code&gt;進行Left Rotation：對node(22)做Left Rotation；&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;current&lt;/code&gt;移至&lt;code&gt;root&lt;/code&gt;，把&lt;code&gt;root&lt;/code&gt;塗黑。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="example" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete17.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖六(d)：。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;如此一來便再次滿足RBT之特徵限制，如圖六(e)。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="example" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete18.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖六(e)：。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;接著考慮刪除黑色的node(39)，判斷：node(45)之&lt;code&gt;child&lt;/code&gt;(為黑色的&lt;code&gt;NIL&lt;/code&gt;)之&lt;code&gt;sibling&lt;/code&gt;為紅色，符合Case1之描述，便利用Case1之方法，調整成Case4，見圖六(f)：&lt;/p&gt;
&lt;p&gt;Case1調整：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;將&lt;code&gt;sibling&lt;/code&gt;塗成黑色：node(52)塗成黑色；&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;current&lt;/code&gt;之&lt;code&gt;parent&lt;/code&gt;塗成紅色：node(41)塗成紅色；&lt;/li&gt;
&lt;li&gt;對&lt;code&gt;current&lt;/code&gt;之&lt;code&gt;parent&lt;/code&gt;做Left Rotation：對node(41)做Left Rotation；&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;sibling&lt;/code&gt;移動到&lt;code&gt;current-&amp;gt;parent&lt;/code&gt;的&lt;code&gt;rightchild&lt;/code&gt;：將&lt;code&gt;sibling&lt;/code&gt;移動至node(48)；  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;再利用Case4的方法修正，便能滿足RBT之特徵，見圖六(g)。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="example" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete19.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖六(f)：。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="example" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete20.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖六(g)：。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;若要刪除黑色的node(7)，由於其&lt;code&gt;child&lt;/code&gt;之&lt;code&gt;sibling&lt;/code&gt;為黑色，且具有兩個黑色的&lt;code&gt;child&lt;/code&gt;(都是&lt;code&gt;NIL&lt;/code&gt;)，符合Case2的情況，便修正如下，見圖六(h)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;將&lt;code&gt;sibling&lt;/code&gt;塗成紅色：node(10)塗成紅色；&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;current&lt;/code&gt;移至&lt;code&gt;currnet&lt;/code&gt;的&lt;code&gt;parent&lt;/code&gt;：&lt;code&gt;current&lt;/code&gt;移至node(9)；&lt;/li&gt;
&lt;li&gt;若新的&lt;code&gt;current&lt;/code&gt;node(9)為紅色，即跳出迴圈，並將&lt;code&gt;current&lt;/code&gt;塗黑。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;經修正後，便符合RBT之特徵，見圖六(i)。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="example" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete21.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖六(h)：。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="example" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete22.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖六(i)：。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;最後，若要刪除黑色的node(3)呢？由於node(3)的&lt;code&gt;child&lt;/code&gt;node(1)為紅色，並不需要考慮到Case1(&lt;code&gt;sibling&lt;/code&gt;為紅色)，只要將node(1)塗黑即可，如圖六(j)。  &lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="example" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete23.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖六(j)：。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="code"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;程式碼&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;DeleteFixedUpRBT()&lt;/code&gt;之範例程式碼分成以下幾個部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如圖四所示，修正的過程可能經歷不止一個Case，因此利用&lt;code&gt;while&lt;/code&gt;來實現，條件式為：&lt;code&gt;current&lt;/code&gt;不是&lt;code&gt;root&lt;/code&gt;，而且&lt;code&gt;current&lt;/code&gt;為黑色；&lt;/li&gt;
&lt;li&gt;若&lt;code&gt;current&lt;/code&gt;是其&lt;code&gt;parent&lt;/code&gt;之&lt;code&gt;leftchild&lt;/code&gt;，其&lt;code&gt;sibling&lt;/code&gt;就必須是&lt;code&gt;rightchild&lt;/code&gt;，反之亦然，而兩種情形之&lt;code&gt;Rotation&lt;/code&gt;修正之方向正好相反，因此，如同&lt;code&gt;InsertFixedUpRBT()&lt;/code&gt;，必須區分出「&lt;code&gt;current&lt;/code&gt;是其&lt;code&gt;parent&lt;/code&gt;之&lt;code&gt;leftchild&lt;/code&gt;」與「&lt;code&gt;current&lt;/code&gt;是其&lt;code&gt;parent&lt;/code&gt;之&lt;code&gt;rightchild&lt;/code&gt;」兩種情況；&lt;/li&gt;
&lt;li&gt;分別進行Case1、Case2、Case3與Case4之修正；&lt;/li&gt;
&lt;li&gt;最後，在line74的&lt;code&gt;current-&amp;gt;color = 1&lt;/code&gt;將&lt;code&gt;current&lt;/code&gt;之顏色塗黑，有可能在Case2用上，見圖五(d)與圖六(h)。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;RBT&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;DeleteFixedUpRBT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="c1"&gt;// Case0:(i)  current是紅色的, 不影響黑色在path上的數量&lt;/span&gt;
    &lt;span class="c1"&gt;//       (ii) current是root,&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;// current是leftchild&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;    
            &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;sibling&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="c1"&gt;// Case1: 如果sibling是紅色&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sibling&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;sibling&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;LeftRotation&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                &lt;span class="n"&gt;sibling&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
            &lt;span class="c1"&gt;// 進入 Case2、3、4: sibling是黑色&lt;/span&gt;
            &lt;span class="c1"&gt;// Case2: sibling的兩個child都是黑色&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sibling&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;sibling&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;sibling&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
            &lt;span class="c1"&gt;// Case3 &amp;amp; 4:&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;// case3: sibling的right child是黑的, 不管left child, 因為馬上會被塗黑&lt;/span&gt;
                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sibling&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
                    &lt;span class="n"&gt;sibling&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                    &lt;span class="n"&gt;sibling&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                    &lt;span class="n"&gt;RightRotation&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sibling&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                    &lt;span class="n"&gt;sibling&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="p"&gt;}&lt;/span&gt;
                &lt;span class="c1"&gt;// 經過Case3後, 一定會變成Case4&lt;/span&gt;
                &lt;span class="c1"&gt;// Case 4: sibling的right child 是紅色的&lt;/span&gt;
                &lt;span class="n"&gt;sibling&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;sibling&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;LeftRotation&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;     &lt;span class="c1"&gt;// 只要進到Case4後, 一定跳出回圈&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;

        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="c1"&gt;// current是rightchild&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;  
            &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;sibling&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="c1"&gt;// Case1: 如果sibling是紅色&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sibling&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;sibling&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;RightRotation&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                &lt;span class="n"&gt;sibling&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
            &lt;span class="c1"&gt;// 進入 Case2、3、4: sibling是黑色&lt;/span&gt;
            &lt;span class="c1"&gt;// Case2: sibling的兩個child都是黑色&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sibling&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;sibling&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;sibling&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
            &lt;span class="c1"&gt;// Case3 &amp;amp; 4:&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;// case3: sibling的left child是黑的, 不管right child, 因為馬上會被塗黑&lt;/span&gt;
                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sibling&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
                    &lt;span class="n"&gt;sibling&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                    &lt;span class="n"&gt;sibling&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                    &lt;span class="n"&gt;LeftRotation&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sibling&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                    &lt;span class="n"&gt;sibling&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="p"&gt;}&lt;/span&gt;
                &lt;span class="c1"&gt;// 經過Case3後, 一定會變成Case4&lt;/span&gt;
                &lt;span class="c1"&gt;// Case 4: sibling的right child 是紅色的&lt;/span&gt;
                &lt;span class="n"&gt;sibling&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;sibling&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;RightRotation&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;     &lt;span class="c1"&gt;// 只要進到Case4後, 一定跳出回圈&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a name="ref"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;參考資料：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844"&gt;Introduction to Algorithms&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376"&gt;Fundamentals of Data Structures in C++&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://code.geeksforgeeks.org/NtLnIk"&gt;GeeksforGeeks：Red Black Tree&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="tree_series"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Tree系列文章&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/treeshu-introjian-jie.html"&gt;Tree(樹): Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-introjian-jie.html"&gt;Binary Tree: Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-traversalxun-fang.html"&gt;Binary Tree: Traversal(尋訪)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-jian-li-yi-ke-binary-tree.html"&gt;Binary Tree: 建立一棵Binary Tree&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-introjian-jie.html"&gt;Binary Search Tree: Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-searchsou-xun-zi-liao-insertxin-zeng-zi-liao.html"&gt;Binary Search Tree: Search(搜尋資料)、Insert(新增資料)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-sortpai-xu-deleteshan-chu-zi-liao.html"&gt;Binary Search Tree: Sort(排序)、Delete(刪除資料)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-introjian-jie.html"&gt;Red Black Tree: Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-rotationxuan-zhuan.html"&gt;Red Black Tree: Rotation(旋轉)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-insertxin-zeng-zi-liao-yu-fixupxiu-zheng.html"&gt;Red Black Tree: Insert(新增資料)與Fixup(修正)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-deleteshan-chu-zi-liao-yu-fixupxiu-zheng.html"&gt;Red Black Tree: Delete(刪除資料)與Fixup(修正)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="C++"></category><category term="Red Black Tree"></category></entry><entry><title>Red Black Tree: Insert(新增資料)與Fixup(修正)</title><link href="http://alrightchiu.github.io/SecondRound/red-black-tree-insertxin-zeng-zi-liao-yu-fixupxiu-zheng.html" rel="alternate"></link><updated>2016-01-27T20:09:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2016-01-27:SecondRound/red-black-tree-insertxin-zeng-zi-liao-yu-fixupxiu-zheng.html</id><summary type="html">&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;先備知識與注意事項*&lt;/h3&gt;
&lt;p&gt;RBT也是一棵BST，而RBT之Insert(新增資料)方法便是先沿用&lt;code&gt;InsertBST()&lt;/code&gt;，再對顏色進行修正。而修正的方法將用上&lt;code&gt;Rotation()&lt;/code&gt;，因此，建議在閱讀本篇文章之前，先熟悉&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-searchsou-xun-zi-liao-insertxin-zeng-zi-liao.html"&gt;Binary Search Tree: Search(搜尋資料)、Insert(新增資料)&lt;/a&gt;與&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-rotationxuan-zhuan.html"&gt;Red Black Tree: Rotation(旋轉)&lt;/a&gt;會很有幫助。 &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#bst"&gt;如同於BST中Insert(新增資料)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#fixup"&gt;修正：InsertFixUpRBT()&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#case1"&gt;Case1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#case3"&gt;Case3&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#case2"&gt;Case2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#example"&gt;幾個範例&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#code"&gt;程式碼&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#ref"&gt;參考資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#tree_series"&gt;Tree系列文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="bst"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;如同於BST中Insert(新增資料)&lt;/h2&gt;
&lt;p&gt;RBT也是一棵BST，在Insert(新增資料)時，必須滿足：&lt;span class="math"&gt;\(Key(L)&amp;lt;Key(Current)&amp;lt;Key(R)\)&lt;/span&gt;，因此，RBT的&lt;code&gt;InsertRBT()&lt;/code&gt;前半部演算法與&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-searchsou-xun-zi-liao-insertxin-zeng-zi-liao.html#insert"&gt;BST的函式：InsertBST()大同小異&lt;/a&gt;。&lt;br /&gt;
需要修改/擴充的部分有三處：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;NIL&lt;/code&gt;：所有原先在BST中指向&lt;code&gt;NULL&lt;/code&gt;的pointer，在RBT中需要修正成指向&lt;code&gt;NIL&lt;/code&gt;，包括條件式與新增node的&lt;code&gt;child pointer&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;顏色：如同在&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-rotationxuan-zhuan.html#fail"&gt;RBT：Rotation(旋轉)&lt;/a&gt;所說，一般預設新增node為紅色，因此，若新增node接在黑色node之後，仍能滿足RBT的特徵，但是若新增node接在紅色node之後，則違反了&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-introjian-jie.html#rbt"&gt;RBT之第四點特徵&lt;/a&gt;，必須進行修正。&lt;/li&gt;
&lt;li&gt;引進函式：&lt;code&gt;InsertFixedUpRBT()&lt;/code&gt;進行修正。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;InsertRBT()&lt;/code&gt;的程式範例如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;RBT&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;InsertRBT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="c1"&gt;// 前半部與 InsertBST()之邏輯完全相同, 僅僅需要修改 NULL &amp;lt;-&amp;gt; NIL&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;neel&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;insert_node&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// default copy constructor&lt;/span&gt;

    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;neel&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;     &lt;span class="c1"&gt;// 把root初始化成neel, 這裡就可以用neel來做判斷&lt;/span&gt;
        &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;insert_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;GetKey&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;GetKey&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
            &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;
            &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;insert_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;neel&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;insert_node&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;insert_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;GetKey&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;GetKey&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
        &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;insert_node&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
        &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;insert_node&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;// 以下是對RBT之node的設定, 將child pointer指向NIL, 顏色設為紅色&lt;/span&gt;
    &lt;span class="n"&gt;insert_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;neel&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;insert_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;neel&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;insert_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;             &lt;span class="c1"&gt;// 顏色可以在constructor中預設&lt;/span&gt;

    &lt;span class="n"&gt;InsertFixedUpRBT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;insert_node&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;      &lt;span class="c1"&gt;// 對可能出現紅色與紅色node相連之情形做修正&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="fixup"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;修正：InsertFixUpRBT()&lt;/h2&gt;
&lt;p&gt;什麼情況需要對&lt;code&gt;InsertRBT()&lt;/code&gt;做修正？&lt;br /&gt;
當新增node接在紅色的node的&lt;code&gt;child pointer&lt;/code&gt;，形成紅色與紅色相連時。&lt;/p&gt;
&lt;p&gt;考慮以下情況，如圖一(a)，新增的node將要接在node(X)上：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;node(X)為其&lt;code&gt;parent&lt;/code&gt;，顏色為紅色；&lt;/li&gt;
&lt;li&gt;node(Y)為其&lt;code&gt;uncle&lt;/code&gt;，其顏色&lt;strong&gt;可能為紅色或黑色&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;node(Z)為其grandparent(&lt;code&gt;parent-&amp;gt;parent&lt;/code&gt;)，顏色必定為黑色；&lt;/li&gt;
&lt;li&gt;node(W)的顏色&lt;strong&gt;可能是紅色或黑色&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;所有灰色node(如node(a)、node(b)、node(c)、node(d))表示：只要不影響RBT之特徵，是否實際攜帶資料或為&lt;code&gt;NIL&lt;/code&gt;並不影響結果。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Insert/insert1.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(a)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;根據&lt;code&gt;uncle&lt;/code&gt;的顏色是紅色或者黑色，可以將修正(FixUp)分成三種情形(case)：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Case1：&lt;code&gt;uncle&lt;/code&gt;是紅色，不論新增的node是node(X)的&lt;code&gt;leftchild&lt;/code&gt;或&lt;code&gt;rightchild&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;Case2：&lt;code&gt;uncle&lt;/code&gt;是黑色，而且新增的node為node(X)的&lt;code&gt;rightchild&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;Case3：&lt;code&gt;uncle&lt;/code&gt;是黑色，而且新增的node為node(X)的&lt;code&gt;leftchild&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a name="case1"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Case1&lt;/h3&gt;
&lt;p&gt;圖一(b)左，此時&lt;code&gt;current&lt;/code&gt;指向新增的node(A)，而node(A)成為node(X)的&lt;code&gt;rightchild&lt;/code&gt;，其&lt;code&gt;uncle&lt;/code&gt;node(Y)是紅色的。&lt;br /&gt;
修正的方法就是「把債還給上一代的上一代」：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;將&lt;code&gt;parent&lt;/code&gt;塗成黑色：node(X)塗成黑色；&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;uncle&lt;/code&gt;塗成黑色：node(Y)塗成黑色；&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;parent-&amp;gt;parent&lt;/code&gt;塗成紅色：node(Z)塗成紅色：&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;current&lt;/code&gt;從node(A)移到node(Z)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此時，如圖一(b)右，從node(Z)出發往其descendant leaves的任一path上之黑色node數皆相同，這個subtree便滿足了RBT的特徵。  &lt;/p&gt;
&lt;p&gt;接著必需根據node(W)的顏色採取不同行動：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若node(W)為黑色，就不需要再做調整；&lt;/li&gt;
&lt;li&gt;若node(W)為紅色，則node(Z)與node(W)再次形成紅色node與紅色node相連，必須重複同樣的判斷流程。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Insert/insert2.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(b)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;若node(A)成為node(X)的&lt;code&gt;leftchild&lt;/code&gt;，如圖一(c)，修正的方法同上。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Insert/insert3.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(c)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="case3"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Case3&lt;/h3&gt;
&lt;p&gt;圖一(d)，新增的node(A)成為node(X)的&lt;code&gt;leftchild&lt;/code&gt;，其&lt;code&gt;uncle&lt;/code&gt;node(Y)是黑色。 &lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Insert/insert4.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(d)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;事實上，若&lt;code&gt;current&lt;/code&gt;指向之node(此為node(A))是新增的node，則根據RBT之第五點特徵，其&lt;code&gt;uncle&lt;/code&gt;node(Y)必定是&lt;code&gt;NIL&lt;/code&gt;，如圖一(e)左。&lt;/p&gt;
&lt;p&gt;不過，在稍後的範例中將會看到，&lt;code&gt;current&lt;/code&gt;不一定是「剛剛新增的node」，也有可能是「修正到一半，出現紅色與紅色相連的node」，但因為是「修正到一半」，尚未調整node(Z)的顏色，因此所有從node(Z)往其descendant leaves的任意path上之黑色node數必定不變，此時，若node(Y)不為&lt;code&gt;NIL&lt;/code&gt;，則node(X)以及node(A)必定還有黑色的&lt;code&gt;child pointer&lt;/code&gt;，如圖一(e)右所示，node(a)、node(b)與node(c)皆為黑色。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Insert/insert5.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(e)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;修正方法如下，見圖一(f)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;將&lt;code&gt;parent&lt;/code&gt;塗成黑色：node(X)塗成黑色；&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;parent-&amp;gt;parent&lt;/code&gt;塗成紅色：node(Z)塗成紅色；&lt;/li&gt;
&lt;li&gt;對&lt;code&gt;parent-&amp;gt;parent&lt;/code&gt;node(Z)進行&lt;strong&gt;Right Rotation(向右旋轉)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Insert/insert6.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(f)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;經過&lt;strong&gt;Case3&lt;/strong&gt;的修正，必定會滿足RBT之規則，原因在於：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先考慮圖一(e)，若從node(A)往其descendant leaves的任意path上之黑色node數為&lt;span class="math"&gt;\(M\)&lt;/span&gt;，則從node(Z)往其descendant leaves的任意path上之黑色node數為&lt;span class="math"&gt;\(M+1\)&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;再看圖一(g)，因為在修正的過程中，node(Z)從黑色被修改成紅色，因此從node(Z)往其descendant leaves的任意path上之黑色node數下修為&lt;span class="math"&gt;\(M\)&lt;/span&gt;，與node(A)相同，使得整棵樹滿足RBT之特徵。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Insert/insert7.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(g)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="case2"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Case2&lt;/h3&gt;
&lt;p&gt;圖一(h)，新增的node(A)成為node(X)的&lt;code&gt;rightchild&lt;/code&gt;，其&lt;code&gt;uncle&lt;/code&gt;node(Y)是黑色。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Insert/insert8.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(h)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;如同Case3，圖一(h)的&lt;code&gt;uncle&lt;/code&gt;node(Y)同樣有兩種可能：攜帶實際資料的黑色node，或者&lt;code&gt;NIL&lt;/code&gt;，如圖一(i)：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Insert/insert9.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(i)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;而修正Case2的方法就是將其轉換成Case3，再利用上述Case3的方法調整成正確的RBT。&lt;br /&gt;
從Case2調整成Case3，如圖一(j)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;將&lt;code&gt;current&lt;/code&gt;移至&lt;code&gt;current-&amp;gt;parent&lt;/code&gt;：將&lt;code&gt;current&lt;/code&gt;從node(A)移到node(X)；&lt;/li&gt;
&lt;li&gt;對新的&lt;code&gt;current&lt;/code&gt;進行Left Rotation：對node(X)進行Left Rotation。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;圖一(j)右符合Case3：「&lt;code&gt;current&lt;/code&gt;成為其&lt;code&gt;parent&lt;/code&gt;的&lt;code&gt;leftchild&lt;/code&gt;，且其&lt;code&gt;uncle&lt;/code&gt;node(Y)是黑色」，因此，只要再進行如同圖一(f)之修正流程即可。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Insert/insert10.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(j)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="example"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;幾個範例&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Example1&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;考慮一棵RBT如圖二(a)：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Insert/insert11.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(a)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;若想新增node(75)，由於其將接在node(80)的&lt;code&gt;leftchild&lt;/code&gt;位置上，而node(80)為紅色，因此需要進行修正。&lt;br /&gt;
接著觀察，node(75)之&lt;code&gt;uncle&lt;/code&gt;為node(60)，同樣是紅色，因此可以使用Case1的方法，如圖二(b)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;將&lt;code&gt;parent&lt;/code&gt;與&lt;code&gt;uncle&lt;/code&gt;塗黑：node(80)與node(60)塗黑；&lt;/li&gt;
&lt;li&gt;將grandparent塗紅：node(70)塗紅；&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;current&lt;/code&gt;移至node(70)；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;進入下一個迴圈&lt;/strong&gt;判斷node(70)是否與其&lt;code&gt;parent&lt;/code&gt;形成紅色與紅色node相連。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;恰好，node(50)為&lt;code&gt;root&lt;/code&gt;，一定是黑色，因此新增node(75)便算是完成。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Insert/insert12.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(b)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;若想繼續新增node(25)，由於其將接在node(30)的&lt;code&gt;leftchild&lt;/code&gt;，而node(30)為紅色，因此需要修正。&lt;br /&gt;
接著觀察，node(25)之&lt;code&gt;uncle&lt;/code&gt;為&lt;code&gt;NIL&lt;/code&gt;是黑色，而node(25)本身是&lt;code&gt;leftchild&lt;/code&gt;，因此可以使用Case3的方法，如圖二(c)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;將&lt;code&gt;parent&lt;/code&gt;塗成黑色：node(30)塗成黑色；&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;parent-&amp;gt;parent&lt;/code&gt;塗成紅色：node(40)塗成紅色；&lt;/li&gt;
&lt;li&gt;對&lt;code&gt;parent-&amp;gt;parent&lt;/code&gt;node(40)進行&lt;strong&gt;Right Rotation(向右旋轉)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Insert/insert13.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(c)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;若想繼續新增node(79)，由於其將接在node(75)的&lt;code&gt;rightchild&lt;/code&gt;，而node(75)為紅色，因此需要修正。&lt;br /&gt;
接著觀察，node(79)之&lt;code&gt;uncle&lt;/code&gt;為&lt;code&gt;NIL&lt;/code&gt;是黑色，而node(79)本身是&lt;code&gt;rightchild&lt;/code&gt;，因此可以使用Case2的方法，先將問題從Case2轉換成Case3，再由Case3之方法修正，如圖二(d)：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Insert/insert14.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(d)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example2&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;考慮一棵RBT如圖三(a)：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Insert/insert15.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(a)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;要在其中新增node(4)，則會依序經歷case1、case2直到case3完成修正，如圖三(b)、圖三(c)、圖三(d)與圖三(e)所示。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Insert/insert16.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(b)：。&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt;&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Insert/insert17.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(c)：。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Insert/insert18.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(d)：。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Insert/insert19.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(e)：。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;根據以上說明，可以歸納出對於&lt;code&gt;InsertRBT()&lt;/code&gt;的修正(Fix-Up)之情形(Case)間的循環圖，如圖四：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;當新增node之&lt;code&gt;parent&lt;/code&gt;為紅色時，需要對RBT進行修正；&lt;/li&gt;
&lt;li&gt;若進入Case1，有可能執行一次即完成，也有可能再次出現紅色與紅色相連的情況，如圖三(b)-(c)；&lt;/li&gt;
&lt;li&gt;若進入Case2，就轉換成Case3的情境；&lt;/li&gt;
&lt;li&gt;一旦進入Case3，經過修正後必定能滿足RBT之特徵限制。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Insert/insert20.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;最後還有一點需要說明。&lt;/p&gt;
&lt;p&gt;圖五中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;左圖是本篇文章介紹修正(Fix-Up)的出發點：將新增的node接在node(X)上，而node(X)是node(Z)的&lt;code&gt;leftchild&lt;/code&gt;(&lt;code&gt;parent&lt;/code&gt;是&lt;code&gt;parent-&amp;gt;parent&lt;/code&gt;的&lt;code&gt;leftchild&lt;/code&gt;)；&lt;/li&gt;
&lt;li&gt;還有另外一半的情況就如圖五之右圖：將新增的node接在node(Y)上，而node(Y)是node(Z)的&lt;code&gt;rightchild&lt;/code&gt;(&lt;code&gt;parent&lt;/code&gt;是&lt;code&gt;parent-&amp;gt;parent&lt;/code&gt;的&lt;code&gt;rightchild&lt;/code&gt;)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Insert/insert21.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;必須要區分這兩者的原因有二：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一是&lt;code&gt;uncle&lt;/code&gt;：因為&lt;code&gt;parent&lt;/code&gt;與&lt;code&gt;uncle&lt;/code&gt;分別為&lt;code&gt;parent-&amp;gt;parent&lt;/code&gt;之&lt;code&gt;leftchild&lt;/code&gt;與&lt;code&gt;rightchild&lt;/code&gt;，若&lt;code&gt;parent&lt;/code&gt;是&lt;code&gt;left-&lt;/code&gt;，&lt;code&gt;uncle&lt;/code&gt;就要是&lt;code&gt;right-&lt;/code&gt;，反之亦然，兩者屬於互斥(exclusive)的、不能同時發生的情境；&lt;/li&gt;
&lt;li&gt;二是Rotation(旋轉)：在Case2與Case3中必須使用Left/Right Rotation，因此，延續第一點原因，考慮到&lt;code&gt;parent&lt;/code&gt;是&lt;code&gt;leftchild&lt;/code&gt;或是&lt;code&gt;rightchild&lt;/code&gt;的不同，Left/Right Rotation的方向也會相反。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="code"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;程式碼&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;InsertFixedUpRBT()&lt;/code&gt;之範例程式碼分成以下幾個部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定義&lt;code&gt;color&lt;/code&gt;：0為紅色，1為黑色；&lt;/li&gt;
&lt;li&gt;如同圖四所示，修正的過程可能歷經不止一個Case，因此利用&lt;code&gt;while&lt;/code&gt;迴圈實現，條件式便是判斷當前&lt;code&gt;current&lt;/code&gt;之&lt;code&gt;parent&lt;/code&gt;是否為紅色；&lt;/li&gt;
&lt;li&gt;分別進行Case1(圖一(b)與圖一(c))、Case2(圖一(j))與Case3(圖一(f))之修正；&lt;/li&gt;
&lt;li&gt;最後，在&lt;strong&gt;line50&lt;/strong&gt;出現一行&lt;code&gt;root-&amp;gt;color=1&lt;/code&gt;，將&lt;code&gt;root&lt;/code&gt;之顏色塗黑，這是為了Case1所設，由於Case1之修正方法是把「紅色與紅色node相連」之可能性往&lt;code&gt;root&lt;/code&gt;方向傳遞，有可能&lt;code&gt;root&lt;/code&gt;恰好是&lt;code&gt;current&lt;/code&gt;的grandparent而被塗成紅色，如圖六，但因為RBT之第二點特徵要求&lt;code&gt;root&lt;/code&gt;一定是黑色，因此必須作此預防。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Insert/insert22.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖六：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;RBT&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;InsertFixedUpRBT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="c1"&gt;// Case0: parent是黑色, 就不用進迴圈&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;   &lt;span class="c1"&gt;// 若parent是紅色即進入迴圈&lt;/span&gt;
        &lt;span class="c1"&gt;// 上半部：parent為grandparent的leftchild之情況，如圖五左&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; 
            &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;uncle&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="c1"&gt;// 若uncle是紅色：Case1&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;uncle&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;uncle&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//grandparent改成紅色&lt;/span&gt;
                &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
            &lt;span class="c1"&gt;// 若uncle是黑色：Case2 or Case3&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="c1"&gt;// 若current是rightchild：Case2  &lt;/span&gt;
                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;        
                    &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                    &lt;span class="n"&gt;LeftRotation&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                &lt;span class="p"&gt;}&lt;/span&gt;
                &lt;span class="c1"&gt;// 若current是leftchild：Case3&lt;/span&gt;
                &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;     
                &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;     
                &lt;span class="n"&gt;RightRotation&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="c1"&gt;// 下半部：parent為grandparent的rightchild之情況，如圖五右&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;  
            &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;uncle&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="c1"&gt;// 若uncle是紅色：Case1&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;uncle&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;uncle&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//grandparent改成紅色&lt;/span&gt;
                &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
            &lt;span class="c1"&gt;// 若uncle是黑色：Case2 or Case3&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                    &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                    &lt;span class="n"&gt;RightRotation&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                &lt;span class="p"&gt;}&lt;/span&gt;
                &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;LeftRotation&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a name="ref"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;參考資料：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844"&gt;Introduction to Algorithms, Ch13&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376"&gt;Fundamentals of Data Structures in C++&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://code.geeksforgeeks.org/NtLnIk"&gt;GeeksforGeeks：Red Black Tree&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="tree_series"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Tree系列文章&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/treeshu-introjian-jie.html"&gt;Tree(樹): Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-introjian-jie.html"&gt;Binary Tree: Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-traversalxun-fang.html"&gt;Binary Tree: Traversal(尋訪)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-jian-li-yi-ke-binary-tree.html"&gt;Binary Tree: 建立一棵Binary Tree&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-introjian-jie.html"&gt;Binary Search Tree: Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-searchsou-xun-zi-liao-insertxin-zeng-zi-liao.html"&gt;Binary Search Tree: Search(搜尋資料)、Insert(新增資料)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-sortpai-xu-deleteshan-chu-zi-liao.html"&gt;Binary Search Tree: Sort(排序)、Delete(刪除資料)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-introjian-jie.html"&gt;Red Black Tree: Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-rotationxuan-zhuan.html"&gt;Red Black Tree: Rotation(旋轉)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-insertxin-zeng-zi-liao-yu-fixupxiu-zheng.html"&gt;Red Black Tree: Insert(新增資料)與Fixup(修正)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-deleteshan-chu-zi-liao-yu-fixupxiu-zheng.html"&gt;Red Black Tree: Delete(刪除資料)與Fixup(修正)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="C++"></category><category term="Red Black Tree"></category></entry><entry><title>Red Black Tree: Rotation(旋轉)</title><link href="http://alrightchiu.github.io/SecondRound/red-black-tree-rotationxuan-zhuan.html" rel="alternate"></link><updated>2016-01-24T23:06:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2016-01-24:SecondRound/red-black-tree-rotationxuan-zhuan.html</id><summary type="html">&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;先備知識與注意事項&lt;/h3&gt;
&lt;p&gt;雖說是Rotation(旋轉)，但其實沒有這麼神奇，只是視覺上看起來像旋轉，在電腦實際將讀取的程式碼實現上，僅僅是數個pointer之指向的重新改寫，所以千萬別害怕。&lt;/p&gt;
&lt;p&gt;本篇文章的第一部分將以Insert(新增資料)與Delete(刪除資料)來說明為什麼需要Rotation(旋轉)，但是讀者可以先不必理會細節，因為實際上的Insert與Delete將有更多情況必須考慮，此部分將留待後續文章逐項說明，在本篇文章只要掌握Rotation(旋轉)即可。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#fail"&gt;於RBT中進行Insert與Delete後竟然不符合RBT&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#rotation"&gt;Rotation(旋轉)&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#left-rotate"&gt;Left Rotation(向左轉)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#right-rotate"&gt;Right Rotation(向右轉)&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#ref"&gt;參考資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#tree_series"&gt;Tree系列文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="fail"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;於RBT中進行Insert與Delete後竟然不符合RBT&lt;/h2&gt;
&lt;p&gt;現考慮如圖一(a)之RBT，欲進行Insert(新增資料)與Delete(刪除資料)：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="rotation" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Rotation/rotate0.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(a)：一棵符合規則的RBT。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;為滿足RBT之特徵第五點：從&lt;code&gt;root&lt;/code&gt;走向任何一個leaf node(&lt;code&gt;NIL&lt;/code&gt;)的任何一條path上之黑色node數皆相同，一般在RBT中Insert(新增資料)時，會先將欲新增的node塗成紅色。&lt;br /&gt;
若幸運地，新增的node接在黑色node上，則RBT仍然是一棵RBT，如圖一(b)，新增node(15)。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="rotation" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Rotation/rotate1.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(b)：在RBT中新增node(15)，新增完後仍然滿足RBT之規則。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;但是，若要在RBT中新增node(31)，因為node(34)是紅色，此處便會出現紅色與紅色相連的情況，違反RBT之第四點特徵，因此需要修正，如圖一(c)。  &lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="rotation" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Rotation/rotate2.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(c)：在RBT中新增node(31)，新增完後無法滿足RBT之規則。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;修正的方法便是將node(35)塗成紅色，node(34)塗成黑色，並且對&lt;strong&gt;node(35)&lt;/strong&gt;進行&lt;strong&gt;Right Rotation(向右旋轉)&lt;/strong&gt;，如此一來，RBT便能維持其基本特徵。&lt;br /&gt;
值得注意的是，在執行Rotation時，有時會順便調整RBT的height(樹高)，使得RBT維持在平衡(balanced)的狀態。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="rotation" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Rotation/rotate3.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(d)：使用&lt;/strong&gt;Rotation&lt;strong&gt;對Insert(新增資料)進行修正。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;在正確新增node(31)後，若要刪除node(20)，因為node(20)是黑色，若將其刪除則違反RBT之第五點特徵：從&lt;code&gt;root&lt;/code&gt;走向任何一個leaf node(&lt;code&gt;NIL&lt;/code&gt;)的任何一條path上之黑色node數皆相同，因此同樣需要進行修正。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="rotation" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Rotation/rotate4.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(e)：因為node(20)是黑色，若將其刪除會違反RBT之第五點特徵。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;修正的方法則是將node(30)塗黑，node(34)塗紅，然後對&lt;strong&gt;node(34)&lt;/strong&gt;進行&lt;strong&gt;Left Rotation(向左旋轉)&lt;/strong&gt;，如此一來，RBT便能維持其基本特徵。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="rotation" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Rotation/rotate5.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(f)：使用&lt;/strong&gt;Rotation&lt;strong&gt;對Delete(刪除資料)進行修正。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;經過以上說明，應該能體會到Rotation在修正Insert(新增資料)與Delete(刪除資料)時的威力，接著便來實地走訪Rotation實際上是哪些pointer在指來指去。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="rotation"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Rotation(旋轉)&lt;/h2&gt;
&lt;p&gt;在說明Rotation(旋轉)之前有兩點需要先申明：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;若是要應用在BST上，則Rotation(旋轉)前後的BST必須要維持相同之Key排序。此處介紹的Rotation(旋轉)便屬於此類。&lt;/li&gt;
&lt;li&gt;Rotation(旋轉)與node是否具有顏色無關，即使是在一般的BST，亦能夠使用Rotation(旋轉)來調整height(樹高)。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a name="left-rotate"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Left Roration(向左旋轉)&lt;/h3&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="rotation" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Rotation/rotate6.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(a)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;從圖二(a)中可以看出，要對以node(X)為&lt;code&gt;root&lt;/code&gt;之subtree進行Left Rotation，必須調整的pointer分別長在node(X)、node(Y)、node(A)與node(j)身上，其中node(j)有可能為&lt;code&gt;NIL&lt;/code&gt;，不過為求完整，在此將以node(j)不為&lt;code&gt;NIL&lt;/code&gt;作說明。&lt;br /&gt;
另外，node(i)與node(k)是否為&lt;code&gt;NIL&lt;/code&gt;皆不影響Left Rotation。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="rotation" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Rotation/rotate7.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(b)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;圖二(b)將所有可能需要更動的pointer列出，其中，藍色箭頭表示由&lt;code&gt;parent pointer&lt;/code&gt;指向&lt;code&gt;child pointer&lt;/code&gt;，紅色箭頭則為&lt;code&gt;child pointer&lt;/code&gt;指向&lt;code&gt;parent pointer&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;Left Roration(向左旋轉)之步驟如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在Left Rotation完成後，node(Y)的&lt;code&gt;leftchild&lt;/code&gt;將會接上node(X)，因此要先把原先node(Y)的&lt;code&gt;leftchild&lt;/code&gt;(也就是node(j))放到node(X)的&lt;code&gt;rightchild&lt;/code&gt;：&lt;ul&gt;
&lt;li&gt;圖二(c)左：將node(X)的&lt;code&gt;rightchild&lt;/code&gt;指向node(j)；&lt;/li&gt;
&lt;li&gt;圖二(c)右：將node(j)的&lt;code&gt;parent&lt;/code&gt;指向node(X)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="rotation" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Rotation/rotate8.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(c)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Left Rotation完成後，node(X)的&lt;code&gt;parent&lt;/code&gt;將會是node(Y)，而node(Y)的&lt;code&gt;parent&lt;/code&gt;要改成原先node(X)的&lt;code&gt;parent&lt;/code&gt;(也就是node(A))：&lt;ul&gt;
&lt;li&gt;圖二(d)左：將node(Y)的&lt;code&gt;parent&lt;/code&gt;指向node(A)。&lt;/li&gt;
&lt;li&gt;圖二(d)右：接著判斷，若原先node(X)是node(A)的&lt;code&gt;leftchild&lt;/code&gt;，那麼node(Y)同樣是node(A)的&lt;code&gt;leftchild&lt;/code&gt;，反之，node(Y)則成為node(A)的&lt;code&gt;rightchild&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="rotation" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Rotation/rotate9.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(d)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最後，只要再把node(Y)的&lt;code&gt;rightchild&lt;/code&gt;指向node(X)，如圖二(e)左，並把node(X)的&lt;code&gt;parent&lt;/code&gt;接上node(Y)，如圖二(e)右，Left Rotation便完成了。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="rotation" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Rotation/rotate10.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(e)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;最後再看一次圖二(a)，若忽略node(A)，左圖中，其餘node之Key順序為&lt;span class="math"&gt;\(i&amp;lt;X&amp;lt;j&amp;lt;Y&amp;lt;k\)&lt;/span&gt;，而右圖中的順序亦為&lt;span class="math"&gt;\(i&amp;lt;X&amp;lt;j&amp;lt;Y&amp;lt;k\)&lt;/span&gt;，因此，如上所述的Left Rotation能夠應用在BST上。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="rotation" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Rotation/rotate6.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(a)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;Left Rotation之程式範例如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;RBT&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;LeftRotation&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;              &lt;span class="c1"&gt;// 把y設成x的rightchild&lt;/span&gt;

    &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="c1"&gt;// 圖二(c)左&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;neel&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;       &lt;span class="c1"&gt;// 圖二(c)右, 若node(j)為NIL則忽略&lt;/span&gt;
        &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;          &lt;span class="c1"&gt;// 圖二(d)左&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;neel&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;          &lt;span class="c1"&gt;// 圖二(d)右&lt;/span&gt;
        &lt;span class="n"&gt;root&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                   
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
        &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;               &lt;span class="c1"&gt;// 圖二(e)左&lt;/span&gt;
    &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                  &lt;span class="c1"&gt;// 圖二(e)右&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;a name="right-rotate"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Right Roration(向左旋轉)&lt;/h3&gt;
&lt;p&gt;Right Rotation的邏輯與Left Rotation完全相同，只要確實地把與node(X)、node(Y)、node(A)與node(j)有關的pointer重新指向正確的記憶體位置，就能夠完成Right Rotation。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="rotation" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Rotation/rotate11.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;Right Rotation之程式範例如下，把所有&lt;code&gt;LeftRotation()&lt;/code&gt;中的&lt;code&gt;left-&lt;/code&gt;與&lt;code&gt;right-&lt;/code&gt;對調就是了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;RBT&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;RightRotation&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;

    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;               &lt;span class="c1"&gt;// 把x設成y的leftchild&lt;/span&gt;

    &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="c1"&gt;// 把x的rightchild放到y的leftchild    &lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;neel&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;      &lt;span class="c1"&gt;// 若x的rightchild不為NIL, 將其parent指向y&lt;/span&gt;
        &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;          &lt;span class="c1"&gt;// 將x的parent指向原先y的parent&lt;/span&gt;
                                    &lt;span class="c1"&gt;// 以下一組if-else將修改原先y的parent之child&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;neel&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;               &lt;span class="c1"&gt;// 若y原先是root, x將成為新的root&lt;/span&gt;
        &lt;span class="n"&gt;root&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                        
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;// 若原先y是其parent之leftchild, &lt;/span&gt;
        &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;        &lt;span class="c1"&gt;//   x亦成為其新的parent之leftchild&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;                                 &lt;span class="c1"&gt;// 若原先y是其parent之rightchild, &lt;/span&gt;
        &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;       &lt;span class="c1"&gt;//   x亦成為其新的parent之rightchild&lt;/span&gt;

    &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;              &lt;span class="c1"&gt;// 將y設為x之rightchild&lt;/span&gt;
    &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                  &lt;span class="c1"&gt;// 將x設為y之parent&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;/br&gt;  &lt;/p&gt;
&lt;p&gt;以上便是Rotation(旋轉)的說明，在接下來介紹Insert(新增資料)與Delete(刪除資料)的兩篇文章中將會再次與各位相會。  &lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a name="ref"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;參考資料：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844"&gt;Introduction to Algorithms, Ch13&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376"&gt;Fundamentals of Data Structures in C++&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://code.geeksforgeeks.org/NtLnIk"&gt;GeeksforGeeks：Red Black Tree&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="tree_series"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Tree系列文章&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/treeshu-introjian-jie.html"&gt;Tree(樹): Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-introjian-jie.html"&gt;Binary Tree: Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-traversalxun-fang.html"&gt;Binary Tree: Traversal(尋訪)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-jian-li-yi-ke-binary-tree.html"&gt;Binary Tree: 建立一棵Binary Tree&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-introjian-jie.html"&gt;Binary Search Tree: Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-searchsou-xun-zi-liao-insertxin-zeng-zi-liao.html"&gt;Binary Search Tree: Search(搜尋資料)、Insert(新增資料)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-sortpai-xu-deleteshan-chu-zi-liao.html"&gt;Binary Search Tree: Sort(排序)、Delete(刪除資料)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-introjian-jie.html"&gt;Red Black Tree: Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-rotationxuan-zhuan.html"&gt;Red Black Tree: Rotation(旋轉)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-insertxin-zeng-zi-liao-yu-fixupxiu-zheng.html"&gt;Red Black Tree: Insert(新增資料)與Fixup(修正)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-deleteshan-chu-zi-liao-yu-fixupxiu-zheng.html"&gt;Red Black Tree: Delete(刪除資料)與Fixup(修正)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="C++"></category><category term="Red Black Tree"></category></entry><entry><title>Red Black Tree: Intro(簡介)</title><link href="http://alrightchiu.github.io/SecondRound/red-black-tree-introjian-jie.html" rel="alternate"></link><updated>2016-01-23T16:09:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2016-01-23:SecondRound/red-black-tree-introjian-jie.html</id><summary type="html">&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;先備知識與注意事項&lt;/h3&gt;
&lt;p&gt;在閱讀過BST系列文章後可以發現，在BST中的操作，不論是Insert(新增資料)或是Delete(刪除資料)，皆需要先做Search(搜尋)，而Search(搜尋)的效率，取決於BST的height(樹高)，如果一棵樹越矮、越平衡(balanced)，則在此BST中搜尋資料的速度較快，理想狀況為Complete Binary Tree(時間複雜度：&lt;span class="math"&gt;\(O(\log N)\)&lt;/span&gt;)。反之，若由於輸入資料的順序使得BST沒長好、偏一邊，則在此BST中搜尋資料的最壞情況將有可能如同在Linked List做搜尋(時間複雜度：&lt;span class="math"&gt;\(O(N)\)&lt;/span&gt;)。  &lt;/p&gt;
&lt;p&gt;本篇文章將介紹BST的進階版Red Black Tree(RBT，紅黑樹)之基本性質，會說是進階版，原因在於RBT其實也是BST(滿足&lt;span class="math"&gt;\(Key(L)&amp;lt;Key(Current)&amp;lt;Key(R)\)&lt;/span&gt;)，不過RBT的node比BST多加了「顏色」(紅色或黑色)，而正因為多了「顏色」，便能修正BST有可能退化成Linked list(連結串列)的潛在缺陷。 &lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="anarchy" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Intro/biasedtree.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一：不平衡的BST。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;另外，本篇文章將不進行「RBT之時間複雜度如何能視同Complete Binary Tree」之論證(筆者火侯不夠，請見諒)，建議讀者可以參考&lt;a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844"&gt;Introduction to Algorithms，第13章&lt;/a&gt;，不過結論就是，RBT可以被視為如同Complete Binary Tree的BST，所有與Search(搜尋)有關的操作(Leftmost、Successor、Insert、Delete等等)，都能夠在&lt;span class="math"&gt;\(O(\log N)\)&lt;/span&gt;內完成。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#why"&gt;為什麼需要Red Black Tree？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#rbt"&gt;Red Black Tree的特徵&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#code"&gt;程式碼&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#ref"&gt;參考資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#tree_series"&gt;Tree系列文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="why"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;為什麼需要Red Black Tree？&lt;/h2&gt;
&lt;p&gt;若考慮最壞情況，在建立BST時，輸入資料的Key恰好被排序過(例如：1、2、3、4...)，那麼這顆BST便會退化成Linked List(接續前例，所有leftchild pointer都指向&lt;code&gt;NULL&lt;/code&gt;，只有rightchild child被使用)：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;BST&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;InsertBST&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   &lt;span class="c1"&gt;// 依序加入Key為1、2、3...之資料&lt;/span&gt;
    &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;InsertBST&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;InsertBST&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;圖二中，右側的藍色數字表示「搜尋該node需要比較(&lt;code&gt;if KEY == current-&amp;gt;key&lt;/code&gt;)的次數」，也就是迴圈的次數。考慮一串Linked List共有N個node，若要尋找第K個node，則最壞情況即是一路找到最後一個node，需要N次。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="linked list" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Intro/rbt1.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二：BST退化成Linked List。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;再比較Complete Binary Tree，如圖三。其中，node裡的數字即為Key，node旁邊的藍色數字代表該node在Complete Binary Tree中的位置順序，右側的藍色數字代表迴圈次數。&lt;br /&gt;
位置順序與迴圈次數有以下關係：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在位置&lt;span class="math"&gt;\(2^3=8\)&lt;/span&gt;與&lt;span class="math"&gt;\(2^4=16\)&lt;/span&gt;之間的node(&lt;span class="math"&gt;\(2^3\leq i&amp;lt;2^4, i=8\sim 15\)&lt;/span&gt;)，只需要&lt;span class="math"&gt;\(3+1\)&lt;/span&gt;次比較(comparison)即可找到。&lt;/li&gt;
&lt;li&gt;依此類推，若BST中有N個node，則所有node保證能夠在&lt;span class="math"&gt;\(\lfloor {\log N} \rfloor +1\)&lt;/span&gt;次 (&lt;span class="math"&gt;\(2^k\leq N&amp;lt;2^{k+1}, k\leq\log N\)&lt;/span&gt;)迴圈以內找到。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cbt" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Intro/rbt2.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三：搜尋BST的理想情況：Complete Binary Tree。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;以上兩個範例為一棵具有N個node的BST之height(樹高)提供了邊界：&lt;span class="math"&gt;\(\log N\leq height\leq N\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;因此，BST越平衡，在樹中搜尋資料的時間就越短，連帶地Insert(新增資料)、Delete(刪除資料)也會變得更有效率。&lt;br /&gt;
這就是RBT值得被介紹的原因。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="rbt"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Red Black Tree的特徵&lt;/h2&gt;
&lt;p&gt;Red Black Tree(RBT)是node塗了「顏色」的Binary Search Tree(BST)，藉由控制顏色，能夠保證在RBT中，&lt;strong&gt;最長path(路徑)不會超過最短path的兩倍&lt;/strong&gt;(若最短的path是5，最長的path至多只能是10)，如此，RBT便能夠近似地視為平衡，如圖四。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="rbt" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Intro/rbt3.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四：最短的path為3(最右path:26-41-47)，其餘path最長只能是6(最左path:26-17-14-10-7-3)。&lt;br /&gt;
若蓋住&lt;code&gt;NIL&lt;/code&gt;與顏色，此即為BST。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;圖四中，所有原本在BST中指向&lt;code&gt;NULL&lt;/code&gt;的pointer，在RBT中，全部指向了&lt;code&gt;NIL&lt;/code&gt;。然而什麼是&lt;code&gt;NIL&lt;/code&gt;？&lt;code&gt;NIL&lt;/code&gt;是永遠為黑色、並且實際占有記憶體的node，因為有配置記憶體，因此能夠以&lt;code&gt;Node-&amp;gt;color&lt;/code&gt;的方式取得某個node之顏色(若使用&lt;code&gt;NULL&lt;/code&gt;則無法)，此優勢將在後續介紹如何於RBT中Insert(新增資料)與Delete(刪除資料)時派上用場。&lt;/p&gt;
&lt;p&gt;接著來看RBT的五項特徵：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;RBT中的每一個node不是黑色就是紅色。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;root&lt;/code&gt;一定是黑色。&lt;/li&gt;
&lt;li&gt;每一個leaf node(也就是&lt;code&gt;NIL&lt;/code&gt;)一定是黑色。&lt;/li&gt;
&lt;li&gt;如果某個node是紅色，那麼其兩個child必定是黑色，不能有兩個紅色node相連，如圖四中的node(17)、node(30)。&lt;br /&gt;
若某個node為黑色，其child之顏色沒有限制，如圖四中的node(38)、node(26)、node(21)。&lt;/li&gt;
&lt;li&gt;站在任何一個node上，所有從該node走到其任意descendant的path上之黑色node數必定相同。&lt;br /&gt;
以圖四為例，站在node(14)上，所有從node(14)走向其descendant leaves(也就是&lt;code&gt;NIL&lt;/code&gt;)的path上之黑色node數必為3： &lt;ul&gt;
&lt;li&gt;path1:14(&lt;strong&gt;b&lt;/strong&gt;)-10(r)-7(&lt;strong&gt;b&lt;/strong&gt;)-3(r)-NIL(&lt;strong&gt;b&lt;/strong&gt;)；&lt;/li&gt;
&lt;li&gt;path2:14(&lt;strong&gt;b&lt;/strong&gt;)-10(r)-7(&lt;strong&gt;b&lt;/strong&gt;)-NIL(&lt;strong&gt;b&lt;/strong&gt;)；&lt;/li&gt;
&lt;li&gt;path3:14(&lt;strong&gt;b&lt;/strong&gt;)-10(r)-12(&lt;strong&gt;b&lt;/strong&gt;)-NIL(&lt;strong&gt;b&lt;/strong&gt;)；&lt;/li&gt;
&lt;li&gt;path4:14(&lt;strong&gt;b&lt;/strong&gt;)-16(&lt;strong&gt;b&lt;/strong&gt;)-15(r)-NIL(&lt;strong&gt;b&lt;/strong&gt;)；&lt;/li&gt;
&lt;li&gt;path5:14(&lt;strong&gt;b&lt;/strong&gt;)-16(&lt;strong&gt;b&lt;/strong&gt;)-NIL(&lt;strong&gt;b&lt;/strong&gt;)；   &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;根據上述特徵的第四點與第五點，RBT中path可能的長度最小值一定是全部node皆為黑色，而path可能的長度最大值並定是紅色-黑色相間(如圖四)，如此便確保RBT擁有&lt;strong&gt;最長path(路徑)不會超過最短path的兩倍&lt;/strong&gt;的特性。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="code"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;程式碼&lt;/h2&gt;
&lt;p&gt;實際的程式實現上，會把所有&lt;code&gt;NIL&lt;/code&gt;視為同一個&lt;code&gt;NIL&lt;/code&gt;，並把&lt;code&gt;root&lt;/code&gt;的parent指向&lt;code&gt;NIL&lt;/code&gt;，以節省記憶體空間，如圖五。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="rbt" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Intro/rbt4.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;class TreeNode&lt;/code&gt;與&lt;code&gt;class RBT&lt;/code&gt;之資料成員(data member)程式範例如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;string&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;RBT&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;element&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;         &lt;span class="c1"&gt;// 0: Red,  1: Black&lt;/span&gt;
    &lt;span class="k"&gt;friend&lt;/span&gt; &lt;span class="n"&gt;RBT&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;RBT&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;neel&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="c1"&gt;// 此即為NIL, 常被稱為sentinel&lt;/span&gt;
    &lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;(為了避開某些IDE將&lt;code&gt;NIL&lt;/code&gt;設定成保留關鍵字(reserved keywords，例如&lt;code&gt;template&lt;/code&gt;、&lt;code&gt;while&lt;/code&gt;、&lt;code&gt;struct&lt;/code&gt;等等)，因此使用&lt;code&gt;neel&lt;/code&gt;。)&lt;/p&gt;
&lt;p&gt;為求畫面簡潔，往後的篇幅裡將把RBT示意圖中的&lt;code&gt;NIL&lt;/code&gt;隱藏起來，只顯示RBT中的internal node，如圖六，不過心裡要記得，RBT無時無刻都被&lt;code&gt;NIL&lt;/code&gt;充滿著。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="rbt" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Intro/rbt5.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖六：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;以上便是RBT之初探，最重要的結論為：就時間複雜度而言，RBT能夠被視為平衡的BST，所有操作皆能在時間複雜度為&lt;span class="math"&gt;\(O(\log N)\)&lt;/span&gt;內完成。&lt;/p&gt;
&lt;p&gt;在接下來的三篇文章中，將依序介紹Rotation(旋轉)、Insert(新增資料)與Delete(刪除資料)。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a name="ref"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;參考資料：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844"&gt;Introduction to Algorithms, Ch13&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376"&gt;Fundamentals of Data Structures in C++&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://code.geeksforgeeks.org/NtLnIk"&gt;GeeksforGeeks：Red Black Tree&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="tree_series"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Tree系列文章&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/treeshu-introjian-jie.html"&gt;Tree(樹): Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-introjian-jie.html"&gt;Binary Tree: Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-traversalxun-fang.html"&gt;Binary Tree: Traversal(尋訪)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-jian-li-yi-ke-binary-tree.html"&gt;Binary Tree: 建立一棵Binary Tree&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-introjian-jie.html"&gt;Binary Search Tree: Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-searchsou-xun-zi-liao-insertxin-zeng-zi-liao.html"&gt;Binary Search Tree: Search(搜尋資料)、Insert(新增資料)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-sortpai-xu-deleteshan-chu-zi-liao.html"&gt;Binary Search Tree: Sort(排序)、Delete(刪除資料)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-introjian-jie.html"&gt;Red Black Tree: Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-rotationxuan-zhuan.html"&gt;Red Black Tree: Rotation(旋轉)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-insertxin-zeng-zi-liao-yu-fixupxiu-zheng.html"&gt;Red Black Tree: Insert(新增資料)與Fixup(修正)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-deleteshan-chu-zi-liao-yu-fixupxiu-zheng.html"&gt;Red Black Tree: Delete(刪除資料)與Fixup(修正)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="C++"></category><category term="Red Black Tree"></category><category term="Intro"></category></entry><entry><title>Binary Search Tree: Sort(排序)、Delete(刪除資料)</title><link href="http://alrightchiu.github.io/SecondRound/binary-search-tree-sortpai-xu-deleteshan-chu-zi-liao.html" rel="alternate"></link><updated>2016-01-15T21:27:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2016-01-15:SecondRound/binary-search-tree-sortpai-xu-deleteshan-chu-zi-liao.html</id><summary type="html">&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;先備知識與注意事項&lt;/h3&gt;
&lt;p&gt;由於Sort與Delete會用到先前在&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-traversalxun-fang.html#in_parent"&gt;Binary Tree：Traversal介紹過的Leftmost()、Rightmost()、Successor()與Predecessor()&lt;/a&gt;，因此建議在開始閱讀本篇文章之前，先復習上述四個函式操作。  &lt;/p&gt;
&lt;p&gt;在文章最後將會附上四個函式的範例程式碼。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#sort"&gt;Sort(排序)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#delete"&gt;BST::DeleteBST(刪除資料)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#main"&gt;main()&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#4function"&gt;Leftmost、Rightmost、Successor、Predecessor範例程式碼&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#ref"&gt;參考資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#tree_series"&gt;Tree系列文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="sort"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Sort(排序)&lt;/h2&gt;
&lt;p&gt;讀者可能會發現，在&lt;code&gt;class BST&lt;/code&gt;的定義中，根本就沒有類似&lt;code&gt;SortBST()&lt;/code&gt;的函式，沒錯，因為在BST中，每一個&lt;code&gt;Treenode&lt;/code&gt;都有&lt;span class="math"&gt;\(Key(L)&amp;lt;Key(Current)&amp;lt;Key(R)\)&lt;/span&gt;的性質，這正好與Inorder(LVR)之順序相同，因此，對整棵樹進行Inorder Traversal，就能夠對資料由小到大(依照Key)進行Visiting。&lt;/p&gt;
&lt;p&gt;以上一篇&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-searchsou-xun-zi-liao-insertxin-zeng-zi-liao.html#binary-search-tree-searchsou-xun-zi-liao-insertxin-zeng-zi-liao"&gt;Binary Search Tree: Search()、Insert()&lt;/a&gt;的&lt;code&gt;main()&lt;/code&gt;所建立的BST為例，如圖一，要將此樹中的資料按照Key之順序由小到大印出，只需要對整棵樹做一次Inorder Traversal即可。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/sort_delete/sort_delete1.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;以下範例程式，將Visiting用作列印資料(print)：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;BST&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;InorderPrint&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Leftmost&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="c1"&gt;// Visiting&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;element&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;(&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;)&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot; &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    
        &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Successor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;            &lt;span class="c1"&gt;// 移動至current的Successor&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;output:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;克林&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="err"&gt;龜仙人&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="err"&gt;比克&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;513&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="err"&gt;悟空&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1000&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="delete"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;BST::DeleteBST(刪除資料)&lt;/h2&gt;
&lt;p&gt;要在BST上執行刪除資料(被刪除的node稱為A)，必須讓刪除A後的BST仍然維持BST的性質，因此，所有「具有指向A的pointer」之node(也就是A的&lt;code&gt;parent&lt;/code&gt;、A的&lt;code&gt;leftchild&lt;/code&gt;與A的&lt;code&gt;rightchild&lt;/code&gt;)都必須指向新的記憶體位置。&lt;/p&gt;
&lt;p&gt;刪除資料的工作，根據欲刪除之node「有幾個child pointer」分成三類：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Case1：欲刪除之node沒有&lt;code&gt;child pointer&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;Case2：欲刪除之node只有一個&lt;code&gt;child pointer&lt;/code&gt;(不論是&lt;code&gt;leftchild&lt;/code&gt;或&lt;code&gt;rightchild&lt;/code&gt;)；&lt;/li&gt;
&lt;li&gt;Case3：欲刪除之node有兩個&lt;code&gt;child pointer&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以圖二(a)為例，依序刪除撒旦、弗力札與西魯：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/sort_delete/sort_delete2.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(a)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Case1&lt;/strong&gt;：由於撒旦沒有&lt;code&gt;child pointer&lt;/code&gt;，因此只要考慮撒旦的parent(普烏)，將普烏的&lt;code&gt;leftchild&lt;/code&gt;指向&lt;code&gt;NULL&lt;/code&gt;即可維持BST的正確性，如圖二(b)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/sort_delete/sort_delete3.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(b)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Case2&lt;/strong&gt;：由於弗力札有一個&lt;code&gt;leftchild&lt;/code&gt;(基紐)，因此在刪除弗力札之前，需要先將基紐的parent指向弗力札的&lt;code&gt;parent&lt;/code&gt;(龜仙人)，並且將龜仙人的&lt;code&gt;rightchild&lt;/code&gt;從原本的弗力札指向基紐，因為基紐原本就位於龜仙人的right subtree(右子樹)，因此，上述操作仍能維持BST的正確性，如圖二(c)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/sort_delete/sort_delete4.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(c)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Case3&lt;/strong&gt;：由於西魯有兩個&lt;code&gt;child&lt;/code&gt;，若直接刪除西魯的資料，並釋放其記憶體位置，要牽動的node較多。變通的祕訣就是「找替身」，原本要刪西魯，但是實際上是釋放西魯的「Successor(達爾)」的記憶體位置(或是「Predecessor(16號)」)，最後再把「Successor(達爾)」(或是「Predecessor(16號)」)的資料放回到西魯的記憶體位置上，又因為BST的特徵，所有「具有兩個&lt;code&gt;child&lt;/code&gt;」的node的Successor或是Predecessor一定是leaf node或是只有一個&lt;code&gt;child&lt;/code&gt;，如此，便回到如同撒旦與弗力札「至多只有一個&lt;code&gt;child&lt;/code&gt;」的情境。 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;驗證「具有兩個&lt;code&gt;child&lt;/code&gt;的node的Successor或是Predecessor一定是leaf node或是只有一個&lt;code&gt;child&lt;/code&gt;」：若某個node有兩個&lt;code&gt;child&lt;/code&gt;，則Successor找的是「right subtree中Key最小的node」，而Predecessor找的是「left subtree中Key最大的node」，因此Successor和Predecessor必定不會同時也有兩個child。以圖二(d)為例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;龜仙人(8)的Predecessor為克林(2)，Successor為基紐(69)；&lt;/li&gt;
&lt;li&gt;比克(513)的Predecessor為基紐(69)，Successor為16號(520)；&lt;/li&gt;
&lt;li&gt;悟飯(888)的Predecessor為達爾(881)，Successor為普烏(999)；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/sort_delete/sort_delete5.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(d)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;現欲刪除西魯，就去找西魯的Successor(達爾)當做替身，因為達爾沒有&lt;code&gt;child&lt;/code&gt;，其刪除方法便如同上述刪除撒旦的方法，如圖二(e)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/sort_delete/sort_delete6.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(e)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最後再將達爾的資料放進原先存放西魯資料的記憶體位置，便完成了刪除西魯的操作，如圖二(f)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/sort_delete/sort_delete7.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(f)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;BST::DeleteBST()&lt;/code&gt;之範例程式碼分成以下幾個步驟：：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先確認BST中有沒有要刪除的node；&lt;/li&gt;
&lt;li&gt;把要刪除的node調整成「至多只有一個&lt;code&gt;child&lt;/code&gt;」；&lt;/li&gt;
&lt;li&gt;把要刪除的node的&lt;code&gt;child&lt;/code&gt;指向新的&lt;code&gt;parent&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;把要刪除的node的&lt;code&gt;parent&lt;/code&gt;指向新的&lt;code&gt;child&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;若實際上刪除的是「替身」，再把替身的資料放回BST中。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;即完成BST之刪除資料操作。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;BST&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;DeleteBST&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;KEY&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;               &lt;span class="c1"&gt;// 要刪除具有KEY的node&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;delete_node&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;delete_node&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Search&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;KEY&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;              &lt;span class="c1"&gt;// 先確認BST中是否有具有KEY的node&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;delete_node&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;data not found.&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;      &lt;span class="c1"&gt;// 真正要被刪除並釋放記憶體的node&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;      &lt;span class="c1"&gt;// 要被刪除的node的child&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;delete_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;delete_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;delete_node&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
        &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Successor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;delete_node&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                                            &lt;span class="c1"&gt;// 經過以上的if-else, y至多只有一個child&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;               &lt;span class="c1"&gt;// 將x設成y的child, 可能是有效記憶體, 也有可能是NULL&lt;/span&gt;
        &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
        &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;                          
        &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;              &lt;span class="c1"&gt;// 此即為圖二(c)中, 基紐指向龜仙人的實作方式&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;                  &lt;span class="c1"&gt;// 再將要被刪除的node之parent指向新的child&lt;/span&gt;
        &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
        &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;delete_node&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;                 &lt;span class="c1"&gt;// y即是達爾, delete_node即是西魯&lt;/span&gt;
        &lt;span class="n"&gt;delete_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;SetKey&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;GetKey&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;   &lt;span class="c1"&gt;// 實際被刪除的是y, 因此最後要再將y的資料放進delete_node的記憶體位置&lt;/span&gt;
        &lt;span class="n"&gt;delete_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;SetElement&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;GetElement&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;   
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="main"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;main()&lt;/h2&gt;
&lt;p&gt;延續上一篇文章&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-searchsou-xun-zi-liao-insertxin-zeng-zi-liao.html#binary-search-tree-searchsou-xun-zi-liao-insertxin-zeng-zi-liao"&gt;Binary Search Tree: Search()、Insert()&lt;/a&gt;的&lt;code&gt;main()&lt;/code&gt;，加入&lt;code&gt;BST::DeleteBST&lt;/code&gt;，把龜仙人(8)刪除，應該會得到如圖三的BST，比克(513)成為新的&lt;code&gt;root&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/sort_delete/sort_delete8.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;BST&lt;/span&gt; &lt;span class="n"&gt;b1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="n"&gt;n1&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;龜仙人&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="n"&gt;n2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1000&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;悟空&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="n"&gt;n3&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;克林&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="n"&gt;n4&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;513&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;比克&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;b1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;InsertBST&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;b1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;InsertBST&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;b1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;InsertBST&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n3&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;b1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;InsertBST&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n4&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;b1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DeleteBST&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;          &lt;span class="c1"&gt;// 刪除龜仙人&lt;/span&gt;
    &lt;span class="n"&gt;b1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;InorderPrint&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;output:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;克林&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="err"&gt;比克&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;513&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="err"&gt;悟空&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1000&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="4function"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Leftmost、Rightmost、Successor、Predecessor範例程式碼&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;BST&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Leftmost&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;BST&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Rightmost&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;BST&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Successor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;Leftmost&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;new_node&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;new_node&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;new_node&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;new_node&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;BST&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Predecessor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;Rightmost&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;new_node&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;new_node&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;new_node&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;new_node&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;以上便是BST中&lt;code&gt;BST::DeleteBST()&lt;/code&gt;之介紹，關鍵即在Successor與Predecessor。  &lt;/p&gt;
&lt;p&gt;在接下來將介紹的Red Black Tree(RBT，紅黑樹)中，BST的&lt;code&gt;Insert()&lt;/code&gt;與&lt;code&gt;Delete()&lt;/code&gt;會再次出現，不過，需要再「多一道手續」以滿足RBT的性質。&lt;/p&gt;
&lt;p&gt;最後，因為RBT的圖比較複雜，所以圈圈裏面放名字會太擠，有礙觀瞻，因此要忍痛讓「悟空」、「克林」退居幕後，直接在node裡面放上Key。 
不過，相信透過這三篇BST的介紹，讀者對七龍珠也有一定程度的了解，後面的部分一定可以靠自學來搜集龍珠了。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a name="ref"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;參考資料：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844"&gt;Introduction to Algorithms&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376"&gt;Fundamentals of Data Structures in C++&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="tree_series"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Tree系列文章&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/treeshu-introjian-jie.html"&gt;Tree(樹): Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-introjian-jie.html"&gt;Binary Tree: Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-traversalxun-fang.html"&gt;Binary Tree: Traversal(尋訪)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-jian-li-yi-ke-binary-tree.html"&gt;Binary Tree: 建立一棵Binary Tree&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-introjian-jie.html"&gt;Binary Search Tree: Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-searchsou-xun-zi-liao-insertxin-zeng-zi-liao.html"&gt;Binary Search Tree: Search(搜尋資料)、Insert(新增資料)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-sortpai-xu-deleteshan-chu-zi-liao.html"&gt;Binary Search Tree: Sort(排序)、Delete(刪除資料)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-introjian-jie.html"&gt;Red Black Tree: Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-rotationxuan-zhuan.html"&gt;Red Black Tree: Rotation(旋轉)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-insertxin-zeng-zi-liao-yu-fixupxiu-zheng.html"&gt;Red Black Tree: Insert(新增資料)與Fixup(修正)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-deleteshan-chu-zi-liao-yu-fixupxiu-zheng.html"&gt;Red Black Tree: Delete(刪除資料)與Fixup(修正)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="C++"></category><category term="Binary Search Tree(二元搜尋樹)"></category></entry><entry><title>Binary Search Tree: Search(搜尋資料)、Insert(新增資料)</title><link href="http://alrightchiu.github.io/SecondRound/binary-search-tree-searchsou-xun-zi-liao-insertxin-zeng-zi-liao.html" rel="alternate"></link><updated>2016-01-03T20:17:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2016-01-03:SecondRound/binary-search-tree-searchsou-xun-zi-liao-insertxin-zeng-zi-liao.html</id><summary type="html">&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;先備知識與注意事項&lt;/h3&gt;
&lt;p&gt;在開始介紹search(搜尋資料)與insert(新增資料)之前，先定義好&lt;code&gt;class TreeNode&lt;/code&gt;與&lt;code&gt;class BST&lt;/code&gt;，順便對未來將介紹的其他member function(成員函式)留下美好的第一印象：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;string&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;BST&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;element&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="c1"&gt;// constructor&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;element&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;element&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="c1"&gt;// default copy constructor&lt;/span&gt;
    &lt;span class="c1"&gt;// default destructor&lt;/span&gt;

    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;GetKey&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;;};&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;GetElement&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;element&lt;/span&gt;&lt;span class="p"&gt;;};&lt;/span&gt;

    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;SetKey&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;;};&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;SetElement&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt; &lt;span class="n"&gt;element&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;;};&lt;/span&gt;   

    &lt;span class="k"&gt;friend&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;BST&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="c1"&gt;// 放在 private 或 public 都可以 &lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="c1"&gt;// class BST&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;BST&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nf"&gt;Rightmost&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nf"&gt;Leftmost&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nf"&gt;Copy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;origNode&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;    &lt;span class="c1"&gt;// preorder traversal, 用在 copy constructor和 operator=&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;PostorderDelete&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;BST&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;     &lt;span class="c1"&gt;// default constructor&lt;/span&gt;
    &lt;span class="n"&gt;BST&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;BST&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;      &lt;span class="c1"&gt;// copy constructor&lt;/span&gt;
    &lt;span class="n"&gt;BST&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;BST&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;BST&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  &lt;span class="c1"&gt;// destructor&lt;/span&gt;

    &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nf"&gt;Search&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;InsertBST&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nf"&gt;Successor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nf"&gt;Predecessor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;InorderPrint&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;DeleteBST&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;KEY&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="nf"&gt;IsEmpty&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;);};&lt;/span&gt;    &lt;span class="c1"&gt;// 確認BST是否存有資料&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;文章內容將著重於BST這個資料結構，並提供此資料結構中可行的演算法，因此，有關C++的實作方法並不唯一，筆者相信有更優秀的寫法(有效利用記憶體、避免memory leak(記憶體洩漏)等議題)，建議讀者可以多多參考例如&lt;a href="http://codereview.stackexchange.com/"&gt;Stack Exchange:Code Review&lt;/a&gt;等等眾多優秀的網站，看網友的程式碼的寫法以及由該份程式碼所開啟的討論串，應該會對實際寫作技巧有些幫助。&lt;br /&gt;
(筆者也還在學啊啊啊啊)&lt;/p&gt;
&lt;p&gt;另外，用以測試的&lt;code&gt;main()&lt;/code&gt;將在BST系列的演算法都介紹完後登場。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#search"&gt;BST::Search(搜尋)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#insert"&gt;BST::InsertBST(新增資料)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#main"&gt;main()&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#ref"&gt;參考資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#tree_series"&gt;Tree系列文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="search"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;BST::Search(搜尋)&lt;/h2&gt;
&lt;p&gt;BST的&lt;code&gt;Search()&lt;/code&gt;操作，便是根據BST的特徵：&lt;span class="math"&gt;\(Key(L)&amp;lt;Key(Current)&amp;lt;Key(R)\)&lt;/span&gt;，判斷&lt;code&gt;Current&lt;/code&gt;node應該往left subtree走，還是往right subtree走。&lt;/p&gt;
&lt;p&gt;現有一棵BST如圖一(a)所示：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/search_insert/f18.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(a)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;   &lt;/p&gt;
&lt;p&gt;搜尋結果可能成功，可能失敗，以下便分別以兩個KEY值作說明。&lt;/p&gt;
&lt;h3&gt;搜尋成功&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;若現在要從BST中搜尋基紐隊長，便以基紐隊長的KEY(627)進入BST。&lt;br /&gt;
進入BST後，便把用來移動的&lt;code&gt;Current&lt;/code&gt;node指向&lt;code&gt;root&lt;/code&gt;，如圖一(b)。  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/search_insert/f19.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(b)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt; &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;此時，便將KEY(627)和比克(&lt;code&gt;root&lt;/code&gt;)的戰鬥力(513)比較，結果是基紐隊長戰勝，因此，基紐隊長如果在BST裡面，應該會長在比克的right subtree，於是便將&lt;code&gt;Current&lt;/code&gt;往比克的right child(達爾)移動，如圖一(c)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/search_insert/f20.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(c)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt; &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;將&lt;code&gt;Current&lt;/code&gt;移動到達爾之後，再將KEY(627)與達爾的戰鬥力(524)比較，結果仍然是基紐隊長大勝，因此步驟同上，繼續將&lt;code&gt;Current&lt;/code&gt;往達爾的right child(弗力札)移動，如圖一(d)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/search_insert/f21.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(d)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt; &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;將&lt;code&gt;Current&lt;/code&gt;移動到弗力札之後，再將KEY(627)與弗力札的戰鬥力(709)比較，結果是弗力札略勝，於是便往弗力札的left child尋找基紐隊長，如圖一(e)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/search_insert/f22.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(e)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;此時，&lt;code&gt;Current&lt;/code&gt;的Key(627)與傳送進&lt;code&gt;Search()&lt;/code&gt;的KEY(627)相同，便確認&lt;code&gt;Current&lt;/code&gt;即為基紐隊長，於是跳出&lt;code&gt;while&lt;/code&gt;迴圈，並傳回&lt;code&gt;Current&lt;/code&gt;。&lt;br /&gt;
即搜尋成功。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;搜尋失敗&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;若現在要從BST中尋找克林，便以克林的戰鬥力(2)為KEY(2)，進入&lt;code&gt;Search()&lt;/code&gt;。&lt;br /&gt;
進入BST後，同樣把用來移動的&lt;code&gt;Current&lt;/code&gt;node指向&lt;code&gt;root&lt;/code&gt;，如圖一(b)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/search_insert/f19.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(b)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt; &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;接著便將KEY(2)和比克的戰鬥力(513)比較，結果是比克勝出，於是將&lt;code&gt;Currnet&lt;/code&gt;往比克的left child(龜仙人)移動，如圖一(f)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/search_insert/f23.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(f)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt; &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;將&lt;code&gt;Current&lt;/code&gt;移動至龜仙人後，將KEY(2)和龜仙人的戰鬥力(8)比較，便判斷出，要將&lt;code&gt;Current&lt;/code&gt;往龜仙人的left child移動，如圖一(f)。&lt;br /&gt;
然而，由於龜仙人沒有left child，於是&lt;code&gt;Current&lt;/code&gt;指向&lt;code&gt;NULL&lt;/code&gt;，便跳出迴圈，並回傳&lt;code&gt;NULL&lt;/code&gt;，即表示搜尋失敗，克林不在BST中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下是&lt;code&gt;BST::Search()&lt;/code&gt;的範例程式碼，其中，有兩種情況會跳出&lt;code&gt;while&lt;/code&gt;迴圈：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;KEY與&lt;code&gt;Current&lt;/code&gt;node的key相同，表示搜尋成功；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Current&lt;/code&gt;移動到&lt;code&gt;NULL&lt;/code&gt;，表示搜尋失敗。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;BST&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Search&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;KEY&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;KEY&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;GetKey&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;KEY&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;GetKey&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
            &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="c1"&gt;// 向左走&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;
            &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;// 向右走&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;/br&gt; &lt;/p&gt;
&lt;p&gt;&lt;a name="insert"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;BST::InsertBST(新增資料)&lt;/h2&gt;
&lt;p&gt;函式&lt;code&gt;InsertBST()&lt;/code&gt;的演算法概念，可以視為&lt;code&gt;Search()&lt;/code&gt;的延伸：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;根據BST對Key之規則，先找到「將要新增之node」適合的位置；&lt;/li&gt;
&lt;li&gt;再將欲新增的node接上BST。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;要尋找「對新增node而言的適當位置」，需要召喚一位「哨兵」先行探路，而「將會成為新增node的&lt;strong&gt;parent node&lt;/strong&gt;(準新手爸媽)」則跟著「哨兵」的腳步，往前推進。 &lt;/p&gt;
&lt;p&gt;定義「哨兵」為&lt;strong&gt;x&lt;/strong&gt;，「準新手爸媽」為&lt;strong&gt;y&lt;/strong&gt;，現欲新增「比克，戰鬥力(513)」進入如圖二(a)之BST。&lt;br /&gt;
(這裡的「哨兵&lt;strong&gt;x&lt;/strong&gt;」具有&lt;code&gt;BST::Search()&lt;/code&gt;中&lt;code&gt;Current&lt;/code&gt;node的功能。)&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/search_insert/f24.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(a)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt; &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如圖二(a)，剛進入BST時，「哨兵&lt;strong&gt;x&lt;/strong&gt;」進到&lt;code&gt;root&lt;/code&gt;，而「準新手爸媽&lt;strong&gt;y&lt;/strong&gt;」即為&lt;code&gt;root&lt;/code&gt;的parent，即為&lt;code&gt;NULL&lt;/code&gt;。  &lt;/li&gt;
&lt;li&gt;接著，將欲新增node之Key(比克(513))與「哨兵&lt;strong&gt;x&lt;/strong&gt;」之Key(龜仙人(8))相比，比克的戰鬥力比龜仙人高，所以比克應該要長在龜仙人的right subtree，因此把「哨兵&lt;strong&gt;x&lt;/strong&gt;」往龜仙人的right child(悟空)移動，並且更新「準新手爸媽&lt;strong&gt;y&lt;/strong&gt;」為龜仙人，如圖二(b)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/search_insert/f25.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(b)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt; &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;接著，繼續比較欲新增node之Key(比克(513))與「哨兵&lt;strong&gt;x&lt;/strong&gt;」之Key(悟空(1000))，結果是悟空的戰鬥力較高，比克應該要長在悟空的left subtree，因此，將「哨兵&lt;strong&gt;x&lt;/strong&gt;」往悟空的left child(&lt;code&gt;NULL&lt;/code&gt;)移動，同時更新「準新手爸媽&lt;strong&gt;y&lt;/strong&gt;」為悟空，如圖二(c)。&lt;/li&gt;
&lt;li&gt;更新後，「準新手爸媽&lt;strong&gt;y&lt;/strong&gt;」成為悟空，「哨兵&lt;strong&gt;x&lt;/strong&gt;」指向&lt;code&gt;NULL&lt;/code&gt;壯烈犧牲，即達到跳出迴圈之條件。此時，便找到了「新增node」之適當位置。&lt;br /&gt;
那個「適當位置」在哪裡呢？就是「準新手爸媽&lt;strong&gt;y&lt;/strong&gt;」的child pointer。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/search_insert/f26.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(c)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt; &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;下一步，便是比較欲新增node之Key(比克(513))與「準新手爸媽&lt;strong&gt;y&lt;/strong&gt;」之Key(悟空(1000))，發現悟空戰鬥力較高，因此，比克(513)便成為「準新手爸媽&lt;strong&gt;y&lt;/strong&gt;」的left child，如圖二(d)，便成功把比克(513)接到BST上。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/search_insert/f27.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(d)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt; &lt;/p&gt;
&lt;p&gt;以下是&lt;code&gt;BST::InsertBST()&lt;/code&gt;的範例程式碼，關鍵便是「哨兵&lt;strong&gt;x&lt;/strong&gt;」與「準新手爸媽&lt;strong&gt;y&lt;/strong&gt;」的冒險之旅：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;BST&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;InsertBST&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;        &lt;span class="c1"&gt;// 準新手爸媽&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;        &lt;span class="c1"&gt;// 哨兵&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;insert_node&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// call default copy constructor of TreeNode&lt;/span&gt;

    &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;                &lt;span class="c1"&gt;// 在while中, 以如同Search()的方式尋找適當的位置       &lt;/span&gt;
        &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                                
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;insert_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;GetKey&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;GetKey&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
            &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;
            &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;                                  &lt;span class="c1"&gt;// 跳出迴圈後, x即為NULL&lt;/span&gt;
    &lt;span class="n"&gt;insert_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;           &lt;span class="c1"&gt;// y即為insert_node的parent&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;                     &lt;span class="c1"&gt;// 下面一組if-else, 把insert_node接上BST&lt;/span&gt;
        &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;insert_node&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;insert_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;GetKey&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;GetKey&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
        &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;insert_node&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
        &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;insert_node&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;備註：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在定義函式&lt;code&gt;InsertBST()&lt;/code&gt;時，函式的參數(argument)可能會視情境而有所改變，這裡是以一個&lt;code&gt;TreeNode&lt;/code&gt;的物件(object)之&lt;strong&gt;reference&lt;/strong&gt;作為參數，傳進函式&lt;code&gt;InsertBST()&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;InsertBST()&lt;/code&gt;特別標示出BST是為了與之後會介紹的Red Black Tree(紅黑樹)之&lt;code&gt;InsertRBT()&lt;/code&gt;做區別。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="main"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;main()&lt;/h2&gt;
&lt;p&gt;有了&lt;code&gt;BST::InsertBST()&lt;/code&gt;後，就可以用土法煉鋼的方式建立一棵如圖二(d)的BST:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;BST&lt;/span&gt; &lt;span class="n"&gt;b1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="n"&gt;n1&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;龜仙人&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="n"&gt;n2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1000&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;悟空&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="n"&gt;n3&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;克林&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="n"&gt;n4&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;513&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;比克&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;b1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;InsertBST&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;b1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;InsertBST&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;b1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;InsertBST&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n3&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;b1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;InsertBST&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n4&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;以上便是BST中&lt;code&gt;Search()&lt;/code&gt;與&lt;code&gt;InsertBST()&lt;/code&gt;之介紹，只要掌握BST的性質&lt;span class="math"&gt;\(Key(L)&amp;lt;Key(Current)&amp;lt;Key(R)\)&lt;/span&gt;與樹中的Traversal(pointer的移動)即可輕鬆上路。 &lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a name="ref"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;參考資料：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844"&gt;Introduction to Algorithms&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376"&gt;Fundamentals of Data Structures in C++&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="tree_series"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Tree系列文章&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/treeshu-introjian-jie.html"&gt;Tree(樹): Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-introjian-jie.html"&gt;Binary Tree: Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-traversalxun-fang.html"&gt;Binary Tree: Traversal(尋訪)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-jian-li-yi-ke-binary-tree.html"&gt;Binary Tree: 建立一棵Binary Tree&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-introjian-jie.html"&gt;Binary Search Tree: Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-searchsou-xun-zi-liao-insertxin-zeng-zi-liao.html"&gt;Binary Search Tree: Search(搜尋資料)、Insert(新增資料)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-sortpai-xu-deleteshan-chu-zi-liao.html"&gt;Binary Search Tree: Sort(排序)、Delete(刪除資料)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-introjian-jie.html"&gt;Red Black Tree: Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-rotationxuan-zhuan.html"&gt;Red Black Tree: Rotation(旋轉)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-insertxin-zeng-zi-liao-yu-fixupxiu-zheng.html"&gt;Red Black Tree: Insert(新增資料)與Fixup(修正)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-deleteshan-chu-zi-liao-yu-fixupxiu-zheng.html"&gt;Red Black Tree: Delete(刪除資料)與Fixup(修正)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="C++"></category><category term="Binary Search Tree(二元搜尋樹)"></category></entry><entry><title>Binary Search Tree: Intro(簡介)</title><link href="http://alrightchiu.github.io/SecondRound/binary-search-tree-introjian-jie.html" rel="alternate"></link><updated>2016-01-02T12:15:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2016-01-02:SecondRound/binary-search-tree-introjian-jie.html</id><summary type="html">&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;先備知識與注意事項&lt;/h3&gt;
&lt;p&gt;先前的文章介紹過廣義的Tree(樹)、Binary Tree(二元樹)，這篇文章將繼續增加限制條件，使Binary Tree晉升成Binary Search Tree(BST，二元搜尋樹)。  &lt;/p&gt;
&lt;p&gt;這裡要處理的資料是日本漫畫的曠世鉅作《七龍珠》中各角色的戰鬥力。&lt;br /&gt;
七龍珠的劇情(正篇有七龍珠、七龍珠Z、七龍珠改、七龍珠GT、七龍珠超，劇場版還有&lt;a href="https://zh.wikipedia.org/wiki/%E4%B8%83%E9%BE%99%E7%8F%A0#.E5.8A.87.E5.A0.B4.E7.89.88"&gt;七龍珠劇場版(太多了請參閱維基百科)&lt;/a&gt;)時而前後連貫，時而交錯，為了維持每個系列之間的角色設定，就需要對角色的戰鬥力進行管理，避免劇情不合邏輯變成鬧劇，在此，筆者推薦鳥山明老師可以使用先進如BST的資料結構來整理角色的資料(當然，也是可以用excel或是國小生字簿，&lt;a href="http://www.imdb.com/title/tt1178663/"&gt;Whatever Works&lt;/a&gt;)。  &lt;/p&gt;
&lt;p&gt;熱血沸騰了。  &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#dictionary"&gt;引入dictionary&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#bst"&gt;Binary Search Tree的特徵&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#operation"&gt;在Binary Search Tree中管理資料&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#insert"&gt;insert(新增資料)&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="#search"&gt;search(搜尋資料)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#sort"&gt;sort(排序)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#delete"&gt;delete(刪除資料)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#ref"&gt;參考資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#tree_series"&gt;Tree系列文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="dictionary"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;引入dictionary&lt;/h2&gt;
&lt;p&gt;搜尋與排序都需要「比大小」，欲執行「比大小」，就要使用「能夠比大小」的資料形態(亦即：兩個比較之物只能唯一滿足於「大於」、「小於」或「等於」之關係)，最直觀的便是使用整數(integer)。  &lt;/p&gt;
&lt;p&gt;在先前的文章中，&lt;code&gt;class TreeNode&lt;/code&gt;包含了指向child的pointer、指向parent的pointer，以及一個&lt;code&gt;char data&lt;/code&gt;來儲存字母。  &lt;/p&gt;
&lt;p&gt;而更多時候，node所攜帶的資料項目(在此為&lt;code&gt;char data&lt;/code&gt;)可能更複雜，也許是一個姓名、一組帳戶資料、一本照片集、一組科學資料等等，然而，要使用這些資料進行「比大小」必須而外自行定義規則，例如：「姓氏照字母順序排序，字母越前面值越大；若第一個字相同，則依序往下比較；若姓名中所有字母之順序皆相同則...」，非常不實際，因此，不用再則了，變通的方法便是直接在資料上加上「編號」(也可以想成，把資料對應(mapping)到特定編號)，以編號做排序，並且能夠以特定編號搜尋其所對應之資料項目，即可避開上述麻煩。  &lt;/p&gt;
&lt;p&gt;如此概念便是Dictionary，稱上述的「編號」為「Key(鍵值)」，稱「資料項目」為「Element(元素)」，則稱一組「Key-Element pairs」的集合為「Dictionary」。  &lt;/p&gt;
&lt;p&gt;如圖一所示，若將先前的字母視為「Element」並加上「Key」，則(Key, Element)可以表示成(編號, A)，若處理學生資料，將編號視為學號，資料視為姓名，則能夠將(Key, Element)可以表示成(學號, 姓名)。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;
&lt;center&gt;
&lt;img alt="dictionary1" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/Intro/f1.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt; &lt;/p&gt;
&lt;p&gt;在接下來的篇幅裡，將使用七龍珠的角色(悟空)作為Element，角色的戰鬥力視為Key：&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;
&lt;center&gt;
&lt;img alt="dictionary2" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/Intro/f2.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;修正後的&lt;code&gt;class TreeNode&lt;/code&gt;可能長這樣： &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;       &lt;span class="c1"&gt;// Element&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Key&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                &lt;span class="c1"&gt;// Key, used for comparison &lt;/span&gt;
     &lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;備註： &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Dictionary的概念也出現在&lt;strong&gt;Hash Table&lt;/strong&gt;(有天才翻譯成"哈希表"也很酷)、C/C++標準函式庫(Standard Library)中的&lt;strong&gt;container&lt;/strong&gt;:&lt;code&gt;map&lt;/code&gt;等等，有非常多應用。&lt;/li&gt;
&lt;li&gt;以下角色戰鬥力的絕對值是捏造的，不過相對值盡力維持正確(除了撒旦)，若有疑問，歡迎龍珠粉來信討論。 &lt;/li&gt;
&lt;li&gt;由於故事的角色眾多，以下將挑選具代表性之角色用來說明BST。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="bst"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Binary Search Tree的特徵&lt;/h2&gt;
&lt;p&gt;有了加裝Dictionary後的&lt;code&gt;TreeNode&lt;/code&gt;，便能夠說明BST的特徵：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;任何CurrnetNode之Key若與其left child、right child之Key有以下關係(若pointer指向&lt;code&gt;NULL&lt;/code&gt;則忽略)：&lt;span class="math"&gt;\(Key(L)&amp;lt;Key(Current)&amp;lt;Key(R)\)&lt;/span&gt;，則可稱這棵樹為Binary Search Tree(BST)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以圖三為例，樹中有三個node，悟空的戰鬥力為1000，龜仙人的戰鬥力為8，克林的戰鬥力為2，若將龜仙人設為&lt;code&gt;root&lt;/code&gt;，則克林的戰鬥力較小，因此成為龜仙人的left child，悟空的戰鬥力較大，便成為龜仙人的right child，如此便滿足&lt;span class="math"&gt;\(Key(L)&amp;lt;Key(Current)&amp;lt;Key(R)\)&lt;/span&gt;，即可稱圖三為一棵BST。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/Intro/f3.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;有了BST後，便能夠替鳥山明老師處理角色之間的戰鬥力關係了。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="operation"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;在Binary Search Tree中管理資料&lt;/h2&gt;
&lt;p&gt;故事一開始的主要角色有悟空(1000)、龜仙人(8)和克林(2)，以龜仙人為&lt;code&gt;root&lt;/code&gt;能夠建立出一棵BST如圖四：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst1" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/Intro/f14.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;
&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="insert"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;insert(新增資料)&lt;/h3&gt;
&lt;p&gt;隨著故事劇情推進，角色也會跟著增加，因此，要在BST中&lt;strong&gt;新增node(新增資料)&lt;/strong&gt;。&lt;br /&gt;
在此，比克大魔王現身地球危害人間，其戰鬥力為513，欲將其放進BST，根據BST的規則判斷出，比克的戰鬥力比龜仙人高，因此要將比克放在龜仙人的right subtree(右子樹)；接著，再和悟空比較，比克的戰鬥力比悟空低，因此將比克建立在悟空的left child上，如圖五(a)所示：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="insert" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/Intro/f4.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五(a)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;接著，賽亞人王子達爾登場，其戰鬥力為524，根據BST的規則，判斷出其應在「龜仙人的right subtree」、「悟空的left subtree」與比克的「right child」，如圖五(b)所示。&lt;br /&gt;
在下一篇文章將會看到，實際上的演算法正是以這種方式實現：移動&lt;code&gt;CurrentNode&lt;/code&gt;，並將&lt;code&gt;CurrentNode&lt;/code&gt;之Key與「欲新增之node的Key」比較，找到符合BST規則的位置後，置入新的node。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="insert" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/Intro/f5.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五(b)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="search"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;search(搜尋資料)&lt;/h3&gt;
&lt;p&gt;在處理資料時，時常需要尋找某特定資料，是否存在資料結構中。以BST處理資料，最簡單的方式便是用Key尋找。&lt;br /&gt;
以圖六為例，故事推進到納美克星弗力札大王篇，若想要確認基紐隊長的資料是否已經建立完成，只要記住隊長的戰鬥力為「627」，進入BST中，便能夠找到隊長，必且回傳(return)隊長的node。&lt;br /&gt;
有時會出現欲搜尋的資料尚未被建立進BST中、或者已經從BST中移除的情況，例如，若要在悟空變成超級賽亞人之前找克林，以克林的戰鬥力「2」來搜尋，但是發現找不到，便回傳(return)&lt;code&gt;NULL&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;因為克林被弗力札大王給殺死了啊啊阿啊(變身超級賽亞人)。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="search" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/Intro/f16.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖六：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;（界王神的聲音：為什麼&lt;code&gt;root&lt;/code&gt;從龜仙人變成比克？不會違反BST規則嗎？詳見&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-rotationxuan-zhuan.html"&gt;Red Black Tree系列之Rotation(旋轉)&lt;/a&gt;。）&lt;/p&gt;
&lt;p&gt;&lt;a name="sort"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;sort(排序)&lt;/h3&gt;
&lt;p&gt;故事來到了魔人普烏篇，因為角色有點多，有點混亂，此時，若想要知道各角色戰鬥力的大小排序，只要按照&lt;strong&gt;Inorder Traversal&lt;/strong&gt;即可按照戰鬥力(Key)高低列出所有資料：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="sort" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/Intro/f17.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖七：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="delete"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;delete(刪除資料)&lt;/h3&gt;
&lt;p&gt;最後，當角色死掉去領便當，就需要從BST刪除資料，而根據欲刪除資料之「&lt;strong&gt;child個數&lt;/strong&gt;」可以分成三種情況：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;刪除撒旦：撒旦&lt;strong&gt;沒有child&lt;/strong&gt;，因此，直接把撒旦的parent(普烏)之left child指向&lt;code&gt;NULL&lt;/code&gt;即可。&lt;/li&gt;
&lt;li&gt;刪除弗力札：弗力札有&lt;strong&gt;一個child&lt;/strong&gt;(left child)，因此刪除弗力札之前，需要先把弗力札的left child(基紐)接到弗力札的parent(龜仙人)上，又因為弗力札原本是龜仙人的right child，因此基紐將遞補弗力札，成為龜仙人的right child。&lt;/li&gt;
&lt;li&gt;刪除西魯：西魯有&lt;strong&gt;兩個child&lt;/strong&gt;，稍微麻煩一點，需要「多一個步驟」，將留待之後的文章做詳細說明。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="delete" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/Intro/f15.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖八：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;以上便是BST與BST中的基本操作之介紹，所有操作都是以BST之特徵：&lt;span class="math"&gt;\(Key(L)&amp;lt;Key(Current)&amp;lt;Key(R)\)&lt;/span&gt;為出發點，尤其是新增node與刪除node，務必要滿足BST之規則。&lt;/p&gt;
&lt;p&gt;接下來，將以兩篇文章的篇幅，說明上述四種資料處理操作的演算法。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a name="ref"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;參考資料：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844"&gt;Introduction to Algorithms&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376"&gt;Fundamentals of Data Structures in C++&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://zh.wikipedia.org/wiki/%E4%B8%83%E9%BE%99%E7%8F%A0#.E5.8A.87.E5.A0.B4.E7.89.88"&gt;Wikipedia：七龍珠&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.imdb.com/title/tt1178663/"&gt;IMDB：Whatever Works&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="tree_series"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Tree系列文章&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/treeshu-introjian-jie.html"&gt;Tree(樹): Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-introjian-jie.html"&gt;Binary Tree: Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-traversalxun-fang.html"&gt;Binary Tree: Traversal(尋訪)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-jian-li-yi-ke-binary-tree.html"&gt;Binary Tree: 建立一棵Binary Tree&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-introjian-jie.html"&gt;Binary Search Tree: Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-searchsou-xun-zi-liao-insertxin-zeng-zi-liao.html"&gt;Binary Search Tree: Search(搜尋資料)、Insert(新增資料)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-sortpai-xu-deleteshan-chu-zi-liao.html"&gt;Binary Search Tree: Sort(排序)、Delete(刪除資料)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-introjian-jie.html"&gt;Red Black Tree: Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-rotationxuan-zhuan.html"&gt;Red Black Tree: Rotation(旋轉)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-insertxin-zeng-zi-liao-yu-fixupxiu-zheng.html"&gt;Red Black Tree: Insert(新增資料)與Fixup(修正)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-deleteshan-chu-zi-liao-yu-fixupxiu-zheng.html"&gt;Red Black Tree: Delete(刪除資料)與Fixup(修正)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;  &lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="C++"></category><category term="Binary Search Tree(二元搜尋樹)"></category><category term="Intro"></category></entry><entry><title>Binary Tree: 建立一棵Binary Tree</title><link href="http://alrightchiu.github.io/SecondRound/binary-tree-jian-li-yi-ke-binary-tree.html" rel="alternate"></link><updated>2015-12-27T16:53:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2015-12-27:SecondRound/binary-tree-jian-li-yi-ke-binary-tree.html</id><summary type="html">&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;先備知識與注意事項&lt;/h3&gt;
&lt;p&gt;在&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-traversal.html#ex_code"&gt;Binary Tree：Traversal&lt;/a&gt;中，非常沒誠意地用暴力方式建了一棵Binary Tree，在這裡至上深深歉意，因此，在本篇文章將提供一種方法，由一個字元陣列(char array)輸入字母，並按照&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-intro.html#fullcomplete"&gt;Complete Binary Tree&lt;/a&gt;之順序重新建立&lt;em&gt;那顆樹&lt;/em&gt;(一種不健康的雪恥心態)。&lt;/p&gt;
&lt;p&gt;其中，問題情境之原始資料是一個字元陣列(char array)，為了方便處理(偷懶)選擇使用C++語言中的神器：&lt;a href="http://www3.ntu.edu.sg/home/ehchua/programming/cpp/cp10_io.html"&gt;stringstream&lt;/a&gt;，這裡礙於篇幅與主題(與筆者自己也還在摸索)，就不多談避免誤導，&lt;a href="(http://www3.ntu.edu.sg/home/ehchua/programming/cpp/cp10_io.html)"&gt;點進連結中&lt;/a&gt;有非常詳細的說明，關於&lt;code&gt;istringstream&lt;/code&gt;、&lt;code&gt;ostringstream&lt;/code&gt;、&lt;code&gt;stringstream&lt;/code&gt;等等template class之繼承關係(inheritance)。&lt;br /&gt;
重點是，&lt;code&gt;stringstream&lt;/code&gt;就是神，就是行，學起來簡直光宗耀祖。&lt;/p&gt;
&lt;p&gt;以及，以下提供的Binary Tree之建立方法，基本上是在&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-traversal.html#ex_code"&gt;Binary Tree：Traversal介紹過的level-order traversal&lt;/a&gt;上加油添醋，因此&lt;a href="https://en.wikipedia.org/wiki/Queue_%28abstract_data_type%29"&gt;queue(佇列)&lt;/a&gt;的概念會再次出現。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#description"&gt;問題描述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#code"&gt;程式碼&lt;/a&gt;   &lt;ul&gt;
&lt;li&gt;&lt;a href="#def"&gt;定義class TreeNode、class BinaryTree&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="#constructor"&gt;Constructor of BinaryTree&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="#func1"&gt;Function：LevelorderConstruct()&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#func2"&gt;Function：insertLevelorder()&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#ref"&gt;參考資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#tree_series"&gt;Tree系列文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="description"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;問題描述&lt;/h2&gt;
&lt;p&gt;問題描述如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;給定一個字元陣列，欲按照Complete Binary Tree之位置規則建立一棵Binary Tree，若陣列元素之資料為大寫字母(ASCII：65~90)，則將其建立成Tree的node，若陣列元素為 ' x ' 則表示該位置沒有node。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-traversal.html#ex_code"&gt;Binary Tree：Traversal&lt;/a&gt;中所提到的Binary Tree為例，如圖一：
&lt;/br&gt;&lt;br /&gt;
&lt;center&gt;
&lt;img alt="binary tree" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/ex.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;   &lt;/p&gt;
&lt;p&gt;其所對應的字元陣列即為：&lt;code&gt;A B C D E F x x x G H x I&lt;/code&gt;，如圖二所示：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="binary tree of char array" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/ex_char.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt; &lt;/p&gt;
&lt;p&gt;以下程式範例的目的就是要以如此文明的方式建立出如圖一的Binary Tree。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="code"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;程式碼&lt;/h2&gt;
&lt;p&gt;先看看&lt;code&gt;main()&lt;/code&gt;中，上半部分別為：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原始資料：字元陣列；&lt;/li&gt;
&lt;li&gt;以該字元陣列實體化(instantiate)一棵Binary Tree，本篇重點在此；&lt;/li&gt;
&lt;li&gt;以inorder traversal印出樹的資料。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下半部則是示範以&lt;code&gt;queue&lt;/code&gt;實現level-order traversal之小應用：以Complete Binary Tree之位置規則在樹中新增node。  &lt;/p&gt;
&lt;p&gt;溫馨小提醒：純粹以inorder traversal之結果並無法驗證樹之結構正如圖一(舉例來說：以inorder traversal對某一Linked list也可能得出相同結果)，因此，建議還是使用IDE的debug功能把pointer全部攤開。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;sstream&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;queue&amp;gt;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;A B C D E F x x x G H x I&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;BinaryTree&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Inorder_by_parent&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;insertLevelorder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;K&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;insertLevelorder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;L&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;insertLevelorder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;M&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;insertLevelorder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;N&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Inorder_by_parent&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在經過一連串程式碼後，預期得到的output：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;D&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt; &lt;span class="n"&gt;G&lt;/span&gt; &lt;span class="n"&gt;E&lt;/span&gt; &lt;span class="n"&gt;H&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="n"&gt;F&lt;/span&gt; &lt;span class="n"&gt;I&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt;   
&lt;span class="n"&gt;L&lt;/span&gt; &lt;span class="n"&gt;D&lt;/span&gt; &lt;span class="n"&gt;M&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt; &lt;span class="n"&gt;G&lt;/span&gt; &lt;span class="n"&gt;E&lt;/span&gt; &lt;span class="n"&gt;H&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt; &lt;span class="n"&gt;F&lt;/span&gt; &lt;span class="n"&gt;I&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt; &lt;span class="n"&gt;K&lt;/span&gt;    
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;/br&gt; &lt;/p&gt;
&lt;p&gt;&lt;a name="def"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;定義class TreeNode、class BinaryTree&lt;/h3&gt;
&lt;p&gt;幾點說明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;這裡對&lt;code&gt;class TreeNode&lt;/code&gt;與&lt;code&gt;class BinaryTree&lt;/code&gt;之定義，與&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-traversal.html#ex_code"&gt;上一篇文章&lt;/a&gt;之最大不同在於資料的隱蔽性，因為在此不需要於&lt;code&gt;main()&lt;/code&gt;中存取任何pointer(&lt;code&gt;root&lt;/code&gt;、&lt;code&gt;leftchild&lt;/code&gt;、&lt;code&gt;rightchild&lt;/code&gt;)，因此將之放進&lt;strong&gt;private&lt;/strong&gt;區塊。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在許多traversal中，時常以pointer不為&lt;code&gt;NULL&lt;/code&gt;作為&lt;code&gt;while&lt;/code&gt;的判斷式，因此在constructor中，多做一步，將pointer指向&lt;code&gt;NULL&lt;/code&gt;(eg：&lt;code&gt;leftchild = 0&lt;/code&gt;)避免埋地雷在日後炸自己。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在&lt;code&gt;class BinaryTree&lt;/code&gt;除了上一篇介紹過的inorder traversal外，多了兩個新朋友&lt;code&gt;LevelorderConstruct()&lt;/code&gt;與&lt;code&gt;insertLevelorder()&lt;/code&gt;，前者即是本篇主角，吃進&lt;code&gt;stringstream&lt;/code&gt;後，把樹建出來；後者純粹是好玩，其功能為「以Complete Binary Tree之位置規則，在理應出現node的位置，新增node」，能夠儘量減少在新增node時增加樹高(height)。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;看下去。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;BinaryTree&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt; &lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;

    &lt;span class="k"&gt;friend&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;BinaryTree&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;BinaryTree&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;BinaryTree&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;};&lt;/span&gt;
    &lt;span class="n"&gt;BinaryTree&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;LevelorderConstruct&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;stringstream&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;ss&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;insertLevelorder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nf"&gt;leftmost&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nf"&gt;InorderSuccessor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Inorder_by_parent&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;/br&gt;  &lt;/p&gt;
&lt;p&gt;&lt;a name="constructor"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Constructor of BinaryTree&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;class BinaryTree&lt;/code&gt;的constructor很直觀，拿到一個字元陣列，先送進&lt;code&gt;stringstream&lt;/code&gt;後，再由&lt;code&gt;stringstream&lt;/code&gt;放進樹中，先對樹的&lt;code&gt;root&lt;/code&gt;進行記憶體配置以及賦值，接著以level-order的方式建立Binary Tree。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="n"&gt;BinaryTree&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;BinaryTree&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;stringstream&lt;/span&gt;  &lt;span class="n"&gt;ss&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;ss&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;root&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;ss&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;LevelorderConstruct&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ss&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="func1"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Function：LevelorderConstruct()&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;在看&lt;code&gt;LevelorderConstruct()&lt;/code&gt;的函式主體之前，再看一眼&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-traversal.html#level"&gt;level-order traversal&lt;/a&gt;，概念上即是藉著&lt;code&gt;queue&lt;/code&gt;的「先排隊就先購票」的特性，在同一個level中，只要確保由左至右將node放進&lt;code&gt;queue&lt;/code&gt;中，便能確保在進入下一個level後，以先前放入node之順序進行visiting。  &lt;/li&gt;
&lt;li&gt;在&lt;code&gt;while&lt;/code&gt;內，新增條件用來判斷從&lt;code&gt;stringstream&lt;/code&gt;中輸出的字母是「大寫字母」(ASCII：65~90)還是「x」，前者要放入樹中建成node，後者則忽略不計。  &lt;/li&gt;
&lt;li&gt;整份程式碼的關鍵在於神器&lt;code&gt;stringstream &amp;amp;ss&lt;/code&gt;，只要不斷地透過&lt;code&gt;ss &amp;gt;&amp;gt; data&lt;/code&gt;，&lt;code&gt;ss&lt;/code&gt;便會自動尋找下一筆資料餵進&lt;code&gt;data&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;最後，當&lt;code&gt;stringstream&lt;/code&gt;不再更新&lt;code&gt;data&lt;/code&gt;時，也就是字元陣列已全數讀取完畢，即跳出&lt;code&gt;while&lt;/code&gt;迴圈。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;步驟如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，在Binary Tree的constructor中，先配置&lt;code&gt;root&lt;/code&gt;的記憶體位置，並透過第一次&lt;code&gt;ss &amp;gt;&amp;gt; root-&amp;gt;data&lt;/code&gt;將第一個字母放進&lt;code&gt;root&lt;/code&gt;中，如圖三(a)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="construct_0" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/construct0.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(a)：從ss取出第一個字母'A'放進&lt;code&gt;root&lt;/code&gt;。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt; &lt;/p&gt;
&lt;p&gt;接著進入&lt;code&gt;while&lt;/code&gt;迴圈。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;條件式：&lt;code&gt;ss &amp;gt;&amp;gt; data&lt;/code&gt;若為真，表示成功從&lt;code&gt;ss&lt;/code&gt;中取出字母，傳進&lt;code&gt;data&lt;/code&gt;。  &lt;/li&gt;
&lt;li&gt;進入迴圈後，先判斷取出的字母若為大寫字母(在此為&lt;strong&gt;'B'&lt;/strong&gt;)，即生成一個新的&lt;code&gt;new_node&lt;/code&gt;，將B放進&lt;code&gt;new_node&lt;/code&gt;中，並將&lt;code&gt;CurrentNode&lt;/code&gt;(在此為A)的left child指向&lt;code&gt;new_node&lt;/code&gt;，如圖三(b)。  &lt;/li&gt;
&lt;li&gt;在&lt;code&gt;queue&lt;/code&gt;  的部分，若成功建立出新的node(此為B)，便把B放進&lt;code&gt;queue&lt;/code&gt;的隊伍中，表示之後將要把&lt;code&gt;CurrentNode&lt;/code&gt;移到B，繼續往下建立新的node。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt; 
&lt;img alt="construct_1" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/construct1.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(b)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt; &lt;/p&gt;
&lt;p&gt;在同一個迴圈裡，建立完&lt;code&gt;CurrentNode&lt;/code&gt;的left child後，接著嘗試建立right child。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;條件式：&lt;code&gt;if( !(ss &amp;gt;&amp;gt; data) )&lt;/code&gt;若為真，表示&lt;code&gt;ss&lt;/code&gt;中的字母已經讀取完畢，即跳出迴圈(&lt;code&gt;break&lt;/code&gt;)。若否，則繼續從&lt;code&gt;ss&lt;/code&gt;中讀取字母。&lt;/li&gt;
&lt;li&gt;判斷字母是否為大寫字母(此為&lt;strong&gt;'C'&lt;/strong&gt;)，便如同生成left child之方法，建立新的&lt;code&gt;new_node&lt;/code&gt;、配置記憶體、將字母&lt;strong&gt;'C'&lt;/strong&gt;放進&lt;code&gt;new_node&lt;/code&gt;中，並將&lt;code&gt;CurrentNode&lt;/code&gt;之right child指向&lt;code&gt;new_node&lt;/code&gt;，如圖三(c)。&lt;/li&gt;
&lt;li&gt;已成功建立新的node(C)，便把C放進&lt;code&gt;queue&lt;/code&gt;的隊伍中，表示之後將要把&lt;code&gt;CurrentNode&lt;/code&gt;移到B，繼續往下建立新的node。
此時，&lt;code&gt;queue&lt;/code&gt;裡有兩個node，分別為B與C，要注意的是，排隊時，先進入隊伍的人會代表隊伍的前方，因此B為&lt;code&gt;queue&lt;/code&gt;的&lt;strong&gt;Front&lt;/strong&gt;，C為&lt;code&gt;queue&lt;/code&gt;的&lt;strong&gt;Back&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="construct_2" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/construct2.png?raw=true" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(c)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt; &lt;/p&gt;
&lt;p&gt;在建立完&lt;code&gt;CurrentNode&lt;/code&gt;的left child與right child後，接著要移動&lt;code&gt;CurrentNode&lt;/code&gt;，作為下一個&lt;code&gt;while&lt;/code&gt;迴圈的起點。&lt;br /&gt;
&lt;code&gt;queue&lt;/code&gt;的功能便是提供&lt;code&gt;CurrentNode&lt;/code&gt;移動的依據：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一律將&lt;code&gt;queue&lt;/code&gt;隊伍的第一個node視作新的&lt;code&gt;CurrentNode&lt;/code&gt;：&lt;code&gt;CurrentNode = q.front()&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;CurrentNode&lt;/code&gt;移動至B後，便把B從&lt;code&gt;queue&lt;/code&gt;移除：&lt;code&gt;q.pop()&lt;/code&gt;，如圖三(d)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如此便能保證，&lt;code&gt;CurrentNode&lt;/code&gt;的移動會依照level-order「由上至下、由左至右」之順序。
&lt;/br&gt;&lt;br /&gt;
&lt;center&gt;
&lt;img alt="construct_3" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/construct3.png?raw=true" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(d)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt; &lt;/p&gt;
&lt;p&gt;進入第二次&lt;code&gt;while&lt;/code&gt;迴圈後，重複以上之步驟：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;從&lt;code&gt;ss&lt;/code&gt;取出字母，放進&lt;code&gt;data&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;判斷&lt;code&gt;data&lt;/code&gt;是否為大寫，若是，便依序在&lt;code&gt;CurrentNode&lt;/code&gt;之left child與right child建立新的node。&lt;/li&gt;
&lt;li&gt;並且，將成功建立之node放進&lt;code&gt;queue&lt;/code&gt;隊伍中，用作之後&lt;code&gt;CurrentNode&lt;/code&gt;移動之用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;仔細觀察圖三(e)至圖三(h)之&lt;code&gt;ss&lt;/code&gt;與&lt;code&gt;CurrentNode&lt;/code&gt;之移動，與&lt;code&gt;queue&lt;/code&gt;的變化：
&lt;/br&gt;&lt;br /&gt;
&lt;center&gt;
&lt;img alt="construct_4" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/construct4.png?raw=true" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(e)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt; &lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="construct_5" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/construct5.png?raw=true" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(f)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt; &lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="construct_6" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/construct6.png?raw=true" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(g)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt; &lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="construct_7" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/construct7.png?raw=true" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(h)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在建立完C的left child後，從&lt;code&gt;ss&lt;/code&gt;讀取到字母&lt;strong&gt;'x'&lt;/strong&gt;，因為其並非大寫字母，表示C沒有right child，因此跳過生成新的node之步驟，如圖三(i)。  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="construct_8" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/construct8.png?raw=true" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(i)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt; &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若沒有生成新的node，便沒有新的node進入&lt;code&gt;queue&lt;/code&gt;排隊。&lt;/li&gt;
&lt;li&gt;接著要繼續將&lt;code&gt;CurrentNode&lt;/code&gt;移動到&lt;code&gt;queue&lt;/code&gt;的第一個元素，也就是D，並把D從&lt;code&gt;queue&lt;/code&gt;中移除，如圖三(j)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="construct_9" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/construct9.png?raw=true" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(j)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;當&lt;code&gt;CurrentNode&lt;/code&gt;移動到D之後，&lt;code&gt;ss&lt;/code&gt;連續放兩個&lt;strong&gt;'x'&lt;/strong&gt;進入&lt;code&gt;data&lt;/code&gt;，表示D的兩個child pointer皆指向&lt;code&gt;NULL&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;由於沒有新的node產生，&lt;code&gt;queue&lt;/code&gt;的隊伍便沒有更新，如圖三(k)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="construct_10" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/construct10.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(k)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt; &lt;/p&gt;
&lt;p&gt;接著，重複步驟：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;移動&lt;code&gt;CurrentNode&lt;/code&gt;至&lt;code&gt;queue&lt;/code&gt;的第一個元素所指示的node。&lt;/li&gt;
&lt;li&gt;從&lt;code&gt;ss&lt;/code&gt;讀取字母，判斷其為大寫字母，生成新的node接在&lt;code&gt;CurrentNode&lt;/code&gt;的child pointer上。&lt;/li&gt;
&lt;li&gt;若有生成新的node，則將該node推入&lt;code&gt;queue&lt;/code&gt;的隊伍。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="construct_11" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/construct11.png?raw=true" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(l)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt; &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;直到&lt;code&gt;ss&lt;/code&gt;輸出最後一個字母&lt;strong&gt;'I'&lt;/strong&gt;後，這棵樹便建立完成。&lt;/li&gt;
&lt;li&gt;由於，&lt;code&gt;ss&lt;/code&gt;已全數讀取完畢，敘述句：&lt;code&gt;ss &amp;gt;&amp;gt; data&lt;/code&gt;不成立，因此結束迴圈。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="construct_12" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/construct12.png?raw=true" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(m)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt; &lt;/p&gt;
&lt;p&gt;&lt;/br&gt;  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;BinaryTree&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;LevelorderConstruct&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;stringstream&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;ss&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;queue&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="o"&gt;*&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;x&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ss&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;65&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;90&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
            &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;new_node&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  &lt;span class="c1"&gt;// call constructor TreeNode(char s)&lt;/span&gt;
            &lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ss&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
            &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;65&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;90&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
            &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;new_node&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;        &lt;span class="c1"&gt;// call constructor TreeNode()&lt;/span&gt;
            &lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;front&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pop&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;/br&gt;
&lt;a name="func2"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Function：insertLevelorder()&lt;/h3&gt;
&lt;p&gt;函式&lt;code&gt;insertLevelorder()&lt;/code&gt;的功能是，能夠按照Complete Binary Tree的位置順序放置新增的node，例如，若要在圖三之樹上新增帶有字母&lt;strong&gt;'K'&lt;/strong&gt;的node，則&lt;code&gt;T.insertLevelorder('K')&lt;/code&gt;便會將&lt;strong&gt;'K'&lt;/strong&gt;建成C的right child，如圖四(a)：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="insertK" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/insertK.png?raw=true" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四(a)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt; &lt;/p&gt;
&lt;p&gt;再依序新增L、M、N：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;T.insertLevelorder('L')&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;T.insertLevelorder('M')&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;T.insertLevelorder('N')&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;即會得到如圖四(b)的樹：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="insertLMN" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/insertLMN.png?raw=true" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四(b)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt; &lt;/p&gt;
&lt;p&gt;程式碼之邏輯與&lt;code&gt;LevelorderConstruct&lt;/code&gt;大同小異，最主要的部分就是利用&lt;code&gt;queue&lt;/code&gt;來記錄&lt;code&gt;CurrentNode&lt;/code&gt;移動的順序：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，將&lt;code&gt;current&lt;/code&gt;設成&lt;code&gt;root&lt;/code&gt;，若樹存在，則進入&lt;code&gt;while&lt;/code&gt;迴圈。&lt;/li&gt;
&lt;li&gt;接著判斷，若&lt;code&gt;current&lt;/code&gt;之left child已經有node，則將之放入&lt;code&gt;queue&lt;/code&gt;中，在下次迴圈將以此node作為&lt;code&gt;current&lt;/code&gt;，若left child還沒有node，便產生帶有&lt;code&gt;data&lt;/code&gt;之新node，並將其建立成&lt;code&gt;current&lt;/code&gt;之left child。&lt;br /&gt;
pointer連接完成後，結束迴圈。&lt;/li&gt;
&lt;li&gt;對&lt;code&gt;current&lt;/code&gt;之right child進行相同之步驟。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如此便能有效控制Binary Tree之樹高(height)，使pointer所配置之記憶體空間有效利用，亦能夠減少traversal(以及其他操作)所需的時間。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;BinaryTree&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;insertLevelorder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;    
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;queue&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="o"&gt;*&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;new_node&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;new_node&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;front&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pop&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;/br&gt;&lt;br /&gt;
以上便是利用&lt;code&gt;queue&lt;/code&gt;執行level-order方式建立Binary Tree之範例。&lt;br /&gt;
另外，&lt;a href="http://www.geeksforgeeks.org/level-order-tree-traversal/"&gt;有些方法是利用遞迴的方式，外帶一個迴圈來進行level-order traversal&lt;/a&gt;，也能夠完成相同的功能。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a name="ref"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;參考資料：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844"&gt;Introduction to Algorithms&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376"&gt;Fundamentals of Data Structures in C++&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www3.ntu.edu.sg/home/ehchua/programming/cpp/cp10_io.html"&gt;C++ Programming Language：Stream IO and File IO&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.geeksforgeeks.org/level-order-tree-traversal/"&gt;GeeksforGeeks：Level Order Tree Traversal&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="tree_series"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Tree系列文章&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/treeshu-introjian-jie.html"&gt;Tree(樹): Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-introjian-jie.html"&gt;Binary Tree: Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-traversalxun-fang.html"&gt;Binary Tree: Traversal(尋訪)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-jian-li-yi-ke-binary-tree.html"&gt;Binary Tree: 建立一棵Binary Tree&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-introjian-jie.html"&gt;Binary Search Tree: Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-searchsou-xun-zi-liao-insertxin-zeng-zi-liao.html"&gt;Binary Search Tree: Search(搜尋資料)、Insert(新增資料)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-sortpai-xu-deleteshan-chu-zi-liao.html"&gt;Binary Search Tree: Sort(排序)、Delete(刪除資料)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-introjian-jie.html"&gt;Red Black Tree: Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-rotationxuan-zhuan.html"&gt;Red Black Tree: Rotation(旋轉)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-insertxin-zeng-zi-liao-yu-fixupxiu-zheng.html"&gt;Red Black Tree: Insert(新增資料)與Fixup(修正)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-deleteshan-chu-zi-liao-yu-fixupxiu-zheng.html"&gt;Red Black Tree: Delete(刪除資料)與Fixup(修正)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;</summary><category term="C++"></category><category term="Binary Tree(二元樹)"></category></entry><entry><title>Binary Tree: Traversal(尋訪)</title><link href="http://alrightchiu.github.io/SecondRound/binary-tree-traversalxun-fang.html" rel="alternate"></link><updated>2015-12-24T22:41:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2015-12-24:SecondRound/binary-tree-traversalxun-fang.html</id><summary type="html">&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;先備知識與注意事項&lt;/h3&gt;
&lt;p&gt;traversal(尋訪)有「站在A地，往所有與A地相連的地方移動」的意思：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以Graph(圖)的語言來說，站在vertex A上，有一條edge連結A與B，若能夠由A往B移動，此即可視為traversal；&lt;/li&gt;
&lt;li&gt;在以pointer實現之Linked list和Tree中，站在node A上，A具有指向B之pointer，因此能夠由A往B移動，此即可視為traversal。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;移動到特定的node之後，通常伴隨著其他行為，例如print out(顯示資料)、assign(賦值)等等，這些操作又稱作Visiting。&lt;/p&gt;
&lt;p&gt;在閱讀本篇之前，建議先閱讀&lt;a href="http://alrightchiu.github.io/SecondRound/linked-list-traversal.html"&gt;Linked List: Traversal&lt;/a&gt;作簡單複習。在Linked list與Tree中的traversal於pointer的操作概念上完全相同，不過由於Node的pointer增加了，於是從一維的移動拓展到二維的移動。&lt;br /&gt;
本篇文章將介紹在Binary Tree中的四種traversal方法。  &lt;/p&gt;
&lt;p&gt;另外，根據不同的程式實作方法，可能會使用上&lt;a href="https://en.wikipedia.org/wiki/Stack_%28abstract_data_type%29"&gt;stack(堆疊)&lt;/a&gt;與&lt;a href="https://en.wikipedia.org/wiki/Queue_%28abstract_data_type%29"&gt;queue(佇列)&lt;/a&gt;，如果熟悉的話，那就會很酷。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#bttraversal"&gt;Traversal in Binary Tree&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#ex_code"&gt;Example with Code&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#pre"&gt;Pre-Order Traversal&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#in"&gt;In-Order Traversal&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#post"&gt;Post-Order Traversal&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#level"&gt;Level-Order Traversal&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#in_parent"&gt;In-Order Traversal by Parent Field&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#successor"&gt;Successor、leftmost&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#predecessor"&gt;Predecessor、rightmost&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#ref"&gt;參考資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#tree_series"&gt;Tree系列文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="bttraversal"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Traversal in Binary Tree&lt;/h2&gt;
&lt;p&gt;Binary Tree的Node具有兩個指向child的pointer，Traversal以「當前所在的node」為參考點，所能夠進行的移動有三種：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;V&lt;/strong&gt;：Visiting，對當前所在的node進行print、assign或其他操作。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;L&lt;/strong&gt;：移動到left child。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;R&lt;/strong&gt;：移動到right child。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="VLR" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/VLR.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一：CurrentNode位在A，leftchild與rightchild分別為B與C。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;   &lt;/p&gt;
&lt;p&gt;以圖一為例，假設現在CurrentNode位在A，leftchild與rightchild分別為B與C，並加上一項限制：「L一定在R之前」，便能產生三種相對關係：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="VLR_pre" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/VLR_pre.png?raw=true" /&gt; &lt;img alt="LVR_in" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/VLR_in.png?raw=true" /&gt; &lt;img alt="LRV_post" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/VLR_post.png?raw=true" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(a)-(c) 依序為： (a)pre-order：VLR、(b)in-order：LVR、(c)post-order：LRV&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;pre-order(VLR)&lt;/strong&gt;：當CurrentNode移動到A時，會先對A進行Visiting，接著前往left child進行Visiting，再前往right child進行Visiting。(若child指向NULL則忽略。)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;in-order(LVR)&lt;/strong&gt;：當CurrentNode移動到A時，會先對A的left child(B)進行Visiting，接著回到A進行Visiting，再前往right child(C)進行Visiting。(若child指向NULL則忽略。)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;post-order(LRV)&lt;/strong&gt;：當CurrentNode移動到A時，會先對A的left child(B)進行Visiting，再前往right child(C)進行Visiting，接著回到A進行Visiting。(若child指向NULL則忽略。)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;
現有一棵樹如圖三(a)，欲進行post-order traversal，並將Visiting用作print(顯示資料)：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bt_a" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/bt_0.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(a)&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;   &lt;/p&gt;
&lt;p&gt;小小備註：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;以下圖例中，V表示CurrentNode所在的node，標上數字後表示已經Visiting，以print(顯示資料)為例，標上"1"表示該node第一個被印出。&lt;/li&gt;
&lt;li&gt;以下文字說明，將使用scope(視野範圍)的概念，用來表示以每個V(CurrentNode)為中心，與其所能夠指向之pointer所構成的範圍(等同於迴圈(或者函式呼叫)的scope)。因為每個迴圈都會改變V(CurrentNode)的位置，因此scope會以V(CurrentNode)為中心不停移動，直到迴圈結束。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;post-order traversal流程如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一開始，CurrentNode進到A(root)，按照post-order的順序規則(LRV)，先檢查B(left child)是否為NULL，若不是，則先移動到B(L)：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bt_b" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/bt_1.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(b)：scope內：A(V)、B(L)、C(R)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;當CurrentNode移動到B，再一次執行post-order的順序規則，檢查D(left child)是否為NULL，若不是，則移動到D(L)：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bt_c" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/bt_2.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(c)：scope內：B(V)、D(L)、E(R)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;當CurrentNode移動到D，再一次執行post-order的順序規則，檢查出D的left child與right child皆為NULL，則回到D做Visiting，在此即印出D(print)，並回到B。  &lt;/li&gt;
&lt;li&gt;回到B的動作發生，即表示「以D為CurrentNode之迴圈或函式已經結束」，於是回到尚未結束的「以B為CurrentNode」之scope。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bt_d" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/bt_3.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(d)：scope內：D(V)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;D已經進行過Visiting，便標上數字"1"，表示D為traversal的第一站。&lt;br /&gt;
接著，在「以B為CurrentNode」的scope中，根據post-order規則，繼續往E(R)移動。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bt_e" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/bt_4.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(e)：scope內：B(V)、D(L)、E(R)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;進入E後，因為E為leaf node，因此過程如圖三(d)，不會進入NULL。&lt;br /&gt;
在D(L)與E(R)都Visiting過後，便回到B(V)進行Visiting，並標上數字。  &lt;/li&gt;
&lt;li&gt;接著回到「以A為CurrentNode」的程序(procedure)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bt_f" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/bt_5.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(f)：scope內：B(V)、D(L)、E(R)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;回到「以A為CurrentNode」的scope後，按照post-order的規則，接著往C(R)移動。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bt_g" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/bt_6.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(g)：scope內：A(V)、B(L)、C(R)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同樣地步驟，再從C移動至F(L)，並發現F為leaf node，於是對F進行Visiting，並標上數字。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bt_h" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/bt_7.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(h)：scope內：C(V)、F(L)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;列出F後，發現C的right child指向NULL，於是略過right child(R)，回到C(V)，並對C進行Visiting，標上數字。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bt_i" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/bt_8.png?raw=true" /&gt;&lt;img alt="bt_j" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/bt_9.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(i)-(j)：scope內：C(V)、F(L)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最後回到「以A為CurrentNode」的scope，對A(V)進行Visiting，便完成了此次post-order traversal，並依序印出&lt;code&gt;D E B F C A&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bt_k" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/bt_10.png?raw=true" /&gt;&lt;img alt="bt_l" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/bt_11.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(k)-(l)：scope內：A(V)、B(L)、C(R)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;以上說明了post-order traversal之過程，另外兩種pre-order與in-order在概念上皆相同，只要把握順序規則即可。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="ex_code"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Example with Code&lt;/h2&gt;
&lt;p&gt;接下來，再以一棵稍微複雜的Binary Tree作為範例，展示pre-order、in-order、post-order及level-order之traversal。&lt;/p&gt;
&lt;p&gt;現有一棵樹如圖四(a)：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="ex" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/ex.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四(a)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;並以最暴力的方式建立&lt;code&gt;TreeNode&lt;/code&gt;與&lt;code&gt;BinaryTree&lt;/code&gt;之物件(object)：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;string&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;queue&amp;gt;&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;BinaryTree&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
        &lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;};&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;};&lt;/span&gt;

    &lt;span class="k"&gt;friend&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;BinaryTree&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;BinaryTree&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;         &lt;span class="c1"&gt;// 以root作為存取整棵樹的起點&lt;/span&gt;
    &lt;span class="n"&gt;BinaryTree&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;};&lt;/span&gt;
    &lt;span class="n"&gt;BinaryTree&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;){};&lt;/span&gt;

    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Preorder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Inorder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Postorder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Levelorder&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="c1"&gt;// definition of BinaryTree::Preorder()&lt;/span&gt;
&lt;span class="c1"&gt;// definition of BinaryTree::Inorder()&lt;/span&gt;
&lt;span class="c1"&gt;// definition of BinaryTree::Postorder()&lt;/span&gt;
&lt;span class="c1"&gt;// definition of BinaryTree::Levelorder()&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// TreeNode instantiation&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;A&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;B&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;B&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;C&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;D&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;D&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;E&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;E&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;F&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;F&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;G&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;G&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;H&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;H&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;I&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;I&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="c1"&gt;// construct the Binary Tree&lt;/span&gt;
    &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; 
    &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;D&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;E&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; 
    &lt;span class="n"&gt;E&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;G&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;E&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;H&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; 
    &lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;F&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;F&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;I&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;BinaryTree&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Preorder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Inorder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Postorder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Levelorder&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上面的程式碼包含了幾個部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;class TreeNode的定義；&lt;/li&gt;
&lt;li&gt;class BinaryTree的定義，其中有四個member function分別為四種traversal；&lt;/li&gt;
&lt;li&gt;main()中建立如圖四(a)的樹，並在&lt;strong&gt;line54 - line61&lt;/strong&gt;執行四種traversal。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;尚缺的四個函式的定義(definition)請接著看下去。&lt;br /&gt;
其中，pre-order、in-order、post-order traversal的邏輯就只是「V」、「L」、「R」誰先誰後的差別，以下程式碼是以較直覺的遞迴(recursion)形式完成，不過，換成迭代(iteration)配合&lt;a href="https://en.wikipedia.org/wiki/Stack_%28abstract_data_type%29"&gt;stack(堆疊)&lt;/a&gt;在概念上完全相同，實作上即是考慮「V」、「L」、「R」誰先push(推)進stack。  &lt;/p&gt;
&lt;p&gt;&lt;a name="pre"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Pre-Order Traversal&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;BinaryTree&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Preorder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot; &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="c1"&gt;// V&lt;/span&gt;
        &lt;span class="n"&gt;Preorder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;       &lt;span class="c1"&gt;// L&lt;/span&gt;
        &lt;span class="n"&gt;Preorder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;      &lt;span class="c1"&gt;// R&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;output:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt; &lt;span class="n"&gt;D&lt;/span&gt; &lt;span class="n"&gt;E&lt;/span&gt; &lt;span class="n"&gt;G&lt;/span&gt; &lt;span class="n"&gt;H&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt; &lt;span class="n"&gt;F&lt;/span&gt; &lt;span class="n"&gt;I&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;center&gt;
&lt;img alt="ex_pre" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/ex_pre.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四(b)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="in"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;In-Order Traversal&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;BinaryTree&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Inorder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;Inorder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;        &lt;span class="c1"&gt;// L&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot; &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="c1"&gt;// V&lt;/span&gt;
        &lt;span class="n"&gt;Inorder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;       &lt;span class="c1"&gt;// R&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;output:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;D&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt; &lt;span class="n"&gt;G&lt;/span&gt; &lt;span class="n"&gt;E&lt;/span&gt; &lt;span class="n"&gt;H&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="n"&gt;F&lt;/span&gt; &lt;span class="n"&gt;I&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;center&gt;
&lt;img alt="ex_in" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/ex_in.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四(c)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="post"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Post-Order Traversal&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;BinaryTree&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Postorder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;Postorder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;     &lt;span class="c1"&gt;// L&lt;/span&gt;
        &lt;span class="n"&gt;Postorder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;    &lt;span class="c1"&gt;// R&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot; &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;// V&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;output:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;D&lt;/span&gt; &lt;span class="n"&gt;G&lt;/span&gt; &lt;span class="n"&gt;H&lt;/span&gt; &lt;span class="n"&gt;E&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt; &lt;span class="n"&gt;I&lt;/span&gt; &lt;span class="n"&gt;F&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;center&gt;
&lt;img alt="ex_post" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/ex_post.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四(d)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="level"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Level-Order Traversal&lt;/h3&gt;
&lt;p&gt;先前介紹了pre-order、in-order、post-order的traversal，而level-order則是照著level由小到大的順序，由上而下，並在同一個level由左至右地依序Visiting每個node。
以下提供迭代(iteration)配合&lt;a href="https://en.wikipedia.org/wiki/Queue_%28abstract_data_type%29"&gt;queue(佇列)&lt;/a&gt;實現level-order traversal之程式碼，其邏輯也非常直觀：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以圖四(e)為例，當CurrentNode站在A時，先對A作Visiting，接著檢查是否有left child與right child，若不為NULL，則依序push(推)進queue中，又根據queue「先進先出」(first-in-first-out)的特性，先將B(left child)推入queue，再推入C(right child)，便能確保在下一層level時，是由左至右，先Visiting到B，才Visiting到C。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="ex_level" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/ex_level.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四(e)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;BinaryTree&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Levelorder&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;queue&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="o"&gt;*&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot; &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;empty&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
            &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;front&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pop&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;output:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt; &lt;span class="n"&gt;D&lt;/span&gt; &lt;span class="n"&gt;E&lt;/span&gt; &lt;span class="n"&gt;F&lt;/span&gt; &lt;span class="n"&gt;G&lt;/span&gt; &lt;span class="n"&gt;H&lt;/span&gt; &lt;span class="n"&gt;I&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="in_parent"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;In-Order Traversal by Parent Field&lt;/h2&gt;
&lt;p&gt;在&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-intro.html#code"&gt;Binary Tree：Intro&lt;/a&gt;提到，若在&lt;code&gt;class TreeNode&lt;/code&gt;加入pointer指向其parent node會非常有幫助，其中一項理由正是接下來要介紹的兩個函式：InorderSuccessor()與InorderPredecessor()。&lt;br /&gt;
說文解字時間：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;字首Inorder-，即是按照inorder之順序規則並應用於inorder traversal；&lt;/li&gt;
&lt;li&gt;字尾Successor/ Predecessor，即是「下一個」與「前一個」。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，InorderSuccessor()與InorderPredecessor()便是用來尋找「以inorder順序」進行traversal之下一個與前一個node。&lt;br /&gt;
以圖四(c)為例，若CurrentNode站在H(&lt;code&gt;CurrentNode = H&lt;/code&gt;)，則&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;CurrentNode = InorderSuccessor(CurrentNode)&lt;/code&gt;會將CurrentNode移動至A；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CurrentNode = InorderPredecessor(CurrentNode)&lt;/code&gt;則會將CurrentNode移動至E。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="ex_in" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/ex_in.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四(c)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;特別介紹inorder，一大原因是為了Binary Search Tree(BST)鋪路，在BST中，照著inorder順序印出node，就會得到排序過的資訊(詳見：&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-sortpai-xu-deleteshan-chu-zi-liao.html#binary-search-tree-sortpai-xu-deleteshan-chu-zi-liao"&gt;Binary Search Tree: Sort(排序)、Delete(刪除資料)&lt;/a&gt;)。&lt;br /&gt;
另外，若觀察前面提過的遞迴(recursion)形式之inorder traversal，Visiting被包含在遞迴函式內，這表示若要進行多種不同的Visiting，例如print(顯示資料)、assign(賦值、更新資料)，都需要重新寫一個專門功能的遞迴函式。顯然，把Visiting和Traversal獨立開來會更有效率。&lt;/p&gt;
&lt;p&gt;在看兩個實用的函式之前，有幾件前置作業：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在main()裡建立圖四之Binary Tree的部分，連結node與其parent node之pointer：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="c1"&gt;// inside main()&lt;/span&gt;
    &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;D&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;E&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;D&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;E&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;E&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;G&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;E&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;H&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;G&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;E&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;H&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;E&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;F&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;F&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;F&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;I&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;I&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;F&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;並在&lt;code&gt;class BinaryTree&lt;/code&gt;的定義中加入六個member function(成員函式)：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="c1"&gt;// inside definition of class BinaryTree&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nf"&gt;leftmost&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nf"&gt;rightmost&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nf"&gt;InorderSuccessor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nf"&gt;InorderPredecessor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Inorder_by_parent&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Inorder_Reverse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中，除了&lt;code&gt;InorderSuccessor()&lt;/code&gt;與&lt;code&gt;InorderPredecessor()&lt;/code&gt;之函式主體外，還有&lt;code&gt;leftmost()&lt;/code&gt;和&lt;code&gt;rightmost()&lt;/code&gt;即是找到Binary Tree中最左與最右的node，可有可無，不過學會了很酷；以及&lt;code&gt;Inorder_by_parent()&lt;/code&gt;與&lt;code&gt;Inorder_Reverse()&lt;/code&gt;為用以呼叫&lt;code&gt;InorderSuccessor()&lt;/code&gt;與&lt;code&gt;InorderPredecessor()&lt;/code&gt;的迴圈主體。&lt;/p&gt;
&lt;p&gt;看下去。&lt;/p&gt;
&lt;p&gt;&lt;a name="successor"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Successor、leftmost&lt;/h3&gt;
&lt;p&gt;函式&lt;code&gt;TreeNode* leftmost(TreeNode *current)&lt;/code&gt;的功能為：尋找以&lt;code&gt;current&lt;/code&gt;為root之subtree中，最左邊的node，最左邊的意思是從&lt;code&gt;current&lt;/code&gt;開始一路往left child做類似&lt;a href="http://alrightchiu.github.io/SecondRound/linked-list-traversal.html"&gt;Linked list之單向traversal&lt;/a&gt;的「一路向左」，而以inorder的順序來說，會找到該subtree中第一個進行Visiting的node。以圖四(c)為例，進入以A為root的Binary Tree，&lt;code&gt;leftmost()&lt;/code&gt;將回傳D。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;BinaryTree&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;leftmost&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;接著觀察在inorder規則下，某一node的下一個node的所在位置有兩種可能：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;若CurrentNode的right child不是NULL，則CurrentNode之下一個順序的node即為以「Current-&amp;gt;rightchild為root」之subtree中，最左的node。&lt;br /&gt;
如圖五(a)所示，若CurrentNode站在B上，B的下一個node即為「以B的right child(也就是E)」為root之subtree中的最左node，即為G。&lt;/li&gt;
&lt;li&gt;若CurrentNode沒有right child，則CurrentNode之下一個順序的node是「以left child的身份尋找到的ancestor」。&lt;br /&gt;
以圖五(a)中的H為例，H沒有right child，因此往上(往root方向)找ancestor，首先找到E，但是H是E的right child，因此再繼續往上找，此時CurrentNode移動到E。而E也是B的right child，再更新CurrentNode為B，往parent找到A，此時，&lt;strong&gt;B為A的left child&lt;/strong&gt;，則A即為H的下一個順序的node。&lt;/li&gt;
&lt;li&gt;若整棵樹偏一邊(稱為skewed Binary Tree)，root只有left subtree，沒有right subtree，則回傳NULL，表示root的successor。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="successor" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/successor.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五(a)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;BinaryTree&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;InorderSuccessor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;leftmost&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;new_node&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;new_node&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;new_node&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;new_node&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;最後，有了&lt;code&gt;leftmost()&lt;/code&gt;與&lt;code&gt;InorderSuccessor()&lt;/code&gt;，即能夠以迴圈的方式進行inorder traversal，相較於遞迴形式的函式，具有更大彈性：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;BinaryTree&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Inorder_by_parent&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;leftmost&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot; &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;InorderSuccessor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;output:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;D&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt; &lt;span class="n"&gt;G&lt;/span&gt; &lt;span class="n"&gt;E&lt;/span&gt; &lt;span class="n"&gt;H&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="n"&gt;F&lt;/span&gt; &lt;span class="n"&gt;I&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;/br&gt;
&lt;a name="predecessor"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Predecessor、rightmost&lt;/h3&gt;
&lt;p&gt;只要把&lt;code&gt;InorderSuccessor()&lt;/code&gt;與&lt;code&gt;leftmost()&lt;/code&gt;中，所有的left與right互換，就得到&lt;code&gt;InorderPredecessor()&lt;/code&gt;與&lt;code&gt;rightmost()&lt;/code&gt;，而概念上也確實是如此：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;rightmost&lt;/strong&gt;：從「以CurrentNode為subtree」的root一路向右做Linked list的單向traversal。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Predecessor&lt;/strong&gt;：某一CurrentNode的「前一個順序的node」之位置有兩種可能：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;若CurrentNode的left child不是NULL，則CurrentNode之前一個順序的node即為以「Current-&amp;gt;lefttchild為root」之subtree中，最右的node。&lt;br /&gt;
如圖五(b)所示，若CurrentNode站在C上，C的前一個node即為「以C的right child(也就是F)」為root之subtree中的最右node，即為I。&lt;/li&gt;
&lt;li&gt;若CurrentNode沒有left child，則CurrentNode之前一個順序的node是「以right child的身份尋找到的ancestor」。&lt;br /&gt;
以圖五(b)中的F為例，F沒有left child，因此往上(往root方向)找ancestor，首先找到C，但是F是C的left child，因此再繼續往上找，此時CurrentNode為C，往parent找到A，此時，&lt;strong&gt;C為A的right child&lt;/strong&gt;，則A即為F的前一個順序的node。&lt;/li&gt;
&lt;li&gt;同樣地，若整棵樹為skewed Binary Tree，root只有right subtree，沒有left subtree，則回傳NULL，表示root的predecessor。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="predecessor" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/predecessor.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五(b)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;BinaryTree&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;rightmost&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;BinaryTree&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;InorderPredecessor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;rightmost&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;new_node&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;new_node&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;new_node&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;new_node&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;有了&lt;code&gt;rightmost()&lt;/code&gt;與&lt;code&gt;InorderPredecessor()&lt;/code&gt;，便能夠照inorder traversal的相反順序對樹的node做Visiting：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;BinaryTree&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Inorder_Reverse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;rightmost&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot; &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;InorderPredecessor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;output:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;C&lt;/span&gt; &lt;span class="n"&gt;I&lt;/span&gt; &lt;span class="n"&gt;F&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="n"&gt;H&lt;/span&gt; &lt;span class="n"&gt;E&lt;/span&gt; &lt;span class="n"&gt;G&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt; &lt;span class="n"&gt;D&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;/br&gt;&lt;br /&gt;
&lt;code&gt;InorderSuccessor()&lt;/code&gt;和&lt;code&gt;InorderPredecessor()&lt;/code&gt;在Binary Search Tree的部分會再次出現，並且出現在基本操作：deletion(刪除node)中，因此學起來不止酷，還很實用的啊。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a name="ref"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;參考資料：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844"&gt;Introduction to Algorithms&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376"&gt;Fundamentals of Data Structures in C++&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Stack_%28abstract_data_type%29"&gt;Wikipedia：Stack(abstract data type)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Queue_%28abstract_data_type%29"&gt;Wikipedia：Queue(abstract data type)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="tree_series"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Tree系列文章&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/treeshu-introjian-jie.html"&gt;Tree(樹): Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-introjian-jie.html"&gt;Binary Tree: Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-traversalxun-fang.html"&gt;Binary Tree: Traversal(尋訪)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-jian-li-yi-ke-binary-tree.html"&gt;Binary Tree: 建立一棵Binary Tree&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-introjian-jie.html"&gt;Binary Search Tree: Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-searchsou-xun-zi-liao-insertxin-zeng-zi-liao.html"&gt;Binary Search Tree: Search(搜尋資料)、Insert(新增資料)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-sortpai-xu-deleteshan-chu-zi-liao.html"&gt;Binary Search Tree: Sort(排序)、Delete(刪除資料)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-introjian-jie.html"&gt;Red Black Tree: Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-rotationxuan-zhuan.html"&gt;Red Black Tree: Rotation(旋轉)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-insertxin-zeng-zi-liao-yu-fixupxiu-zheng.html"&gt;Red Black Tree: Insert(新增資料)與Fixup(修正)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-deleteshan-chu-zi-liao-yu-fixupxiu-zheng.html"&gt;Red Black Tree: Delete(刪除資料)與Fixup(修正)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;</summary><category term="C++"></category><category term="Binary Tree(二元樹)"></category></entry><entry><title>Linked List: Traversal(尋訪)</title><link href="http://alrightchiu.github.io/SecondRound/linked-list-traversalxun-fang.html" rel="alternate"></link><updated>2015-12-23T20:00:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2015-12-23:SecondRound/linked-list-traversalxun-fang.html</id><summary type="html">&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;先備知識與注意事項&lt;/h3&gt;
&lt;p&gt;traversal(尋訪)有「站在A地，往所有與A地相連的地方移動」的意思：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以Graph(圖)的語言來說，站在vertex A上，有一條edge連結A與B，若能夠由A往B移動，此即可視為traversal；&lt;/li&gt;
&lt;li&gt;在以pointer實現之Linked list和Tree中，站在node A上，A具有指向B之pointer，因此能夠由A往B移動，此即可視為traversal。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;移動到特定的node之後，通常伴隨著其他行為，例如print out(顯示資料)、assign(賦值)等等，這些操作又稱作Visiting。&lt;/p&gt;
&lt;p&gt;這篇文章將介紹在Linked list中的traversal。  &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;Traversal in Linked List&lt;/h2&gt;
&lt;p&gt;若有一個Linked list如圖一：&lt;/p&gt;
&lt;p&gt;&lt;/br&gt; 
&lt;center&gt;
&lt;img alt="linked list" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Linked%20List/Traversal_fig/LLtraversal.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一：Linked list: A-&amp;gt;B-&amp;gt;C-&amp;gt;D-&amp;gt;NULL。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;   &lt;/p&gt;
&lt;p&gt;現要求Visiting為print(顯示資料)，欲列印出Linked list中的所有字母，也就是從A開始，依序印出B、C、D，程式範例如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;string&amp;gt;&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;         &lt;span class="c1"&gt;// pointer to next node&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="c1"&gt;// data&lt;/span&gt;

    &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;(){};&lt;/span&gt;                       &lt;span class="c1"&gt;// default constructor&lt;/span&gt;
    &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;){};&lt;/span&gt;   &lt;span class="c1"&gt;// constructor&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;traversal&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;CurrentNode&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CurrentNode&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;CurrentNode&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot; &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;traversal&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CurrentNode&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// initialize nodes&lt;/span&gt;
    &lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;A&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;B&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;B&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;C&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;D&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;D&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="c1"&gt;// construct linked list&lt;/span&gt;
    &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;D&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;// representing the front of linked list by CurrentNode&lt;/span&gt;
    &lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;CurrentNode&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;// traversal by iteration &lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CurrentNode&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;CurrentNode&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot; &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;CurrentNode&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;CurrentNode&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;// traversal by recursion&lt;/span&gt;
    &lt;span class="n"&gt;traversal&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;output：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;A B C D     // from while loop
A B C D     // from traversal()
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;line5 - line12：&lt;/strong&gt;定義&lt;code&gt;class Node&lt;/code&gt;，其中包含了指向下一個node的pointer，以&lt;code&gt;string&lt;/code&gt;攜帶字母，以及&lt;code&gt;Node&lt;/code&gt;的constructor。(為了在main()中能夠取用，全部寫成public member。)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;line13 - line18：&lt;/strong&gt;此為recursion(遞迴)形式的traversal，與&lt;strong&gt;line42&lt;/strong&gt;一併討論。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;line21 - line24：&lt;/strong&gt;定義帶有字母A、B、C、D的node。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;line27 - line29：&lt;/strong&gt;示範如何使用最暴力的方式建立出如圖一的Linked list。(管理Linked list之過程時常是動態的(今天新增一筆資料，明天刪除兩筆資料)，因此建議將「新增node」寫成函式形式，例如：insert())。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;line32：&lt;/strong&gt; 定義&lt;code&gt;CurrentNode&lt;/code&gt;表示「當前所位於的node」。在Linked list(及其衍生資料結構)的操作中，時常使用CurrentNode，目的是為了讓函式能夠有效地重複利用。&lt;br /&gt;
舉例來說，若要用最暴力的方式依序印出A、B、C、D：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot; &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot; &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot; &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;output：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt; &lt;span class="n"&gt;D&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然而，這樣的寫法除了&lt;a href="https://www.youtube.com/watch?v=Qdcfxk-e_iw"&gt;太hardcore&lt;/a&gt;之外，還有幾點缺陷：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只有當資料量小，並且站在全知視角(已經知道Linked list中A、B、C、D之相對位置)時，才能土法煉鋼。假設Linked list中有一百個node，欲依序列出資料，又或者Node裡不只有定義pointer next，而是有pointer next1、next2、next3，就只好關閉視窗。&lt;/li&gt;
&lt;li&gt;資料隱蔽問題：一般情況，在定義&lt;code&gt;class Node&lt;/code&gt;時，不會把&lt;code&gt;Node *next&lt;/code&gt;與&lt;code&gt;string str&lt;/code&gt;裸露在外，而是寫成private member讓使用者無法任意修改。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;隱蔽性問題這裡不多談，大致上的方向是使用member function存取private member。&lt;br /&gt;
接著要處理的是程式的重複使用性。  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;line35 - line38：&lt;/strong&gt; traversal主體。  &lt;/p&gt;
&lt;p&gt;分解步驟如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;line35&lt;/strong&gt;：在&lt;strong&gt;line32&lt;/strong&gt;定義之&lt;code&gt;CurrentNode&lt;/code&gt;目前為node A，不是NULL，因此進入&lt;code&gt;While&lt;/code&gt;迴圈。&lt;br /&gt;
如圖二所示，在第一次迴圈中，可觸及的Node只有&lt;code&gt;CurrentNode&lt;/code&gt;與&lt;code&gt;CurrentNode-&amp;gt;next&lt;/code&gt;，即為A與B。 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="linked list_1" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Linked%20List/Traversal_fig/LLtraversal1.png?raw=true" /&gt;&lt;br /&gt;
&lt;strong&gt;圖二：第一次迴圈，可觸及的node只有A與B。&lt;/strong&gt;
&lt;/center&gt; &lt;br /&gt;
&lt;/br&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;line36&lt;/strong&gt;：列印出&lt;code&gt;CurrentNode&lt;/code&gt;所帶的字母。  &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;line37&lt;/strong&gt;：將&lt;code&gt;CurrentNode&lt;/code&gt;移動至&lt;code&gt;CurrentNode&lt;/code&gt;所指向的下一個node，亦即，從A移動到B。  &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;line38&lt;/strong&gt;：跳出迴圈後，若更新過後的&lt;code&gt;CurrentNode&lt;/code&gt;仍不為NULL(在A之後的是B)，將進入第二次&lt;code&gt;while&lt;/code&gt;迴圈，重複&lt;strong&gt;line35 - line38&lt;/strong&gt;。  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;依此類推，第二至第四次迴圈之示意圖如下：&lt;br /&gt;
&lt;/br&gt;
&lt;center&gt;
&lt;img alt="linked list_2" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Linked%20List/Traversal_fig/LLtraversal2.png?raw=true" /&gt;&lt;br /&gt;
&lt;strong&gt;圖三：第二次迴圈，視野範圍內可觸及的node為B與C。&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt;&lt;img alt="linked list_3" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Linked%20List/Traversal_fig/LLtraversal3.png?raw=true" /&gt;&lt;br /&gt;
&lt;strong&gt;圖四：第三次迴圈，視野範圍內可觸及的node為C與D。&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt;&lt;img alt="linked list_4" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Linked%20List/Traversal_fig/LLtraversal4.png?raw=true" /&gt;&lt;br /&gt;
&lt;strong&gt;圖五：第四次迴圈，視野範圍內可觸及的node只有D。&lt;/strong&gt;
&lt;/center&gt; &lt;br /&gt;
&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;直到第四次迴圈之&lt;strong&gt;line37&lt;/strong&gt;，&lt;code&gt;CurrentNode&lt;/code&gt;更新為NULL，表示已經抵達Linked list的尾端，同時，不滿足&lt;code&gt;while&lt;/code&gt;之條件式，便結束迴圈。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;line42：&lt;/strong&gt; 函式traversal()之主體(&lt;strong&gt;line13 - line18&lt;/strong&gt;)與&lt;strong&gt;line35 - line38&lt;/strong&gt;之&lt;code&gt;while&lt;/code&gt;迴圈具有相同的作用。兩者皆能列印出Linked list中的所有資料。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;  &lt;/p&gt;
&lt;p&gt;以上是在Linked list中，單向(single direction)的traversal之介紹，只要把握pointer對記憶體位置(memory address)的操作原則，應該能輕鬆掌握。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;參考資料：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Linked_list"&gt;Wikipedia：Linked List&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.youtube.com/watch?v=Qdcfxk-e_iw"&gt;太hardcore了&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;  &lt;/p&gt;</summary><category term="C++"></category><category term="Linked List(連結串列)"></category></entry><entry><title>Binary Tree: Intro(簡介)</title><link href="http://alrightchiu.github.io/SecondRound/binary-tree-introjian-jie.html" rel="alternate"></link><updated>2015-12-21T22:24:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2015-12-21:SecondRound/binary-tree-introjian-jie.html</id><summary type="html">&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;先備知識與注意事項&lt;/h3&gt;
&lt;p&gt;接續上一篇談到的&lt;a href="http://alrightchiu.github.io/SecondRound/treeshu.html"&gt;Tree(樹)&lt;/a&gt;，這篇文章將介紹樹這個大集合裡的其中一支大宗：&lt;strong&gt;Binary Tree&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;
學海無涯，快點跳海。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#bt"&gt;Binary Tree&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#code"&gt;程式碼&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#fullcomplete"&gt;Full &amp;amp; Complete Binary Tree&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#application"&gt;學習Binary Tree的未來出路&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#ref"&gt;參考資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#tree_series"&gt;Tree系列文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="bt"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Binary Tree&lt;/h2&gt;
&lt;p&gt;最廣義的樹(Tree)對於樹上的node之child數目沒有限制，因此，每個node可以有多個child。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;br /&gt;
&lt;img alt="general_tree" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Intro/general_tree.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一：這是一棵樹(Tree)&lt;/strong&gt;
&lt;/center&gt;  &lt;/p&gt;
&lt;p&gt;若限制node只能有兩個child，等價於「樹上的每一個node之degree皆為2」，此即稱為&lt;strong&gt;Binary Tree&lt;/strong&gt;(二元樹)，並稱兩個child pointer為left child和right-child。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;br /&gt;
&lt;img alt="binary_tree" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Intro/binary_tree.png?raw=true" /&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二：這是一棵Binary Tree。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="code"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;程式碼&lt;/h2&gt;
&lt;p&gt;修改在&lt;a href="http://alrightchiu.github.io/SecondRound/treeshu.html#code"&gt;Tree(樹)&lt;/a&gt;提供的程式實作方式，將node的child pointer設為left child與right child，以滿足Binary Tree的形式。&lt;br /&gt;
另外，在class TreeNode有個&lt;code&gt;TreeNode *parent&lt;/code&gt;，顧名思義，即是指向該node之parent的pointer，以圖二為例，B的parent pointer即指向A。&lt;br /&gt;
Binary Tree的node未必需要parent pointer(或稱為parent field)，然而加入parent後，在對樹的操作(operaion)如inorder traversal(中序尋訪)、node deletion(刪除node)、以及任何需要back-tracing(回溯路徑)的操作時，會更加有效率。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// 以C++為例&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Tree&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;         
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;       
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;           
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;data1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                  
    &lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="n"&gt;data2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;...&lt;/span&gt;
    &lt;span class="k"&gt;friend&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Tree&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Tree&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;             &lt;span class="c1"&gt;// 以root作為存取整棵樹的起點&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="fullcomplete"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Full &amp;amp; Complete Binary Tree&lt;/h2&gt;
&lt;p&gt;有兩類Binary Tree十分常見，分別為&lt;strong&gt;Full Binary Tree&lt;/strong&gt;以及&lt;strong&gt;Complete Binary Tree&lt;/strong&gt;。&lt;br /&gt;
(完滿二元樹？完整二元樹？我的建議是當作專有名詞，不要翻譯。) &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A. Full Binary Tree&lt;/strong&gt;:  &lt;/p&gt;
&lt;p&gt;如圖三所示，一棵&lt;strong&gt;Full Binary Tree&lt;/strong&gt;(或稱作Perfect Binary Tree)具有以下性質：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有internal node都有兩個subtree(也就是兩個child pointer)；&lt;/li&gt;
&lt;li&gt;所有leaf node具有相同的level(或相同的height)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由以上性質能夠推論出，若一棵Full Binary Tree的leaf node之level為&lt;span class="math"&gt;\(n\)&lt;/span&gt;，整棵樹共有&lt;span class="math"&gt;\(2^n-1\)&lt;/span&gt;個node。leaf node的level為4， 整棵樹共有15個node。&lt;br /&gt;
並且，每個node與其child有以下關係：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第&lt;span class="math"&gt;\(i\)&lt;/span&gt;個node的left child之index為 &lt;span class="math"&gt;\(2i\)&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;第&lt;span class="math"&gt;\(i\)&lt;/span&gt;個node的right child之index為 &lt;span class="math"&gt;\(2i+1\)&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;除了root之parent為NULL之外，第&lt;span class="math"&gt;\(i\)&lt;/span&gt;個node的parent之index為 &lt;span class="math"&gt;\(\lfloor {i\over2} \rfloor\)&lt;/span&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="Full Binary Tree" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Intro/fullBT.png?raw=true" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三：若一棵Full Binary Tree的leaf node之level為&lt;span class="math"&gt;\(n\)&lt;/span&gt;，整棵樹共有&lt;span class="math"&gt;\(2^n-1\)&lt;/span&gt;個node。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;B. Complete Binary Tree&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;若一棵樹的node按照Full Binary Tree的次序排列(由上至下，由左至右)，則稱此樹為&lt;strong&gt;Complete Binary Tree&lt;/strong&gt;。  &lt;/p&gt;
&lt;p&gt;以圖四及圖五作說明。&lt;br /&gt;
圖四的樹共有10個node，且這十個node正好填滿Full Binary Tree的前十個位置，則此樹為Complete Binary Tree。  &lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="Complete Binary Tree" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Intro/complBT.png?raw=true" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四：這是一棵Complete Binary Tree。&lt;/strong&gt;
&lt;/center&gt;  &lt;/p&gt;
&lt;p&gt;圖五的樹共有11個node，但是第11個node(K)應該要是第5個node(E)的child，因此，此樹並非Complete Binary Tree。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="Not Complete Binary Tree" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Intro/non_complBT.png?raw=true" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五：這不是一棵Complete Binary Tree。&lt;/strong&gt;
&lt;/center&gt;
&lt;/br&gt; &lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="application"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;學習Binary Tree的未來出路&lt;/h2&gt;
&lt;p&gt;如果有家長擔心小孩子學了Binary Tree之後對未來的出路沒有幫助，這裡有&lt;a href="http://stackoverflow.com/questions/2130416/what-are-the-applications-of-binary-trees"&gt;網路神人在StackOverFlow&lt;/a&gt;開示，以下簡單翻譯幾項Binary Tree的應用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Binary Search Tree(BST)：在某些資料經常要增加、刪除的應用中，BST常用來做搜尋，例如許多程式語言的Library中的&lt;code&gt;map&lt;/code&gt;和&lt;code&gt;set&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;Binary Space Partition：應用於幾乎所有的3D電玩遊戲以決定哪些物件需要rendered(呈現)。&lt;/li&gt;
&lt;li&gt;Binary Tries：應用於大多數high-bandwidth router(高頻寬路由器)以儲存router-tables。&lt;/li&gt;
&lt;li&gt;Heaps：用以實現高效率的priority queues(優先權佇列)，許多作業系統用來安排工作程序。&lt;/li&gt;
&lt;li&gt;Huffman Coding Tree：例如.jpeg、.mp3等壓縮技術皆使用Huffman編碼。(在一顆20MB的硬碟要價新台幣一萬元的時代，壓縮技術就是救世主。)  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以及其他應用(記得點進連結瞻仰大神網友風範)。&lt;br /&gt;
大致可以體會到Binary Tree是許多進階應用的基礎，學會了幾乎是治病強身。&lt;br /&gt;
接下來將會介紹Binary Tree(以及往後主題)中最基本的操作：traversal(尋訪)，顧名思義，就是如何在樹中移動，有了traversal之後再進一步探討search(搜尋)、insertion(新增node)、deletion(刪除node)、sorting(排序)會更加容易。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a name="ref"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;參考資料：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Binary_tree"&gt;Wikipedia：Binary tree&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376"&gt;Fundamentals of Data Structures in C++&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/2130416/what-are-the-applications-of-binary-trees"&gt;StackOverFlow：What are the applications of binary trees?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="tree_series"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Tree系列文章&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/treeshu-introjian-jie.html"&gt;Tree(樹): Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-introjian-jie.html"&gt;Binary Tree: Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-traversalxun-fang.html"&gt;Binary Tree: Traversal(尋訪)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-jian-li-yi-ke-binary-tree.html"&gt;Binary Tree: 建立一棵Binary Tree&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-introjian-jie.html"&gt;Binary Search Tree: Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-searchsou-xun-zi-liao-insertxin-zeng-zi-liao.html"&gt;Binary Search Tree: Search(搜尋資料)、Insert(新增資料)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-sortpai-xu-deleteshan-chu-zi-liao.html"&gt;Binary Search Tree: Sort(排序)、Delete(刪除資料)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-introjian-jie.html"&gt;Red Black Tree: Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-rotationxuan-zhuan.html"&gt;Red Black Tree: Rotation(旋轉)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-insertxin-zeng-zi-liao-yu-fixupxiu-zheng.html"&gt;Red Black Tree: Insert(新增資料)與Fixup(修正)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-deleteshan-chu-zi-liao-yu-fixupxiu-zheng.html"&gt;Red Black Tree: Delete(刪除資料)與Fixup(修正)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="C++"></category><category term="Binary Tree(二元樹)"></category><category term="Intro"></category></entry><entry><title>Tree(樹): Intro(簡介)</title><link href="http://alrightchiu.github.io/SecondRound/treeshu-introjian-jie.html" rel="alternate"></link><updated>2015-12-19T20:27:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2015-12-19:SecondRound/treeshu-introjian-jie.html</id><summary type="html">&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;先備知識與注意事項&lt;/h3&gt;
&lt;p&gt;若熟悉Linked List(連結串列)將會更容易理解樹：Linked list是一維的線性結構(不是往前、就是往後)，而樹(與圖)則推廣成多維的結構。&lt;br /&gt;
&lt;/br&gt;
&lt;center&gt;&lt;img alt="linkedlist" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/Tree_fig/linked_list_size.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一：A、B、C、D稱為node(節點)，用以代表資料(data)、狀態(state)。&lt;br /&gt;
連結各個node之間的連結(link)稱為edge，可能是單方向，或者雙向。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;   &lt;/p&gt;
&lt;p&gt;另外則是用詞翻譯的選擇，由於許多名詞時常被設置為程式碼的變數名稱，而且翻譯後將造成理解上的斷層(如node/vertex(節點)、edge(邊緣？)、parent(父還是母？)、child(孩子？)、ancestor(祖先？)、sibling(手足？兄弟姐妹？)...)，所以決定將此類用詞視為專有名詞，不做翻譯。&lt;br /&gt;
文句中將出現中英夾雜的情形，敬請見諒。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.youtube.com/watch?v=u1ZB_rGFyeU"&gt;OK Go&lt;/a&gt;.  &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#example"&gt;隨處可見的Tree(樹)&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="#essence"&gt;那麼，樹最根本的特徵是什麼？&lt;/a&gt;   &lt;/li&gt;
&lt;li&gt;&lt;a href="#tree_not_tree"&gt;還有哪些結構是樹？&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="#element"&gt;用以描述一棵樹的元素&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="#definition"&gt;樹的定義&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="#code"&gt;程式碼&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="#set"&gt;集合關係&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="#ref"&gt;參考資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#tree_series"&gt;Tree系列文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="example"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;隨處可見的Tree(樹)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Tree(樹)&lt;/strong&gt;是用以描述具有&lt;strong&gt;階層結構&lt;/strong&gt;(hierarchical structure)的問題的首選，階層結構意味著明確的先後次序，例如，若要印出ABC三個字母的所有排列組合(permutation)，直覺反射的圖像會是：  &lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;br /&gt;
&lt;img alt="fig1.a" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/Tree_fig/abc_permu_size.png?raw=true" /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;
&lt;img alt="fig1.b" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/Tree_fig/abc_permu_vertical_size.png?raw=true" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二：ABC字母排列組合。&lt;br /&gt;
視R為樹根(root)，每一個選擇狀態視為node，此即為樹的結構。&lt;/strong&gt;
&lt;/center&gt;
&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;圖二的邏輯為：從起點(R)開始，先決定第一個字母，再依序決定第二、第三個字母，並且，在每一次選擇字母時，可能有不止一個可供選擇的字母。最後一共走出六條路徑，得到六種排列組合，而且這六種排列方式只能經由一種唯一的選擇方式(唯一的路徑)產生。若將起點(R)視為樹根(root)，每一個字母選擇的狀態(例如：A、C、BC、CAB)都視為一個node，這樣的結構便能夠視為一棵樹。  &lt;/p&gt;
&lt;p&gt;另外如一本書的目錄、族譜、官僚企業的職位關係，甚至是更廣義的「從家門口為起點尋找方圓一公里以內的便利商店」都能夠建立出樹的模型。  &lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="essence"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;那麼，樹最根本的特徵是什麼？&lt;/h2&gt;
&lt;p&gt;以族譜為例，若包龍星是宋世傑的爸爸，那麼包龍星就絕對不能同時又是宋世傑的兒子。圖三以node與edge描述此關係，並定義箭頭是從父指向子，則包龍星指向宋世傑的箭頭表示包為父、宋為子，而宋世傑指向包龍星的箭頭表示宋為父、包為子，這一個箭頭即違反了最初「包龍星是宋世傑的爸爸」的命題，此即稱為cycle，也就是著名的「雞生蛋」與「蛋生雞」。  &lt;/p&gt;
&lt;p&gt;而樹的最根本特徵就是：&lt;strong&gt;在樹的結構裡，只有一個root(樹根)，並且不存在cycle&lt;/strong&gt;。
此特徵將衍生出另外兩項等價的性質：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;在樹中若要從root尋找特定node，一定只存在一條路徑(path)。&lt;/strong&gt;  &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;每個node只會有一個parent。&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;/br&gt; 
&lt;center&gt;
&lt;img alt="cycle" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/Tree_fig/cycle_size.png?raw=true" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三：包龍星若是宋世傑的parent(父)，又同時為其child(子)，即形成cycle。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt; &lt;/p&gt;
&lt;p&gt;&lt;a name="tree_not_tree"&gt;&lt;/a&gt; &lt;/p&gt;
&lt;h2&gt;還有哪些結構是樹？&lt;/h2&gt;
&lt;p&gt;(若不是樹，皆稱為圖(graph)。)&lt;/p&gt;
&lt;p&gt;下列四種結構中，a、b可以視為樹，而c、d則否：
&lt;/br&gt;
&lt;center&gt;&lt;img alt="fig2.a" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/Tree_fig/is_Tree_a_size.png?raw=true" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三.a：若樹的node只有指向left subtree(左子樹)與right subtree(右子樹)時，又稱為Binary Tree(二元樹)。&lt;/strong&gt;&lt;br /&gt;
&lt;/br&gt; 
&lt;img alt="fig2.b" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/Tree_fig/is_Tree_b_size.png?raw=true" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三.b：若樹退化成Linked list(連結串列)，仍滿足樹的定義。&lt;/strong&gt;  &lt;br /&gt;
&lt;/br&gt;
&lt;img alt="fig2.c" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/Tree_fig/is_Not_Tree_c_size.png?raw=true" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三.c：在F出現cycle；以及，D有兩個parent node。&lt;/strong&gt;&lt;br /&gt;
&lt;/br&gt;
&lt;img alt="fig2.d" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/Tree_fig/is_Not_Tree_d_size.png?raw=true" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三.d：一棵樹只能有一個root(樹根)。此圖像又稱為Forest(樹林)。&lt;/strong&gt;
&lt;/center&gt;
&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="element"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;用以描述一棵樹的元素&lt;/h2&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="fig3" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/Tree_fig/general_Tree.png?raw=true" /&gt;   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四：這是一棵普通的樹。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;  &lt;/p&gt;
&lt;p&gt;配合圖四，以下將介紹在樹中常見的元素，可以用來計算時間複雜度(time complexity)、與同好交流感情，好處不勝枚舉。   &lt;/p&gt;
&lt;p&gt;針對&lt;strong&gt;node / vertex&lt;/strong&gt;：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;degree(分歧度)&lt;/strong&gt;：一個node擁有的subtree(子樹)的個數。例如：A的degree為3，F的degree為2，N的degree為0。  &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;root(樹根)&lt;/strong&gt;：樹中最上層的node，也是唯一一個其parent為&lt;strong&gt;NULL&lt;/strong&gt;的node。圖四中，A即為root。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;leaf&lt;/strong&gt;：沒有child/subtree的node稱為leaf node。圖四中，G、H、J、K、L、M、N皆為leaf node。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;external node&lt;/strong&gt;：沒有child的node。因此，leaf node與external node同義。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;internal node&lt;/strong&gt;：至少有一個child的node，稱為internal node。圖四中，A、B、C、D、E、F、I皆為internal node。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;針對&lt;strong&gt;樹&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;parent&lt;/strong&gt; &amp;lt;--&amp;gt; &lt;strong&gt;child&lt;/strong&gt;：圖四中，A為C的parent，C為A的child；E為K的parent，K為E的child。若以pointer說明，被指向者(pointed)為child，指向者(point to)為parent。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;siblings&lt;/strong&gt;：擁有相同parent的node們，互相稱兄道弟。例如：B、C、D共同的parent為A。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;descendant(子嗣)&lt;/strong&gt;：圖四中，站在A，所有能夠以「尋找child」的方式找到的node，皆稱為A的descendant，因此整棵樹除了A以外皆為A的descendant。站在F，能夠以「parent指向child」找到的node有L、M，則稱L、M為F的descendant。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ancestor(祖先)&lt;/strong&gt;：圖四中，站在K，所有能夠以「尋找parent」的方式找到的node，皆稱為K的ancestor，因此，E、B、A皆為K的ancestor。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;path(路徑)&lt;/strong&gt;：由descendant與ancestor關係連結成的edge，例如A-B-E-K、A-C-F-N。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;level&lt;/strong&gt;：定義root的level為1，其餘node的level為其parent的level加一。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;height of node&lt;/strong&gt;：某一node與其最長path上之descendant leaf node之間的edge數。例如F的height為1，D的height為2，leaf node的height為0。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;height of tree&lt;/strong&gt;：樹的height即為root的height，圖四中，樹的height為A的height，等於3。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;depth&lt;/strong&gt;：某一node與root之間的edge數。例如，F的depth為2，L的depth為3。  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="definition"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;定義&lt;/h2&gt;
&lt;p&gt;以下列出兩種互相等價的Tree(樹)的定義：&lt;br /&gt;
(根據以上範例說明，再配合樹的定義，還不飛上天？)&lt;/p&gt;
&lt;p&gt;A. &lt;strong&gt;Tree(樹)&lt;/strong&gt;是由一個或多個節點所組成的有限集合，並且滿足：  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;存在且只有一個稱為&lt;code&gt;root&lt;/code&gt;(樹根)的節點；&lt;/li&gt;
&lt;li&gt;其餘的節點可以分割成任意正整數個(包含零個)互斥(disjoint)的集合：&lt;span class="math"&gt;\(T_1、...、T_n\)&lt;/span&gt;，其中每一個集合也都滿足樹的定義，這些集合又稱為這棵樹的&lt;strong&gt;subtree(子樹)&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;B. &lt;strong&gt;Tree(樹)&lt;/strong&gt;是由一個或多個nodes/vertices以及edge所組成，而且沒有cycle的集合(set)。  &lt;/p&gt;
&lt;p&gt;在圖三(d)中，曾出現&lt;strong&gt;Forest(樹林)&lt;/strong&gt;，其定義很直觀：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由&lt;span class="math"&gt;\(n\geq 0\)&lt;/span&gt;棵彼此互斥(disjoint)的Tree(樹)所形成的集合(Set)，即稱為Forest(樹林)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="forest" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/Tree_fig/forest_.png?raw=true" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五：Forest(樹林)由多個Tree(樹)所組成，可以用來表示互斥集合(disjoint set)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="code"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;程式碼&lt;/h2&gt;
&lt;p&gt;實務上，要以程式碼實作一棵樹，常用的手法為：先以class TreeNode(或是struct)定義出每顆node能夠指向多少subtree、攜帶哪些資料形態，再以另一個class Tree表示整棵樹，並以root作為樹的存取點：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Tree&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;        &lt;span class="c1"&gt;// 以下表示每一個node有四個pointer指向child&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;whatever&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;works&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;data1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                  &lt;span class="c1"&gt;// node所攜帶的info&lt;/span&gt;
    &lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="n"&gt;data2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;...&lt;/span&gt;
    &lt;span class="k"&gt;friend&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Tree&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Tree&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;             &lt;span class="c1"&gt;// 以root作為存取整棵樹的起點&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="set"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;集合關係&lt;/h2&gt;
&lt;p&gt;本篇介紹的Tree(樹)位居承先啟後的戰略位置，圖六是與Tree(樹)有關的資料結構的集合關係圖：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="fig4" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/Tree_fig/Set_Graph_Tree_size.png?raw=true" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖六：與Tree(樹)相關的資料結構之集合關係。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;本篇介紹的Tree(樹)並沒有限制child/ subtree的個數，理論上可以有多到超過記憶體空間的child node。&lt;br /&gt;
然而在實務上，較常使用每個node至多只有兩個child的樹，稱為&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-introjian-jie.html"&gt;&lt;strong&gt;Binary Tree&lt;/strong&gt;(二元樹)&lt;/a&gt;。&lt;br /&gt;
從Binary Tree再增加「鍵值大小規則」，即得到&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-introjian-jie.html"&gt;&lt;strong&gt;Binary Search Tree&lt;/strong&gt;(BST，二元搜尋樹)&lt;/a&gt;。&lt;br /&gt;
以BST為基礎，在每個node上添加顏色(紅與黑)用以平衡樹的height，以減短搜尋時間，此種樹稱為&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-introjian-jie.html"&gt;&lt;strong&gt;Red Black Tree&lt;/strong&gt;(RBT，紅黑樹)&lt;/a&gt;。&lt;br /&gt;
另一個方向，若打破「不能存在cycle」的限制，則從樹推廣至&lt;a href="http://alrightchiu.github.io/SecondRound/graph-introjian-jie.html"&gt;&lt;strong&gt;圖(Graph)&lt;/strong&gt;&lt;/a&gt;。  &lt;/p&gt;
&lt;p&gt;在接下來的文章將先以縮小集合的方向依序介紹：Binary Tree、BST、RBT，再進入Graph(圖)這個更複雜的主題。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a name="ref"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;參考資料：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Tree_%28data_structure%29"&gt;Wikipedia：Tree(data structure)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376"&gt;Fundamentals of Data Structures in C++&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://program-lover.blogspot.tw/2008/12/tree.html"&gt;Infinite Loop：【演算】樹 - Tree&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://zh.wikipedia.org/wiki/%E4%B9%9D%E5%93%81%E8%8A%9D%E9%BA%BB%E5%AE%98"&gt;Wikipedia：九品芝麻官&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://zh.wikipedia.org/wiki/%E5%AF%A9%E6%AD%BB%E5%AE%98_%281992%E5%B9%B4%E9%9B%BB%E5%BD%B1%29"&gt;Wikipedia：威龍闖天關&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="tree_series"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Tree系列文章&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/treeshu-introjian-jie.html"&gt;Tree(樹): Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-introjian-jie.html"&gt;Binary Tree: Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-traversalxun-fang.html"&gt;Binary Tree: Traversal(尋訪)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-jian-li-yi-ke-binary-tree.html"&gt;Binary Tree: 建立一棵Binary Tree&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-introjian-jie.html"&gt;Binary Search Tree: Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-searchsou-xun-zi-liao-insertxin-zeng-zi-liao.html"&gt;Binary Search Tree: Search(搜尋資料)、Insert(新增資料)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-sortpai-xu-deleteshan-chu-zi-liao.html"&gt;Binary Search Tree: Sort(排序)、Delete(刪除資料)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-introjian-jie.html"&gt;Red Black Tree: Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-rotationxuan-zhuan.html"&gt;Red Black Tree: Rotation(旋轉)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-insertxin-zeng-zi-liao-yu-fixupxiu-zheng.html"&gt;Red Black Tree: Insert(新增資料)與Fixup(修正)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-deleteshan-chu-zi-liao-yu-fixupxiu-zheng.html"&gt;Red Black Tree: Delete(刪除資料)與Fixup(修正)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="C++"></category><category term="Intro"></category></entry></feed>