<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Ordinary Days</title><link href="http://alrightchiu.github.io/SecondRound/" rel="alternate"></link><link href="http://alrightchiu.github.io/SecondRound/feeds/all.atom.xml" rel="self"></link><id>http://alrightchiu.github.io/SecondRound/</id><updated>2015-12-14T09:27:00+08:00</updated><entry><title>樹(Tree)</title><link href="http://alrightchiu.github.io/SecondRound/shu-tree.html" rel="alternate"></link><updated>2015-12-14T09:27:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2015-12-14:SecondRound/shu-tree.html</id><summary type="html">&lt;h6&gt;&lt;strong&gt;先備知識與注意事項&lt;/strong&gt;&lt;/h6&gt;
&lt;p&gt;用array處理樹(Tree)的手法對一個初學者如筆者來說，還暫時僅存在於理論上可行的層次。以下將以指標(pointer)為主做說明。&lt;/p&gt;
&lt;p&gt;若熟悉連結串列(Linked List)將會更容易理解樹：Linked list是一維的結構(不是往前、就是往後)，而樹(與圖)則推廣成多維的結構。&lt;br /&gt;
&lt;/br&gt;
&lt;center&gt;&lt;img alt="linkedlist" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/tree/linked_list_size.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一：A、B、C、D稱為node(節點)，用以代表資料(data)、狀態(state)。&lt;br /&gt;
連結各個node之間的連結(link)稱為edge，可能是單方向，或者雙向。&lt;/strong&gt;
&lt;/center&gt; 
&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;另外則是用詞翻譯的選擇，為響應兩性平權(feminism)以及使用的頻繁程度，名詞如node/vertex(節點)、edge(邊緣？)、parent(父還是母？)、child(孩子？)、ancestor(祖先？)...皆不做翻譯。  &lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;br /&gt;
OK Go.&lt;br /&gt;
&lt;/br&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;隨處可見的樹&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;樹&lt;/strong&gt;(Tree)是用以描述具有&lt;strong&gt;階層結構&lt;/strong&gt;(hierarchical structure)的問題的首選，階層結構意味著明確的先後次序，例如，若要印出ABC三個字母的所有排列組合(permutation)，直覺反射的圖像會是：  &lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;br /&gt;
&lt;img alt="fig1.a" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/tree/abc_permu_size.png?raw=true" /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;
&lt;img alt="fig1.b" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/tree/abc_permu_vertical_size.png?raw=true" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二：ABC字母排列組合。&lt;br /&gt;
視R為樹根(root)，每一個選擇狀態視為node，此即為樹的結構。&lt;/strong&gt;
&lt;/center&gt;
&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;圖二的邏輯為：從起點(R)開始，先決定第一個字母，再依序決定第二、第三個字母，並且，在每一次選擇字母時，可能有不止一個可供選擇的字母。最後一共走出六條路徑，得到六種排列組合，而且這六種排列方式只能經由一種唯一的選擇方式(唯一的路徑)產生。若將起點(R)視為樹根(root)，每一個字母選擇的狀態(例如：A、C、BC、CAB)都視為一個node，這樣的結構便能夠視為一棵樹。  &lt;/p&gt;
&lt;p&gt;另外如族譜、官僚企業的職位關係，甚至是更廣義的「從家門口為起點尋找方圓一公里以內的便利商店」都能夠建立出樹的模型。&lt;br /&gt;
&lt;/br&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;那麼，樹最根本的特徵是什麼？&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;以族譜為例，若包龍星是宋世傑的爸爸，那麼包龍星就絕對不能同時又是宋世傑的兒子。圖三以node與edge描述此關係，並定義箭頭是從父指向子，則包龍星指向宋世傑的箭頭表示包為父、宋為子，而宋世傑指向包龍星的箭頭表示宋為父、包為子，這一個箭頭即違反了最初「包龍星是宋世傑的爸爸」的命題，此即稱為cycle，也就是著名的「雞生蛋」與「蛋生雞」。  &lt;/p&gt;
&lt;p&gt;而樹的最根本特徵就是：&lt;strong&gt;在樹的結構裡，只有一個樹根(root)，並且不存在cycle&lt;/strong&gt;。以此衍生出另外一個特徵：&lt;strong&gt;在樹中若要從root尋找特定node，一定只存在一條路徑(path)。&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt;&lt;/br&gt; 
&lt;center&gt;
&lt;img alt="cycle" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/tree/cycle_size.png?raw=true" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三：包龍星若是宋世傑的parent(父)，又同時為其child(子)，即形成cycle。&lt;/strong&gt;
&lt;/center&gt;
&lt;/br&gt; &lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;還有哪些結構是樹？&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;(若不是樹，皆稱為圖(graph)。)&lt;/p&gt;
&lt;p&gt;下列四種結構中，a、b可以視為樹，而c、d則否：
&lt;/br&gt;
&lt;center&gt;&lt;img alt="fig2.a" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/tree/is_Tree_a_size.png?raw=true" /&gt;&lt;br /&gt;
&lt;strong&gt;圖三.a：若樹的node只有指向左子樹(left subtree)與右子樹(right subtree)時，又稱為二元樹(Binary Tree)。&lt;/strong&gt;&lt;br /&gt;
&lt;/br&gt; 
&lt;img alt="fig2.b" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/tree/is_Tree_b_size.png?raw=true" /&gt;&lt;br /&gt;
&lt;strong&gt;圖三.b：若樹退化成連結串列(linked list)，仍滿足樹的定義。&lt;/strong&gt;  &lt;br /&gt;
&lt;/br&gt;
&lt;img alt="fig2.c" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/tree/is_Not_Tree_c_size.png?raw=true" /&gt;&lt;br /&gt;
&lt;strong&gt;圖三.c：在F出現cycle；C-&amp;gt;B-&amp;gt;D-&amp;gt;E出現undirected cycle，詳見圖論(graph theory)。&lt;br /&gt;
後者等價於：D有兩個parent node。&lt;/strong&gt;&lt;br /&gt;
&lt;/br&gt;
&lt;img alt="fig2.d" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/tree/is_Not_Tree_d_size.png?raw=true" /&gt;&lt;br /&gt;
&lt;strong&gt;圖三.d：一棵樹只能有一個樹根(root)。此圖像又稱為樹林(forest)。&lt;/strong&gt;
&lt;/center&gt;
&lt;/br&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;用以描述一棵樹的元素&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="fig3" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/tree/general_Tree_size.png?raw=true" /&gt;   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四：這是一棵普通的樹。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;  &lt;/p&gt;
&lt;p&gt;配合圖四，以下將介紹在樹中常見的元素，可以用來計算時間複雜度(time complexity)、與同好交流感情，好處不勝枚舉。   &lt;/p&gt;
&lt;p&gt;針對&lt;strong&gt;node / vertex&lt;/strong&gt;：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;degree(分歧度)&lt;/strong&gt;：一個node擁有的subtree(子樹)的個數。例如：A的degree為3，G的degree為2，N的degree為0。  &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;root(樹根)&lt;/strong&gt;：樹中最上層的node，也是唯一一個其parent為&lt;strong&gt;NULL&lt;/strong&gt;的node。圖四中，A即為root。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;leaf&lt;/strong&gt;：沒有child/subtree的node稱為leaf node。圖四中，L、N、H、I皆為leaf node。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;針對&lt;strong&gt;樹&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;parent&lt;/strong&gt; &amp;lt;--&amp;gt; &lt;strong&gt;child&lt;/strong&gt;：圖四中，A為C的parent，C為A的child；E為L的parent，L為E的child。若以pointer說明，被指向者(pointed)為child，指向者(point to)為parent。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;siblings&lt;/strong&gt;：擁有相同parent的node們，互相稱兄道弟。例如：B、C、D共同的parent為A。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;descendant(子嗣)&lt;/strong&gt;：圖四中，站在A，所有能夠以「尋找child」的方式找到的node，皆稱為A的descendant，因此整棵樹除了A以外皆為A的descendant。站在G，能夠以「parent指向child」找到的node有M、N，則稱M、N為G的descendant。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ancestor(祖先)&lt;/strong&gt;：圖四中，站在L，所有能夠以「尋找parent」的方式找到的node，皆稱為L的ancestor，因此，E、B、A皆為L的ancestor。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;path(路徑)&lt;/strong&gt;：由descendant與ancestor關係連結成的edge，例如A-B-E-L、A-C-G-N。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;level&lt;/strong&gt;：定義root的level為1，其餘node的level為其parent的level加一。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;height of node&lt;/strong&gt;：某一node與其descendant leaf node之間的edge數。例如G的height為1，D的height為2，leaf node的height為0。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;height of tree&lt;/strong&gt;：樹的height即為root的height，圖四中，樹的height為A的height，等於3。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;depth&lt;/strong&gt;：某一node與root之間的edge數。例如，G的depth為2，L的depth為3。&lt;br /&gt;
&lt;/br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;strong&gt;定義&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;根據以上範例說明，再配合樹的定義，還不飛上天？  &lt;/p&gt;
&lt;p&gt;以下列出兩種樹的定義：  &lt;/p&gt;
&lt;p&gt;A. &lt;strong&gt;樹&lt;/strong&gt;是由一個或多個節點所組成的有限集合，並且滿足：  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;存在且只有一個稱為樹根(root)的節點；&lt;/li&gt;
&lt;li&gt;其餘的節點可以分割成任意正整數個(包含零個)互斥(disjoint)的集合：T&lt;sub&gt;1&lt;/sub&gt;、...、T&lt;sub&gt;n&lt;/sub&gt;，其中每一個集合也都滿足樹的定義，這些集合又稱為這棵樹的&lt;strong&gt;子樹&lt;/strong&gt;(subtree)。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;B. &lt;strong&gt;樹&lt;/strong&gt;是由一個或多個nodes/vertices以及edge所組成，而且沒有循環(cycle)的集合(set)。&lt;br /&gt;
&lt;/br&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;程式碼&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;實務上，要以程式碼定義一棵樹，常用的手法為：先以class TreeNode(或是struct)定義出node，再以另一個class Tree表示整棵樹，並以root作為樹的存取點：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;// 以C++為例
class TreeNode{
    TreeNode *leftchild;        // 以下表示每一個node有四個pointer指向child
    TreeNode *rightchild;
    TreeNode *whatever;
    TreeNode *works;
    int data1;                  // node所攜帶的info
    double data2;
    ...
};
class Tree{
    TreeNode *root;         // 以root作為存取整棵樹的起點
};
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;集合關係&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;本篇介紹的樹(Tree)位居承先啟後的重要戰略位置，圖五展示了與樹有關的資料結構的集合關係圖：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="fig4" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/tree/Set_Graph_Tree_size.png?raw=true" /&gt;&lt;br /&gt;
&lt;strong&gt;圖五：與樹相關的資料結構之集合關係。&lt;/strong&gt;
&lt;/center&gt;
&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;本篇介紹的樹並沒有限制child/ subtree的個數，理論上可以有多到超過記憶體空間的child node。&lt;br /&gt;
然而在實務上，較常使用每個node至多只有兩個child的樹，稱為&lt;strong&gt;Binary Tree&lt;/strong&gt;(二元樹)。&lt;br /&gt;
從Binary Tree再增加「鍵值大小規則」，即得到&lt;strong&gt;Binary Search Tree&lt;/strong&gt;(BST，二元搜尋樹)。&lt;br /&gt;
以BST為基礎，在每個node上添加顏色(紅與黑)用以平衡樹的height，以減短搜尋時間，此種樹稱為&lt;strong&gt;Red Black Tree&lt;/strong&gt;(RB Tree，紅黑樹)。
另一個方向，若打破「不能存在cycle」的限制，則從樹推廣至&lt;strong&gt;圖(graph)&lt;/strong&gt;。  &lt;/p&gt;
&lt;p&gt;在接下來的文章將先以縮小集合的方向依序介紹：Binary Tree、BST、RB Tree，再進入圖(graph)這個更複雜的主題。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h6&gt;#&lt;strong&gt;參考資料&lt;/strong&gt;：&lt;/h6&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Tree_%28data_structure%29"&gt;Wikipedia：Tree(data structure)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376"&gt;Fundamentals of Data Structures in C++&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://program-lover.blogspot.tw/2008/12/tree.html"&gt;Infinite Loop：【演算】樹 - Tree&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://zh.wikipedia.org/wiki/%E4%B9%9D%E5%93%81%E8%8A%9D%E9%BA%BB%E5%AE%98"&gt;Wikipedia：九品芝麻官&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://zh.wikipedia.org/wiki/%E5%AF%A9%E6%AD%BB%E5%AE%98_%281992%E5%B9%B4%E9%9B%BB%E5%BD%B1%29"&gt;Wikipedia：威龍闖天關&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;</summary><category term="今天不寫明天就忘了"></category></entry><entry><title>font test</title><link href="http://alrightchiu.github.io/SecondRound/font-test.html" rel="alternate"></link><updated>2015-12-07T20:09:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2015-12-07:SecondRound/font-test.html</id><summary type="html">&lt;p&gt;如果&lt;br /&gt;
“程式設計／腳本／標記語言都是英文的，常見的開源計畫如 Linux 也都是英文的。Branch master set up to track remote branch master from origin.全世界的開發者都在使用英文，為跨國客戶工作的開發者更是被逼得一定要會英文，才能為他們的需求找到解決辦法。
發現了嗎？英文之於人類，就像二進位之於電腦。
”&lt;br /&gt;
why why why why why &lt;br /&gt;
ㄏ&lt;/p&gt;
&lt;p&gt;舒潔棉柔舒適&lt;/p&gt;</summary><category term="yoyo"></category></entry><entry><title>不會吧</title><link href="http://alrightchiu.github.io/SecondRound/bu-hui-ba.html" rel="alternate"></link><updated>2015-12-04T23:51:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2015-12-04:SecondRound/bu-hui-ba.html</id><summary type="html">&lt;p&gt;好的
中文測試&lt;/p&gt;
&lt;p&gt;字體          間距&lt;/p&gt;
&lt;p&gt;之類的 如果  是   這樣     的&lt;/p&gt;
&lt;p&gt;哈哈&lt;/p&gt;
&lt;p&gt;噢噎&lt;/p&gt;
&lt;p&gt;煩呦&lt;/p&gt;</summary><category term="這麼巧"></category></entry><entry><title>give me tags.html</title><link href="http://alrightchiu.github.io/SecondRound/give-me-tagshtml.html" rel="alternate"></link><updated>2015-12-04T22:51:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2015-12-04:SecondRound/give-me-tagshtml.html</id><summary type="html">&lt;div class="highlight"&gt;&lt;pre&gt;                    cd
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;c      &lt;br /&gt;
why why why why why &lt;br /&gt;
c&lt;/p&gt;</summary><category term="yoyo"></category></entry><entry><title>test2</title><link href="http://alrightchiu.github.io/SecondRound/test2.html" rel="alternate"></link><updated>2015-12-04T11:23:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2015-12-04:SecondRound/test2.html</id><summary type="html">&lt;p&gt;haha&lt;/p&gt;
&lt;p&gt;why can't I set the SITELOGO?&lt;/p&gt;</summary><category term="Yo"></category></entry><entry><title>step to try</title><link href="http://alrightchiu.github.io/SecondRound/step-to-try.html" rel="alternate"></link><updated>2015-12-03T20:21:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2015-12-03:SecondRound/step-to-try.html</id><summary type="html">&lt;p&gt;Hello World from Pelican!&lt;/p&gt;
&lt;p&gt;try to change the theme&lt;/p&gt;
&lt;p&gt;oh &lt;/p&gt;
&lt;p&gt;it's&lt;/p&gt;
&lt;p&gt;snow&lt;/p&gt;
&lt;p&gt;hey oh~&lt;/p&gt;
&lt;p&gt;when to &lt;/p&gt;
&lt;p&gt;ha&lt;/p&gt;
&lt;p&gt;no&lt;/p&gt;
&lt;p&gt;way
 hello&lt;/p&gt;
&lt;p&gt;my boy&lt;/p&gt;</summary><category term="Test"></category></entry></feed>