<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Second Round</title><link href="http://alrightchiu.github.io/SecondRound/" rel="alternate"></link><link href="http://alrightchiu.github.io/SecondRound/feeds/yan-suan-fa-yu-zi-liao-jie-gou.atom.xml" rel="self"></link><id>http://alrightchiu.github.io/SecondRound/</id><updated>2016-02-03T23:49:00+08:00</updated><entry><title>Grpah: Intro(簡介)</title><link href="http://alrightchiu.github.io/SecondRound/grpah-introjian-jie.html" rel="alternate"></link><updated>2016-02-03T23:49:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2016-02-03:SecondRound/grpah-introjian-jie.html</id><summary type="html">&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;先備知識與注意事項&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;在經歷過&lt;a href="http://alrightchiu.github.io/SecondRound/treeshu-introjian-jie.html"&gt;Tree系列文章&lt;/a&gt;的洗禮後，接著要介紹的是Graph(圖)。&lt;/p&gt;
&lt;p&gt;Graph比Tree更加廣義，其定義僅僅使用了集合(Set)，並且不限制結構裡的node/vertex只能有唯一的&lt;code&gt;parent field&lt;/code&gt;，因此，更多的問題能夠以Graph建立模型。 &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#course"&gt;初探Graph的美妙：以課程與其先修科目為例&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#graph"&gt;Graph的定義&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#represent"&gt;表示法(representation)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#terminology"&gt;一些名詞解釋&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#app"&gt;預告：Graph的應用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#ref"&gt;參考資料&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name="course"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;初探Graph的美妙：以課程與其先修科目為例&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;舉例來說，有間大學的計算機科學學位之必修課程，以及與該課程相關的先修科目設計如表一：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Course name&lt;/th&gt;
&lt;th&gt;Prerequisites&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Programming I(程式設計 I)&lt;/td&gt;
&lt;td&gt;None&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Discrete Mathematics(離散數學)&lt;/td&gt;
&lt;td&gt;None&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Data Structures(資料結構)&lt;/td&gt;
&lt;td&gt;Programming I, Discrete Mathematics&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Calculus I(微積分 I)&lt;/td&gt;
&lt;td&gt;None&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Calculus II(微積分 II)&lt;/td&gt;
&lt;td&gt;Calculus I&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Linear Algebra(線性代數)&lt;/td&gt;
&lt;td&gt;Calculus II&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Analysis of Algorithm(演算法分析)&lt;/td&gt;
&lt;td&gt;Data Structures, Linear Algebra&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Assembly Language(組合語言)&lt;/td&gt;
&lt;td&gt;Data Structures&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Operating Systems(作業系統)&lt;/td&gt;
&lt;td&gt;Analysis of Algorithm, Assembly Language&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Programming Language(程式語言)&lt;/td&gt;
&lt;td&gt;Analysis of Algorithm&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Compiler Design(編譯器設計)&lt;/td&gt;
&lt;td&gt;Programming Language&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Artificial Intelligence(人工智慧)&lt;/td&gt;
&lt;td&gt;Analysis of Algorithm&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Computational Theory(計算機理論)  &amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/td&gt;
&lt;td&gt;Analysis of Algorithm&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Parallel Algorithms(平行演算法)&lt;/td&gt;
&lt;td&gt;Computational Theory&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Numerical Analysis(數值方法)&lt;/td&gt;
&lt;td&gt;Calculus II&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;表一：某計算機科學學位之必修課程表&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;第一眼或許不太容易立即由表格獲得修課順序的資訊，因為表格受限於上至下、左至右的格式，只能逐項列出資訊，不容易表達資料與資料間的「先後關係」。&lt;/p&gt;
&lt;p&gt;現在換個方式，將具有先後修課順序的課程以線段與箭號連接，若A是B的先修課程，則箭號由A指向B，即可將表一轉換成圖一：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="prerequisites" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/Intro_fig/f_1.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;由圖一，將資料與資料的「先後關係」以「資料節點」與「線段(箭號)」表示，攻讀這門計算機科學學位的修課流程圖便一目了然。&lt;/p&gt;
&lt;p&gt;這樣的想法，不只是將表格轉換成對人類視覺上有意義的「圖」而已，對電腦來說，由於以Graph建立之模型能夠保持資料之間的「關係」，使得各種巧妙的演算法能夠在Graph中完成各種任務。&lt;br /&gt;
(反例：若要把在Graph上實現的各種演算法，如法炮製在以二維陣列表示的表一上，將會非常困難。)&lt;/p&gt;
&lt;p&gt;本篇文章的重點著重在介紹Graph(圖)的定義與實現方式，而接下來的文章將介紹一些基本的與Graph相關之演算法。&lt;/p&gt;
&lt;p&gt;&lt;a name="graph"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;Graph的定義&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;在圖一中，每一門課程被視為「資料節點」，且課程與課程之間有「線段(箭號)」連結：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;vertex&lt;/strong&gt;：稱每一個「資料節點」為vertex(或是node)，並定義所有的vertex所形成之集合(Set)為&lt;span class="math"&gt;\(V\)&lt;/span&gt;或&lt;span class="math"&gt;\(V(G)\)&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;edge&lt;/strong&gt;：稱每一個「線段(箭號)」為edge(實際上是用一對vertex表示edge，例如&lt;span class="math"&gt;\((V_i,V_j)\)&lt;/span&gt;即為連結V&lt;sub&gt;i&lt;/sub&gt;與V&lt;sub&gt;j&lt;/sub&gt;的edge)，並定義所有的edge所形成之集合(Set)為&lt;span class="math"&gt;\(E\)&lt;/span&gt;或&lt;span class="math"&gt;\(E(G)\)&lt;/span&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;則Graph定義為&lt;span class="math"&gt;\(V\)&lt;/span&gt;與&lt;span class="math"&gt;\(E\)&lt;/span&gt;所形成的集合，表示成&lt;span class="math"&gt;\(G(V,E)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;再根據edge是否具有「方向性」，可以將Graph分成「directed graph(有向圖)」與「undirected graph(無向圖)」：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;directed graph(有向圖)&lt;/strong&gt;：edge的方向性表示資料間的關係，若vertex(A)與vertex(B)之關係是「單向的」，那麼連結vertex(A)與vertex(B)的edge即具有方向性。  &lt;ul&gt;
&lt;li&gt;以圖一中的課程與其先修科目為例，vertex(Data Structures)是vertex(Analysis of Algorithm)的先修課程，相反則否，因此，連結兩個vertex之edge具有方向性，而所有vertex與edge形成之集合即為directed graph；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;undirected graph(無向圖)&lt;/strong&gt;：edge的方向性表示資料間的關係，若vertex(A)與vertex(B)的關係是「雙向的」，那麼連結vertex(A)與vertex(B)之edge就不具有方向性。  &lt;ul&gt;
&lt;li&gt;如圖二中，如果能夠開車從玉山抵達太魯閣，就能夠從太魯閣原路折返回到玉山，因此，這兩個地理位置之間的交通路線便不具有方向性。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="google_map" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/Intro_fig/f_2.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二：Google Map路線規劃，開車過去要4小時34分鐘。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;再看幾個Graph的範例。&lt;br /&gt;
圖三(a)中的G&lt;sub&gt;1&lt;/sub&gt;與G&lt;sub&gt;2&lt;/sub&gt;為undirected graph，圖三(b)中的G&lt;sub&gt;3&lt;/sub&gt;與G&lt;sub&gt;4&lt;/sub&gt;為directed graph。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="undirected" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/Intro_fig/f3.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(a)：Tree(樹)也是undirected graph(無向圖)。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="directed" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/Intro_fig/f4.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(b)：directed graph(有向圖)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="represent"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;表示法(representation)&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;那麼該如何表示Graph呢？&lt;br /&gt;
一般有兩種常用的表示法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Adjacency Matrix(相鄰矩陣)&lt;/strong&gt;：一個二維矩陣，若從vertex(A)到vertex(B)有edge，則矩陣位置[A][B]值為&lt;span class="math"&gt;\(1\)&lt;/span&gt;，反之，則為&lt;span class="math"&gt;\(0\)&lt;/span&gt;。  &lt;ul&gt;
&lt;li&gt;以圖四為例，在undireced graph中，vertex(X)與vertex(Y)之間有edge，則矩陣位置[X][Y]與[Y][X]之值皆為&lt;span class="math"&gt;\(1\)&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;在directed graph中，有從vertex(X)指向vertex(Y)的edge，則矩陣位置[X][Y]之值為&lt;span class="math"&gt;\(1\)&lt;/span&gt;，但是沒有反向的edge，因此矩陣位置[Y][X]之值為&lt;span class="math"&gt;\(0\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Adjacency List(相鄰串列)&lt;/strong&gt;：先以一個一維陣列列出所有的vertex，再以Linked list表示所有與vertex相連的vertex。&lt;br /&gt;
(vertex接進Linked list的順序不重要，因為是Graph是定義成Set。)  &lt;ul&gt;
&lt;li&gt;以圖四為例，在undireced graph中，vertex(W)與vertex(Z)、vertex(Y)、vertex(V)具有edge相連，則在一維陣列中表示vertex(W)之位置之後，依序接上vertex(Z)、vertex(Y)、vertex(V)。&lt;/li&gt;
&lt;li&gt;在direced graph中，vertex(W)僅僅剩下指向vertex(Y)與vertex(V)的edge，因此，在一維陣列中表示vertex(W)之位置之後，只要接上vertex(Y)與vertex(V)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="selfloop" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/Intro_fig/f_5.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四：Adjacency Matrix與Adjacency List適用於directed graph與undirected graph。&lt;/strong&gt; 
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;比較兩者的差異：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用記憶體空間：&lt;ol&gt;
&lt;li&gt;Adjacency Matrix：一定會用到&lt;span class="math"&gt;\(O(|V|^2)\)&lt;/span&gt;，因此，若Graph較為「稠密(dense)」，各vertex之間的edge數量較多則適合使用Adjacency Matrix；&lt;/li&gt;
&lt;li&gt;Adjacency List：將使用&lt;span class="math"&gt;\(O(|V|+|E|)\)&lt;/span&gt;，因此，若Graph較為「稀疏(sparse)」，edge數量較少，如圖一的Graph，即適合使用Adjacency List。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;存取資料：&lt;ol&gt;
&lt;li&gt;Adjacency Matrix：由於Matrix是連續記憶體，在存取資料時會稍微快一些；&lt;/li&gt;
&lt;li&gt;Adjacency List：同理，若是使用動態記憶體配置建立Linked list，則資料存取會稍慢(這項缺點可以使用C++的STL::Vector解決，不過STL::Vector不適合用在動態改變的Graph上)。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;新增edge：&lt;ol&gt;
&lt;li&gt;Adjacency Matrix：在Matrix中增加一條edge僅僅是把矩陣中相對應位置的值從&lt;span class="math"&gt;\(0\)&lt;/span&gt;設成&lt;span class="math"&gt;\(1\)&lt;/span&gt;，只需要&lt;span class="math"&gt;\(O(1)\)&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;Adjacency List：若每次都把新的vertex加在List的最前端(front)，也只需要&lt;span class="math"&gt;\(O(1)\)&lt;/span&gt;。不過，最壞情況(worst case)發生在「某個vertex與其他vertex全部相連」，因此需要&lt;span class="math"&gt;\(O(|E|)\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;刪除edge：&lt;ol&gt;
&lt;li&gt;Adjacency Matrix：在Matrix中刪除edge僅僅是把矩陣中相對應位置的值從&lt;span class="math"&gt;\(1\)&lt;/span&gt;設成&lt;span class="math"&gt;\(0\)&lt;/span&gt;，只需要&lt;span class="math"&gt;\(O(1)\)&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;Adjacency List：如同在Linked list中刪除資料，需要&lt;span class="math"&gt;\(O(|E|)\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name="terminology"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;一些名詞解釋&lt;/strong&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;adjacent(相鄰)&lt;/strong&gt;：若在vertex(A)與vertex(B)之間有一條edge(不論是否具有方向性)，則稱vertex(A)與vertex(B)為adjacent(相鄰)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;subgraph(子圖)&lt;/strong&gt;：若構成G'的兩個集合滿足&lt;span class="math"&gt;\(V(G')\subseteq V(G), E(G')\subseteq E(G)\)&lt;/span&gt;，則稱G'為G的subgraph，如圖五。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="subgraph" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/Intro_fig/f_6.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五：G與G的subgraph。&lt;/strong&gt; 
&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;path(路徑)&lt;/strong&gt;：若從vertex(V&lt;sub&gt;1&lt;/sub&gt;)到vertex(V&lt;sub&gt;k&lt;/sub&gt;)存在一連串前後相接的edge(&lt;span class="math"&gt;\((V_i,V_{i+1})\subseteq E(G),i=1,2,...,k-1\)&lt;/span&gt;)，則稱這一連串edge為「從vertex(V&lt;sub&gt;1&lt;/sub&gt;)到vertex(V&lt;sub&gt;k&lt;/sub&gt;)的path」。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;length(長度)/distance(距離)&lt;/strong&gt;：length(或distance)即是path中的edge數。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;simple path(簡單路徑)&lt;/strong&gt;：若一條path中，除了起點vertex與終點vertex之外，沒有vertex被重複經過，則稱這條path為simple path。  &lt;ul&gt;
&lt;li&gt;如圖六中，path:X-&amp;gt;Y-&amp;gt;Z即為simple path，path:W-&amp;gt;Y-&amp;gt;Z-&amp;gt;V-&amp;gt;W也是simple path，即使W有重複，但是因為分別是起點與終點，所以仍符合定義。而path:Y-&amp;gt;X-&amp;gt;Y-&amp;gt;W就不是simple path，因為第二次經過Y時，Y不是終點。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="subgraph" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/Intro_fig/f_7.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖六：。&lt;/strong&gt; 
&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;cycle(循環)&lt;/strong&gt;：若有ㄧ條「simple path」的起點vertex與終點vertex相同，則稱這條path為cycle。  &lt;ul&gt;
&lt;li&gt;圖六中的path:W-&amp;gt;Y-&amp;gt;Z-&amp;gt;V-&amp;gt;W，又稱為directed cycle(有向循環)；&lt;/li&gt;
&lt;li&gt;圖七中的path:Y-&amp;gt;V-&amp;gt;W-&amp;gt;Y與path:X-&amp;gt;Y-&amp;gt;W-&amp;gt;Z-&amp;gt;X皆為undirected cycle(無向循環)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;acyclic graph(無循環圖)&lt;/strong&gt;：若graph中不存在cycle，則稱這個graph為acyclic graph，見圖七。  &lt;ul&gt;
&lt;li&gt;在Tree中找不到任何一條simple path的起點與終點是相同vertex(node)，因此Tree一定是acyclic graph。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="subgraph" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/Intro_fig/f_8.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖七：。&lt;/strong&gt; 
&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;weight(權重)&lt;/strong&gt;：若要表示兩個地理位置之間的「距離」或是運送「成本」，可以在edge上加上weight，這樣的graph又稱為weighted graph，如圖八。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="subgraph" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/Intro_fig/f_9.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖八：weight的值可能為正或是負。&lt;/strong&gt; 
&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;connected&lt;/strong&gt;：若存在從vertex(A)指向vertex(B)、以及從vertex(B)指向vertex(A)的edge(若是在directed graph中，需要兩條edge；若是undirected graph只需要一條edge)，則稱vertex(A)與vertex(B)為connected，見圖九(a)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="subgraph" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/Intro_fig/f_10.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖九(a)：。&lt;/strong&gt; 
&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;connected in undirected graph&lt;/strong&gt;：若在undirected graph中，對任意兩個vertex都存在一條path連結這兩個vertex，則稱此undirected graph是connected。  &lt;ul&gt;
&lt;li&gt;圖九(b)中，G&lt;sub&gt;1&lt;/sub&gt;中的所有vertex都可以經過一條path到達其他vertex，因此G&lt;sub&gt;1&lt;/sub&gt;為connected。  &lt;/li&gt;
&lt;li&gt;G&lt;sub&gt;2&lt;/sub&gt;中，vertex:X、S、Z分別與vertex:Y、W、T之間皆不存在path，因此G&lt;sub&gt;2&lt;/sub&gt;不是connected。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;connected component&lt;/strong&gt;：若在一個undirected graph中，存在某一個subgraph是connected，而且沒有任何vertex、edge再加入這個subgraph之集合後仍能使得這個subgraph維持connected特性，則稱此subgraph為connected component(最大集合的connected subgraph)。  &lt;ul&gt;
&lt;li&gt;圖九(b)中，右上方為G&lt;sub&gt;1&lt;/sub&gt;的其中一個subgraph。此subgraph不是connected component，原因在於，再加入vertex:W、T，以及edge:(Y,W)、(Y,T)，也就是變回G&lt;sub&gt;1&lt;/sub&gt;後，仍然維持connected特性，因此這個subgraph並不是「可以維持connected的最大集合」。&lt;br /&gt;
換句話說，在一個connected的undirected graph中，只會有一個connected component，就是graph本身。  &lt;/li&gt;
&lt;li&gt;圖九(b)的G&lt;sub&gt;2&lt;/sub&gt;本身不是connected，而是由兩個connected component組成。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="subgraph" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/Intro_fig/f_11.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖九(b)：。&lt;/strong&gt; 
&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;strongly connected in directed graph&lt;/strong&gt;：若在directed graph中，對任意兩個vertex都存在一條path連結這兩個vertex，則稱此directed graph是strongly connected。&lt;ul&gt;
&lt;li&gt;圖九(c)，G&lt;sub&gt;3&lt;/sub&gt;中的所有vertex都可以經過一條path到達其他vertex，因此G&lt;sub&gt;3&lt;/sub&gt;為strongly connected。&lt;/li&gt;
&lt;li&gt;G&lt;sub&gt;4&lt;/sub&gt;並非strongly connected，例如，vertex(Z)無法經由path到達vertex(S)，vertex(Y)無法經由path到達vertex(X)等等。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;strongly connected component&lt;/strong&gt;：若在一個directed graph中，存在某一個subgraph是strongly connected，而且沒有任何vertex、edge再加入這個subgraph之集合後仍能使得這個subgraph維持strongly connected特性，則稱此subgraph為strongly connected component(最大集合的strongly connected subgraph)。&lt;ul&gt;
&lt;li&gt;圖九(c)中，右上方為G&lt;sub&gt;3&lt;/sub&gt;的其中一個subgraph。此subgraph不是strongly connected component，原因在於，再加入edge:(W,Z)後(也就是變回G&lt;sub&gt;3&lt;/sub&gt;)，仍然維持connected特性，因此這個subgraph並不是「可以維持connected的最大集合」。&lt;br /&gt;
如同undirected graph，若一個directed graph本身是strongly sonnected，則本身也是唯一的strongly connected component。&lt;/li&gt;
&lt;li&gt;G&lt;sub&gt;4&lt;/sub&gt;是由三個strongly connected component組成。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="subgraph" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/Intro_fig/f_12.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖九(c)：。&lt;/strong&gt; 
&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;self-loop(自我迴圈)&lt;/strong&gt;：若有edge從vertex(A)指向vertex(A)，即稱為self-edge或是self-loop。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;multigraph(多邊圖)&lt;/strong&gt;：若在graph中相同的edge重複出現多次，則稱此圖為multigraph，之後要討論的Graph將排除此種情形。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="selfloop" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Graph%20series/Intro_fig/f_13.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖十：self-loop與multigraph在directed graph和undirected graph中定義皆相同。&lt;/strong&gt; 
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="app"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;預告：Graph的應用&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;在接下來的文章，主要將探討以下三個應用的演算法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Minimum Spanning Tree(MST，最小生成樹)&lt;/strong&gt;：給定一個connected、weighted的undirected graph，要在這個graph中，找到(1)連結所有vertex，而且(2)edge上的weight總和最小的「Tree」。&lt;br /&gt;
例如，鄉公所要鋪路，先以鄉公所為中心(&lt;code&gt;root&lt;/code&gt;)，把所有馬路必須到達的地區視為vertex，則路就是edge，那麼，鋪路的目標便是利用最低成本(weight總和最小)將馬路延伸到所有必須抵達的地區，這就是MST的問題。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Shortest Path(最短路徑)&lt;/strong&gt;：顧名思義，最短路徑即是找到vertex(A)與vertex(B)之間lenght最小的path，例如Google Map。&lt;br /&gt;
其中又可以分為：&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Single Source Single Destination&lt;/strong&gt;：從一個vertex，抵達特定的另一個vertex之最短路徑；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Single Source All Destination&lt;/strong&gt;：從一個vertex，抵達graph中其餘所有vertex之最短路徑；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;All Source Single Destination&lt;/strong&gt;：從每一個graph中的vertex抵達特定的vertex之最短路徑；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;All Source All Destination&lt;/strong&gt;：graph中的所有vertex抵達其餘所有vertex之最短路徑。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Network Flow(網路流)&lt;/strong&gt;：若現在有一個複雜的水管系統，水從入水口流入，經過許多互相連結、且孔徑不一的水管後，從出水口流出，目標是一次流入最大量的水。&lt;br /&gt;
其中可能遇到的問題如：由於水管的孔徑各不相同，若先流過一條半徑只有2公分的水管，則接在其後的水管的半徑即使再大，水流量仍會被半徑2公分的水管所限制，因此整體流量也就受限制。&lt;br /&gt;
如何分配水流在水管之間的流法，即是Network Flow要處理的問題。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;不過在介紹以上三項主題之前，下兩篇文章將先介紹在Graph中最基本的搜尋(Search)方法：Breadth First Search(BFS，廣度優先搜尋)與Depth First Search(DFS，深度優先搜尋)。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="ref"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;參考資料&lt;/strong&gt;：&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844"&gt;Introduction to Algorithms, Ch22&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376"&gt;Fundamentals of Data Structures in C++, Ch6&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.hackerearth.com/notes/graph-theory-part-i/"&gt;Hacker Earth：Graph Theory - Part I &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://theoryofprogramming.com/2014/12/24/graph-theory-basics/"&gt;Theory of Programming：Graph Theory Basics&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Tree_%28graph_theory%29"&gt;Wikipedia：Tree(graph theory)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.google.com.tw/maps/dir/%E7%8E%89%E5%B1%B1%E5%9C%8B%E5%AE%B6%E5%85%AC%E5%9C%92%E7%AE%A1%E7%90%86%E8%99%95+553%E5%8D%97%E6%8A%95%E7%B8%A3%E6%B0%B4%E9%87%8C%E9%84%89%E4%B8%AD%E5%B1%B1%E8%B7%AF%E4%B8%80%E6%AE%B5300%E8%99%9F/%E8%8A%B1%E8%93%AE%E7%B8%A3%E5%A4%AA%E9%AD%AF%E9%96%A3%E5%9C%8B%E5%AE%B6%E5%85%AC%E5%9C%92%E7%AE%A1%E7%90%86%E8%99%95/@23.9945162,121.0278493,10.35z/data=!4m13!4m12!1m5!1m1!1s0x34692ae27ea40fff:0xab9c90d0fc985ac5!2m2!1d120.8504096!2d23.8128448!1m5!1m1!1s0x34688286a79bc241:0x9c0222099dc32245!2m2!1d121.621627!2d24.158708?hl=zh-TW"&gt;Google Map：從玉山國家公園到太魯閣國家公園&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="C++"></category><category term="Graph"></category><category term="Intro"></category></entry><entry><title>Red Black Tree: Delete(刪除資料)與Fixup(修正)</title><link href="http://alrightchiu.github.io/SecondRound/red-black-tree-deleteshan-chu-zi-liao-yu-fixupxiu-zheng.html" rel="alternate"></link><updated>2016-01-30T14:11:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2016-01-30:SecondRound/red-black-tree-deleteshan-chu-zi-liao-yu-fixupxiu-zheng.html</id><summary type="html">&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;先備知識與注意事項&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;如同&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-insertxin-zeng-zi-liao-yu-fixupxiu-zheng.html"&gt;Red Black Tree: Insert(新增資料)與Fixup(修正)&lt;/a&gt;，RBT之Delete(刪除資料)方法同樣是先沿用&lt;code&gt;DeleteBST()&lt;/code&gt;，再對顏色利用&lt;code&gt;Rotation&lt;/code&gt;進行修正。&lt;br /&gt;
建議讀者在閱讀本篇文章之前，先復習&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-sortpai-xu-deleteshan-chu-zi-liao.html#delete"&gt;BST::DeleteBST(刪除資料)&lt;/a&gt;與&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-rotationxuan-zhuan.html"&gt;Red Black Tree: Rotation(旋轉)&lt;/a&gt;，會比較容易上手。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#violate"&gt;於RBT中Delete(刪除資料)可能違反RBT之特徵&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#bst"&gt;如同於BST中Delete(刪除資料)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#fixup"&gt;修正：DeleteFixUpRBT()&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#case1"&gt;Case1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#case2"&gt;Case2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#case3"&gt;Case3&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#case4"&gt;Case4&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#example"&gt;範例&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#code"&gt;程式碼&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#ref"&gt;參考資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#tree_series"&gt;Tree系列文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name="violate"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;於RBT中Delete(刪除資料)可能違反RBT之特徵&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;在RBT中執行Delete(刪除資料)時，若刪除之node為黑色，有可能違反三點RBT特徵：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;圖一(a)：若要刪除的node恰好為&lt;code&gt;root&lt;/code&gt;，而刪除後恰好是紅色的node遞補成為新的&lt;code&gt;root&lt;/code&gt;，此時便違反RBT之第二點特徵：&lt;code&gt;root&lt;/code&gt;一定要是黑色；&lt;/li&gt;
&lt;li&gt;圖一(b)：若刪除node後，出現紅色與紅色node相連之情形，則違反RBT之第四點特徵：紅色node之&lt;code&gt;child&lt;/code&gt;一定要是黑色；&lt;/li&gt;
&lt;li&gt;圖一(b)：若刪除之node是黑色，則所有包含被刪除node的path上之黑色node數必定會減少，若恰好被刪除之node不是&lt;code&gt;root&lt;/code&gt;，將會違反RBT之第五點特徵：站在任何一個node上，所有從該node走到其任意descendant的path上之黑色node數必定相同。&lt;br /&gt;
圖一(b)左：從&lt;code&gt;root&lt;/code&gt;node(B)出發至任意leaves的path上都有三個黑色node(包含&lt;code&gt;NIL&lt;/code&gt;)；&lt;br /&gt;
圖一(b)右：刪除node(D)後，path(node(B)-node(E)-node(C))上之黑色node數剩下&lt;span class="math"&gt;\(2\)&lt;/span&gt;個(包含&lt;code&gt;NIL&lt;/code&gt;)。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因此，需要對顏色進行修正，以滿足RBT特徵。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="violate" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete1.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(a)：違反RBT之第二點與第四點特徵。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="violate" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete2.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(b)：違反RBT之第四點與第五點特徵。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="bst"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;如同於BST中Delete(刪除資料)&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;RBT::DeleteRBT()&lt;/code&gt;之範例程式碼分成兩個部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第一部分，如同&lt;code&gt;DeleteBST()&lt;/code&gt;，依照欲刪除之node的&lt;code&gt;child&lt;/code&gt;個數分成三種情形處理：&lt;ol&gt;
&lt;li&gt;先確認BST中有沒有要刪除的node；&lt;/li&gt;
&lt;li&gt;把要刪除的node調整成「至多只有一個&lt;code&gt;child&lt;/code&gt;」；&lt;/li&gt;
&lt;li&gt;把要刪除的node的&lt;code&gt;child&lt;/code&gt;指向新的&lt;code&gt;parent&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;把要刪除的node的&lt;code&gt;parent&lt;/code&gt;指向新的&lt;code&gt;child&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;若實際上刪除的是「替身」，再把替身的資料放回BST中；&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;第二部分，若刪除的node是黑色，需要進行修正(Fix-Up)。 &lt;br /&gt;
&lt;/br&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;RBT&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;DeleteRBT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;KEY&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;              &lt;span class="c1"&gt;// 要刪除具有KEY的node&lt;/span&gt;

    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;delete_node&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;delete_node&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Search&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;KEY&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;             &lt;span class="c1"&gt;// 先確認BST中是否有具有KEY的node&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;delete_node&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;data not found.&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;     &lt;span class="c1"&gt;// 真正要被刪除並釋放記憶體的node&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;     &lt;span class="c1"&gt;// 要被刪除的node的child&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;delete_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;neel&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;delete_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;neel&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;delete_node&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
        &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Successor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;delete_node&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                                           &lt;span class="c1"&gt;// 經過以上的if-else, y至多只有一個child&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;neel&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;              &lt;span class="c1"&gt;// 將x設成y的child, 可能是實際資料, 也有可能是NIL&lt;/span&gt;
        &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
        &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                 &lt;span class="c1"&gt;// 即使x是NIL也要把x的parent指向有效的記憶體位置&lt;/span&gt;
                                           &lt;span class="c1"&gt;// 因為在FixUp時需要藉由x-&amp;gt;parent判斷x為leftchild或是rightchild&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;neel&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;                 &lt;span class="c1"&gt;// 再將要被刪除的node之parent指向新的child&lt;/span&gt;
        &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                    
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
        &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;delete_node&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;                &lt;span class="c1"&gt;// 若實際上是「替身」被刪除, 要把「替身」的資料放回RBT中&lt;/span&gt;
        &lt;span class="n"&gt;delete_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;SetKey&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;GetKey&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
        &lt;span class="n"&gt;delete_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;SetElement&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;GetElement&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;                   &lt;span class="c1"&gt;// 若刪除的node是黑色, 則要從x進行修正&lt;/span&gt;
        &lt;span class="n"&gt;DeleteFixedUpRBT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;a name="fixup"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;修正：DeleteFixUpRBT()&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;考慮在圖二之RBT中刪除node(B)，由於node(B)是黑色，必定違反RBT之特徵，因此需要修正。&lt;br /&gt;
(以下圖示中，白色的node表示顏色可能為黑色也可能為紅色，而且可能是一棵subtree或是&lt;code&gt;NIL&lt;/code&gt;，需視情況而定。)&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="original" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete3.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二：。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;根據&lt;code&gt;sibling&lt;/code&gt;之顏色與&lt;code&gt;sibling&lt;/code&gt;之&lt;code&gt;child&lt;/code&gt;之顏色，可以分為下列四種情形(Case)，如圖三：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Case1：&lt;code&gt;sibling&lt;/code&gt;為紅色；&lt;/li&gt;
&lt;li&gt;Case2：&lt;code&gt;sibling&lt;/code&gt;為黑色，而且&lt;code&gt;sibling&lt;/code&gt;的兩個&lt;code&gt;child&lt;/code&gt;都是黑色；&lt;/li&gt;
&lt;li&gt;Case3：&lt;code&gt;sibling&lt;/code&gt;為黑色，而且&lt;code&gt;sibling&lt;/code&gt;的&lt;code&gt;rightchild&lt;/code&gt;是黑色；&lt;/li&gt;
&lt;li&gt;Case4：&lt;code&gt;sibling&lt;/code&gt;為黑色，而且&lt;code&gt;sibling&lt;/code&gt;的&lt;code&gt;rightchild&lt;/code&gt;是紅色。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="4cases" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete4.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三：。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;DeleteFixUpRBT()&lt;/code&gt;的情形(Case)較為複雜，圖四是所有情形之循環圖：&lt;br /&gt;
(&lt;code&gt;current&lt;/code&gt;即是被刪除的node之&lt;code&gt;child&lt;/code&gt;)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若&lt;code&gt;current&lt;/code&gt;是黑色的，而且&lt;code&gt;current&lt;/code&gt;不為&lt;code&gt;root&lt;/code&gt;，則依情況進入四個Case；&lt;/li&gt;
&lt;li&gt;若進入Case1，修正後，將進入Case2、Case3或Case4；&lt;/li&gt;
&lt;li&gt;若進入Case2，有可能修正後即符合RBT特徵，也有可能根據新的&lt;code&gt;current&lt;/code&gt;之情形重新判斷起；&lt;/li&gt;
&lt;li&gt;若進入Case3，修正後必定進入Case4；&lt;/li&gt;
&lt;li&gt;若進入Case4，修正後必定符合RBT之特徵。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="flow" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete5.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四：。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="case1"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;Case1&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;若&lt;code&gt;sibling&lt;/code&gt;為紅色，修正方法如下，見圖五(a)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;將&lt;code&gt;sibling&lt;/code&gt;塗成黑色：node(E)塗成黑色；&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;current&lt;/code&gt;之&lt;code&gt;parent&lt;/code&gt;塗成紅色：node(C)塗成紅色；&lt;/li&gt;
&lt;li&gt;對&lt;code&gt;current&lt;/code&gt;之&lt;code&gt;parent&lt;/code&gt;做Left Rotation：對node(C)做Left Rotation；&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;sibling&lt;/code&gt;移動到&lt;code&gt;current-&amp;gt;parent&lt;/code&gt;的&lt;code&gt;rightchild&lt;/code&gt;：將&lt;code&gt;sibling&lt;/code&gt;移動至node(D)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="case1" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete6.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五(a)：。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;在上述步驟中，並沒有更改&lt;code&gt;current&lt;/code&gt;之記憶體位置和顏色，&lt;code&gt;current&lt;/code&gt;仍為黑色。不過其&lt;code&gt;sibling&lt;/code&gt;必定會變成黑色，因此將進入Case2、Case3或Case4。&lt;/p&gt;
&lt;p&gt;為什麼Case1經過以上修正還沒有結束？原因要回到刪除node之前的RBT。&lt;br /&gt;
圖五(b)左，展示了刪除node之前，以node(C)為&lt;code&gt;root&lt;/code&gt;的RBT(或是更大的RBT之subtree)的其中一種可能情況。&lt;br /&gt;
從node(C)往任何一個descendant leaf的path上之黑色node數為&lt;span class="math"&gt;\(3\)&lt;/span&gt;，刪除node(B)後，使得其中一條path的黑色node數減少，經過上述方法之調整，仍然無法使得所有path之黑色node數相同，如圖五(b)右。&lt;br /&gt;
不過Case1所提出的修正方法能夠將情況調整成Case2、Case3或Case4，並且修正至滿足RBT之特徵。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="case1" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete7.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五(b)：圖中的「Original」僅代表其中一種可能的情形。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="case2"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;Case2&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;若&lt;code&gt;sibling&lt;/code&gt;為黑色，並且&lt;code&gt;sibling&lt;/code&gt;之兩個&lt;code&gt;child&lt;/code&gt;皆為黑色，修正的方法如下，見圖五(c)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;將&lt;code&gt;sibling&lt;/code&gt;塗成紅色：node(E)塗成紅色；&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;current&lt;/code&gt;移至&lt;code&gt;currnet&lt;/code&gt;的&lt;code&gt;parent&lt;/code&gt;：&lt;code&gt;current&lt;/code&gt;移至node(c)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="case2" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete8.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五(c)：。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;經過上述步驟，根據新的&lt;code&gt;current&lt;/code&gt;node(C)之顏色，可以分成兩種情形：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若node(C)為紅色，則跳出迴圈，把node(C)塗黑，即可滿足RBT之特徵，如圖五(d)，其邏輯便是：將從node(C)出發往&lt;code&gt;leftchild&lt;/code&gt;與&lt;code&gt;rightchild&lt;/code&gt;path的黑色數目調整成與刪除之前(Original)相同；&lt;/li&gt;
&lt;li&gt;若node(C)為黑色，且node(C)不是&lt;code&gt;root&lt;/code&gt;，則繼續下一輪迴圈，重新判斷其屬於四種情況之何者並修正，如圖五(e)，從node(G)出發至任意descendant leaf之path上的黑色node數並不完全相同。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="case2" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete9.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五(d)：圖中的「Original」僅代表其中一種可能的情形。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="case2" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete10.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五(e)：圖中的「Original」僅代表其中一種可能的情形。此時的RBT還要繼續修正，見Case3。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="case3"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;Case3&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;若&lt;code&gt;sibling&lt;/code&gt;為黑色，並且&lt;code&gt;sibling&lt;/code&gt;之&lt;code&gt;rightchild&lt;/code&gt;為黑色，修正的方法如下，見圖五(f)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;將&lt;code&gt;sibling&lt;/code&gt;之&lt;code&gt;leftchild&lt;/code&gt;塗成黑色：node(D)塗成黑色；&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;sibling&lt;/code&gt;塗成紅色：node(E)塗成紅色；&lt;/li&gt;
&lt;li&gt;對&lt;code&gt;sibling&lt;/code&gt;進行Right Rotation：對node(E)進行Right Rotation；&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;sibling&lt;/code&gt;移至&lt;code&gt;current-&amp;gt;parent&lt;/code&gt;的&lt;code&gt;rightchild&lt;/code&gt;：將&lt;code&gt;sibling&lt;/code&gt;移至node(D)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="case3" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete11.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五(f)：。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;經過以上修正步驟，&lt;code&gt;sibling&lt;/code&gt;之&lt;code&gt;rightchild&lt;/code&gt;成為紅色，便進入Case4。&lt;/p&gt;
&lt;p&gt;&lt;a name="case4"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;Case4&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;若&lt;code&gt;sibling&lt;/code&gt;為黑色，並且&lt;code&gt;sibling&lt;/code&gt;之&lt;code&gt;rightchild&lt;/code&gt;為紅色，修正的方法如下，見圖五(g)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;將&lt;code&gt;sibling&lt;/code&gt;塗成&lt;code&gt;current&lt;/code&gt;之&lt;code&gt;parent&lt;/code&gt;的顏色：若node(C)是紅色，則將node(E)塗成紅色，若node(C)是黑色，則將node(E)塗成黑色；&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;parent&lt;/code&gt;塗成黑色：node(C)塗成黑色；&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;sibling&lt;/code&gt;之&lt;code&gt;rightchild&lt;/code&gt;塗成黑色：node(F)塗成黑色；&lt;/li&gt;
&lt;li&gt;對&lt;code&gt;parent&lt;/code&gt;進行Left Rotation：對node(C)做Left Rotation；&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;current&lt;/code&gt;移至&lt;code&gt;root&lt;/code&gt;，把&lt;code&gt;root&lt;/code&gt;塗黑。&lt;br /&gt;
(注意：圖五(d)之node(E)未必是RBT之&lt;code&gt;root&lt;/code&gt;。)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="case4" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete12.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五(g)：。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;如圖五(h)所示，Case4修正方法的邏輯便是：在刪除node(B)之後的RBT(或是subtree)中，將所有從&lt;code&gt;root&lt;/code&gt;位置(調整前是node(C)，調整後是node(E))出發往任意descendant leaf之path上的黑色數目調整成與刪除之前(Original)相同，因此，經過Case4的修正一定能夠滿足RBT之特徵。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="case4" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete13.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五(h)：圖中的「Original」僅代表其中一種可能的情形。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="example"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h4&gt;&lt;strong&gt;範例&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;接著以一個簡單的範例(圖六(a)之RBT)操作上述四種Case的修正方法。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="example" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete14.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖六(a)：。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;若考慮刪除node(19)，由於node(19)是黑色，需要修正。&lt;br /&gt;
接著判斷，node(19)的&lt;code&gt;child&lt;/code&gt;(為黑色的&lt;code&gt;NIL&lt;/code&gt;)之&lt;code&gt;sibling&lt;/code&gt;為黑色，且&lt;code&gt;sibling&lt;/code&gt;之&lt;code&gt;rightchild&lt;/code&gt;為黑色，符合Case3的描述，因此利用Case3之修正方法，見圖六(b)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;將&lt;code&gt;sibling&lt;/code&gt;之&lt;code&gt;leftchild&lt;/code&gt;塗成黑色：node(24)塗成黑色；&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;sibling&lt;/code&gt;塗成紅色：node(27)塗成紅色；&lt;/li&gt;
&lt;li&gt;對&lt;code&gt;sibling&lt;/code&gt;進行Right Rotation：對node(27)進行Right Rotation；&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;sibling&lt;/code&gt;移至&lt;code&gt;current-&amp;gt;parent&lt;/code&gt;的&lt;code&gt;rightchild&lt;/code&gt;：將&lt;code&gt;sibling&lt;/code&gt;移至node(24)；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接著進入Case4：&lt;code&gt;subling&lt;/code&gt;為黑色，而且&lt;code&gt;sibling&lt;/code&gt;之&lt;code&gt;rightchild&lt;/code&gt;為紅色，進行修正：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;將&lt;code&gt;sibling&lt;/code&gt;塗成&lt;code&gt;current&lt;/code&gt;之&lt;code&gt;parent&lt;/code&gt;的顏色：node(22)是黑色，則將node(24)塗成黑色；&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;parent&lt;/code&gt;塗成黑色：node(22)塗成黑色；&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;sibling&lt;/code&gt;之&lt;code&gt;rightchild&lt;/code&gt;塗成黑色：node(27)塗成黑色；&lt;/li&gt;
&lt;li&gt;對&lt;code&gt;parent&lt;/code&gt;進行Left Rotation：對node(22)做Left Rotation；&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;current&lt;/code&gt;移至&lt;code&gt;root&lt;/code&gt;，把&lt;code&gt;root&lt;/code&gt;塗黑。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="example" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete15.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖六(b)：。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;如此一來便再次滿足RBT之特徵限制，如圖六(c)。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="example" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete16.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖六(c)：。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;再考慮刪除黑色的node(45)，判斷：node(45)之&lt;code&gt;child&lt;/code&gt;(為黑色的&lt;code&gt;NIL&lt;/code&gt;)之&lt;code&gt;sibling&lt;/code&gt;為黑色，且&lt;code&gt;sibling&lt;/code&gt;之&lt;code&gt;rightchild&lt;/code&gt;為紅色，符合Case4的描述，並利用Case4方法修正，見圖六(d)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;將&lt;code&gt;sibling&lt;/code&gt;塗成&lt;code&gt;current&lt;/code&gt;之&lt;code&gt;parent&lt;/code&gt;的顏色：node(22)是黑色，則將node(24)塗成黑色；&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;parent&lt;/code&gt;塗成黑色：node(22)塗成黑色；&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;sibling&lt;/code&gt;之&lt;code&gt;rightchild&lt;/code&gt;塗成黑色：node(27)塗成黑色；&lt;/li&gt;
&lt;li&gt;對&lt;code&gt;parent&lt;/code&gt;進行Left Rotation：對node(22)做Left Rotation；&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;current&lt;/code&gt;移至&lt;code&gt;root&lt;/code&gt;，把&lt;code&gt;root&lt;/code&gt;塗黑。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="example" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete17.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖六(d)：。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;如此一來便再次滿足RBT之特徵限制，如圖六(e)。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="example" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete18.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖六(e)：。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;接著考慮刪除黑色的node(39)，判斷：node(45)之&lt;code&gt;child&lt;/code&gt;(為黑色的&lt;code&gt;NIL&lt;/code&gt;)之&lt;code&gt;sibling&lt;/code&gt;為紅色，符合Case1之描述，便利用Case1之方法，調整成Case4，見圖六(f)：&lt;/p&gt;
&lt;p&gt;Case1調整：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;將&lt;code&gt;sibling&lt;/code&gt;塗成黑色：node(52)塗成黑色；&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;current&lt;/code&gt;之&lt;code&gt;parent&lt;/code&gt;塗成紅色：node(41)塗成紅色；&lt;/li&gt;
&lt;li&gt;對&lt;code&gt;current&lt;/code&gt;之&lt;code&gt;parent&lt;/code&gt;做Left Rotation：對node(41)做Left Rotation；&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;sibling&lt;/code&gt;移動到&lt;code&gt;current-&amp;gt;parent&lt;/code&gt;的&lt;code&gt;rightchild&lt;/code&gt;：將&lt;code&gt;sibling&lt;/code&gt;移動至node(48)；  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;再利用Case4的方法修正，便能滿足RBT之特徵，見圖六(g)。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="example" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete19.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖六(f)：。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="example" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete20.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖六(g)：。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;若要刪除黑色的node(7)，由於其&lt;code&gt;child&lt;/code&gt;之&lt;code&gt;sibling&lt;/code&gt;為黑色，且具有兩個黑色的&lt;code&gt;child&lt;/code&gt;(都是&lt;code&gt;NIL&lt;/code&gt;)，符合Case2的情況，便修正如下，見圖六(h)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;將&lt;code&gt;sibling&lt;/code&gt;塗成紅色：node(10)塗成紅色；&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;current&lt;/code&gt;移至&lt;code&gt;currnet&lt;/code&gt;的&lt;code&gt;parent&lt;/code&gt;：&lt;code&gt;current&lt;/code&gt;移至node(9)；&lt;/li&gt;
&lt;li&gt;若新的&lt;code&gt;current&lt;/code&gt;node(9)為紅色，即跳出迴圈，並將&lt;code&gt;current&lt;/code&gt;塗黑。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;經修正後，便符合RBT之特徵，見圖六(i)。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="example" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete21.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖六(h)：。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="example" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete22.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖六(i)：。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;最後，若要刪除黑色的node(3)呢？由於node(3)的&lt;code&gt;child&lt;/code&gt;node(1)為紅色，並不需要考慮到Case1(&lt;code&gt;sibling&lt;/code&gt;為紅色)，只要將node(1)塗黑即可，如圖六(j)。  &lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="example" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Delete/delete23.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖六(j)：。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="code"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;程式碼&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;DeleteFixedUpRBT()&lt;/code&gt;之範例程式碼分成以下幾個部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如圖四所示，修正的過程可能經歷不止一個Case，因此利用&lt;code&gt;while&lt;/code&gt;來實現，條件式為：&lt;code&gt;current&lt;/code&gt;不是&lt;code&gt;root&lt;/code&gt;，而且&lt;code&gt;current&lt;/code&gt;為黑色；&lt;/li&gt;
&lt;li&gt;若&lt;code&gt;current&lt;/code&gt;是其&lt;code&gt;parent&lt;/code&gt;之&lt;code&gt;leftchild&lt;/code&gt;，其&lt;code&gt;sibling&lt;/code&gt;就必須是&lt;code&gt;rightchild&lt;/code&gt;，反之亦然，而兩種情形之&lt;code&gt;Rotation&lt;/code&gt;修正之方向正好相反，因此，如同&lt;code&gt;InsertFixedUpRBT()&lt;/code&gt;，必須區分出「&lt;code&gt;current&lt;/code&gt;是其&lt;code&gt;parent&lt;/code&gt;之&lt;code&gt;leftchild&lt;/code&gt;」與「&lt;code&gt;current&lt;/code&gt;是其&lt;code&gt;parent&lt;/code&gt;之&lt;code&gt;rightchild&lt;/code&gt;」兩種情況；&lt;/li&gt;
&lt;li&gt;分別進行Case1、Case2、Case3與Case4之修正；&lt;/li&gt;
&lt;li&gt;最後，在line74的&lt;code&gt;current-&amp;gt;color = 1&lt;/code&gt;將&lt;code&gt;current&lt;/code&gt;之顏色塗黑，有可能在Case2用上，見圖五(d)與圖六(h)。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;RBT&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;DeleteFixedUpRBT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="c1"&gt;// Case0:(i)  current是紅色的, 不影響黑色在path上的數量&lt;/span&gt;
    &lt;span class="c1"&gt;//       (ii) current是root,&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;// current是leftchild&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;    
            &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;sibling&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="c1"&gt;// Case1: 如果sibling是紅色&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sibling&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;sibling&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;LeftRotation&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                &lt;span class="n"&gt;sibling&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
            &lt;span class="c1"&gt;// 進入 Case2、3、4: sibling是黑色&lt;/span&gt;
            &lt;span class="c1"&gt;// Case2: sibling的兩個child都是黑色&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sibling&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;sibling&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;sibling&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
            &lt;span class="c1"&gt;// Case3 &amp;amp; 4:&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;// case3: sibling的right child是黑的, 不管left child, 因為馬上會被塗黑&lt;/span&gt;
                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sibling&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
                    &lt;span class="n"&gt;sibling&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                    &lt;span class="n"&gt;sibling&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                    &lt;span class="n"&gt;RightRotation&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sibling&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                    &lt;span class="n"&gt;sibling&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="p"&gt;}&lt;/span&gt;
                &lt;span class="c1"&gt;// 經過Case3後, 一定會變成Case4&lt;/span&gt;
                &lt;span class="c1"&gt;// Case 4: sibling的right child 是紅色的&lt;/span&gt;
                &lt;span class="n"&gt;sibling&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;sibling&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;LeftRotation&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;     &lt;span class="c1"&gt;// 只要進到Case4後, 一定跳出回圈&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;

        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="c1"&gt;// current是rightchild&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;  
            &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;sibling&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="c1"&gt;// Case1: 如果sibling是紅色&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sibling&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;sibling&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;RightRotation&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                &lt;span class="n"&gt;sibling&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
            &lt;span class="c1"&gt;// 進入 Case2、3、4: sibling是黑色&lt;/span&gt;
            &lt;span class="c1"&gt;// Case2: sibling的兩個child都是黑色&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sibling&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;sibling&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;sibling&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
            &lt;span class="c1"&gt;// Case3 &amp;amp; 4:&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;// case3: sibling的left child是黑的, 不管right child, 因為馬上會被塗黑&lt;/span&gt;
                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sibling&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
                    &lt;span class="n"&gt;sibling&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                    &lt;span class="n"&gt;sibling&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                    &lt;span class="n"&gt;LeftRotation&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sibling&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                    &lt;span class="n"&gt;sibling&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="p"&gt;}&lt;/span&gt;
                &lt;span class="c1"&gt;// 經過Case3後, 一定會變成Case4&lt;/span&gt;
                &lt;span class="c1"&gt;// Case 4: sibling的right child 是紅色的&lt;/span&gt;
                &lt;span class="n"&gt;sibling&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;sibling&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;RightRotation&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;     &lt;span class="c1"&gt;// 只要進到Case4後, 一定跳出回圈&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;/br&gt;
&lt;a name="ref"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;參考資料&lt;/strong&gt;：&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844"&gt;Introduction to Algorithms&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376"&gt;Fundamentals of Data Structures in C++&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://code.geeksforgeeks.org/NtLnIk"&gt;GeeksforGeeks：Red Black Tree&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name="tree_series"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;Tree系列文章&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/treeshu-introjian-jie.html"&gt;Tree(樹): Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-introjian-jie.html"&gt;Binary Tree: Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-traversalxun-fang.html"&gt;Binary Tree: Traversal(尋訪)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-jian-li-yi-ke-binary-tree.html"&gt;Binary Tree: 建立一棵Binary Tree&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-introjian-jie.html"&gt;Binary Search Tree: Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-searchsou-xun-zi-liao-insertxin-zeng-zi-liao.html"&gt;Binary Search Tree: Search(搜尋資料)、Insert(新增資料)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-sortpai-xu-deleteshan-chu-zi-liao.html"&gt;Binary Search Tree: Sort(排序)、Delete(刪除資料)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-introjian-jie.html"&gt;Red Black Tree: Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-rotationxuan-zhuan.html"&gt;Red Black Tree: Rotation(旋轉)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-insertxin-zeng-zi-liao-yu-fixupxiu-zheng.html"&gt;Red Black Tree: Insert(新增資料)與Fixup(修正)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-deleteshan-chu-zi-liao-yu-fixupxiu-zheng.html"&gt;Red Black Tree: Delete(刪除資料)與Fixup(修正)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="C++"></category><category term="Red Black Tree"></category></entry><entry><title>Red Black Tree: Insert(新增資料)與Fixup(修正)</title><link href="http://alrightchiu.github.io/SecondRound/red-black-tree-insertxin-zeng-zi-liao-yu-fixupxiu-zheng.html" rel="alternate"></link><updated>2016-01-27T20:09:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2016-01-27:SecondRound/red-black-tree-insertxin-zeng-zi-liao-yu-fixupxiu-zheng.html</id><summary type="html">&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;先備知識與注意事項&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;RBT也是一棵BST，而RBT之Insert(新增資料)方法便是先沿用&lt;code&gt;InsertBST()&lt;/code&gt;，再對顏色進行修正。而修正的方法將用上&lt;code&gt;Rotation()&lt;/code&gt;，因此，建議在閱讀本篇文章之前，先熟悉&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-searchsou-xun-zi-liao-insertxin-zeng-zi-liao.html"&gt;Binary Search Tree: Search(搜尋資料)、Insert(新增資料)&lt;/a&gt;與&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-rotationxuan-zhuan.html"&gt;Red Black Tree: Rotation(旋轉)&lt;/a&gt;會很有幫助。 &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#bst"&gt;如同於BST中Insert(新增資料)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#fixup"&gt;修正：InsertFixUpRBT()&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#case1"&gt;Case1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#case3"&gt;Case3&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#case2"&gt;Case2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#example"&gt;幾個範例&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#code"&gt;程式碼&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#ref"&gt;參考資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#tree_series"&gt;Tree系列文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name="bst"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;如同於BST中Insert(新增資料)&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;RBT也是一棵BST，在Insert(新增資料)時，必須滿足：&lt;span class="math"&gt;\(Key(L)&amp;lt;Key(Current)&amp;lt;Key(R)\)&lt;/span&gt;，因此，RBT的&lt;code&gt;InsertRBT()&lt;/code&gt;前半部演算法與&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-searchsou-xun-zi-liao-insertxin-zeng-zi-liao.html#insert"&gt;BST的函式：InsertBST()大同小異&lt;/a&gt;。&lt;br /&gt;
需要修改的部分有兩處：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;NIL&lt;/code&gt;：所有原先在BST中指向&lt;code&gt;NULL&lt;/code&gt;的pointer，在RBT中需要修正成指向&lt;code&gt;NIL&lt;/code&gt;，包括條件式與新增node的&lt;code&gt;child pointer&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;顏色：如同在&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-rotationxuan-zhuan.html#fail"&gt;RBT：Rotation(旋轉)&lt;/a&gt;所說，一般預設新增node為紅色，因此，若新增node接在黑色node之後，仍能滿足RBT的特徵，但是若新增node接在紅色node之後，則違反了&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-introjian-jie.html#rbt"&gt;RBT之第四點特徵&lt;/a&gt;，必須進行修正。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;InsertRBT()&lt;/code&gt;的程式範例如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;RBT&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;InsertRBT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="c1"&gt;// 前半部與 InsertBST()之邏輯完全相同, 僅僅需要修改 NULL &amp;lt;-&amp;gt; NIL&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;neel&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;insert_node&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// default copy constructor&lt;/span&gt;

    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;neel&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;     &lt;span class="c1"&gt;// 把root初始化成neel, 這裡就可以用neel來做判斷&lt;/span&gt;
        &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;insert_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;GetKey&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;GetKey&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
            &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;
            &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;insert_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;neel&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;insert_node&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;insert_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;GetKey&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;GetKey&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
        &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;insert_node&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
        &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;insert_node&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;// 以下是對RBT之node的設定, 將child pointer指向NIL, 顏色設為紅色&lt;/span&gt;
    &lt;span class="n"&gt;insert_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;neel&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;insert_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;neel&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;insert_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;             &lt;span class="c1"&gt;// 顏色可以在constructor中預設&lt;/span&gt;

    &lt;span class="n"&gt;InsertFixedUpRBT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;insert_node&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;      &lt;span class="c1"&gt;// 對可能出現紅色與紅色node相連之情形做修正&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;a name="fixup"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;修正：InsertFixUpRBT()&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;什麼情況需要對&lt;code&gt;InsertRBT()&lt;/code&gt;做修正？&lt;br /&gt;
當新增node接在紅色的node的&lt;code&gt;child pointer&lt;/code&gt;，形成紅色與紅色相連時。&lt;/p&gt;
&lt;p&gt;考慮以下情況，如圖一(a)，新增的node將要接在node(X)上：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;node(X)為其&lt;code&gt;parent&lt;/code&gt;，顏色為紅色；&lt;/li&gt;
&lt;li&gt;node(Y)為其&lt;code&gt;uncle&lt;/code&gt;，其顏色&lt;strong&gt;可能為紅色或黑色&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;node(Z)為其grandparent(&lt;code&gt;parent-&amp;gt;parent&lt;/code&gt;)，顏色必定為黑色；&lt;/li&gt;
&lt;li&gt;node(W)的顏色&lt;strong&gt;可能是紅色或黑色&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;所有灰色node(如node(a)、node(b)、node(c)、node(d))表示：只要不影響RBT之特徵，是否實際攜帶資料或為&lt;code&gt;NIL&lt;/code&gt;並不影響結果。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Insert/insert1.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(a)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;根據&lt;code&gt;uncle&lt;/code&gt;的顏色是紅色或者黑色，可以將修正(FixUp)分成三種情形(case)：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Case1：&lt;code&gt;uncle&lt;/code&gt;是紅色，不論新增的node是node(X)的&lt;code&gt;leftchild&lt;/code&gt;或&lt;code&gt;rightchild&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;Case2：&lt;code&gt;uncle&lt;/code&gt;是黑色，而且新增的node為node(X)的&lt;code&gt;rightchild&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;Case3：&lt;code&gt;uncle&lt;/code&gt;是黑色，而且新增的node為node(X)的&lt;code&gt;leftchild&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a name="case1"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;Case1&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;圖一(b)左，此時&lt;code&gt;current&lt;/code&gt;指向新增的node(A)，而node(A)成為node(X)的&lt;code&gt;rightchild&lt;/code&gt;，其&lt;code&gt;uncle&lt;/code&gt;node(Y)是紅色的。&lt;br /&gt;
修正的方法就是「把債還給上一代的上一代」：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;將&lt;code&gt;parent&lt;/code&gt;塗成黑色：node(X)塗成黑色；&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;uncle&lt;/code&gt;塗成黑色：node(Y)塗成黑色；&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;parent-&amp;gt;parent&lt;/code&gt;塗成紅色：node(Z)塗成紅色：&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;current&lt;/code&gt;從node(A)移到node(Z)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此時，如圖一(b)右，從node(Z)出發往其descendant leaves的任一path上之黑色node數皆相同，這個subtree便滿足了RBT的特徵。  &lt;/p&gt;
&lt;p&gt;接著必需根據node(W)的顏色採取不同行動：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若node(W)為黑色，就不需要再做調整；&lt;/li&gt;
&lt;li&gt;若node(W)為紅色，則node(Z)與node(W)再次形成紅色node與紅色node相連，必須重複同樣的判斷流程。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Insert/insert2.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(b)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;若node(A)成為node(X)的&lt;code&gt;leftchild&lt;/code&gt;，如圖一(c)，修正的方法同上。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Insert/insert3.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(c)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="case3"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;Case3&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;圖一(d)，新增的node(A)成為node(X)的&lt;code&gt;leftchild&lt;/code&gt;，其&lt;code&gt;uncle&lt;/code&gt;node(Y)是黑色。 &lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Insert/insert4.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(d)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;事實上，若&lt;code&gt;current&lt;/code&gt;指向之node(此為node(A))是新增的node，則根據RBT之第五點特徵，其&lt;code&gt;uncle&lt;/code&gt;node(Y)必定是&lt;code&gt;NIL&lt;/code&gt;，如圖一(e)左。&lt;/p&gt;
&lt;p&gt;不過，在稍後的範例中將會看到，&lt;code&gt;current&lt;/code&gt;不一定是「剛剛新增的node」，也有可能是「修正到一半，出現紅色與紅色相連的node」，但因為是「修正到一半」，尚未調整node(Z)的顏色，因此所有從node(Z)往其descendant leaves的任意path上之黑色node數必定不變，此時，若node(Y)不為&lt;code&gt;NIL&lt;/code&gt;，則node(X)以及node(A)必定還有黑色的&lt;code&gt;child pointer&lt;/code&gt;，如圖一(e)右所示，node(a)、node(b)與node(c)皆為黑色。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Insert/insert5.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(e)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;修正方法如下，見圖一(f)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;將&lt;code&gt;parent&lt;/code&gt;塗成黑色：node(X)塗成黑色；&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;parent-&amp;gt;parent&lt;/code&gt;塗成紅色：node(Z)塗成紅色；&lt;/li&gt;
&lt;li&gt;對&lt;code&gt;parent-&amp;gt;parent&lt;/code&gt;node(Z)進行&lt;strong&gt;Right Rotation(向右旋轉)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Insert/insert6.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(f)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;經過&lt;strong&gt;Case3&lt;/strong&gt;的修正，必定會滿足RBT之規則，原因在於：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先考慮圖一(e)，若從node(A)往其descendant leaves的任意path上之黑色node數為&lt;span class="math"&gt;\(M\)&lt;/span&gt;，則從node(Z)往其descendant leaves的任意path上之黑色node數為&lt;span class="math"&gt;\(M+1\)&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;再看圖一(g)，因為在修正的過程中，node(Z)從黑色被修改成紅色，因此從node(Z)往其descendant leaves的任意path上之黑色node數下修為&lt;span class="math"&gt;\(M\)&lt;/span&gt;，與node(A)相同，使得整棵樹滿足RBT之特徵。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Insert/insert7.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(g)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="case2"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;Case2&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;圖一(h)，新增的node(A)成為node(X)的&lt;code&gt;rightchild&lt;/code&gt;，其&lt;code&gt;uncle&lt;/code&gt;node(Y)是黑色。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Insert/insert8.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(h)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;如同Case3，圖一(h)的&lt;code&gt;uncle&lt;/code&gt;node(Y)同樣有兩種可能：攜帶實際資料的黑色node，或者&lt;code&gt;NIL&lt;/code&gt;，如圖一(i)：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Insert/insert9.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(i)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;而修正Case2的方法就是將其轉換成Case3，再利用上述Case3的方法調整成正確的RBT。&lt;br /&gt;
從Case2調整成Case3，如圖一(j)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;將&lt;code&gt;current&lt;/code&gt;移至&lt;code&gt;current-&amp;gt;parent&lt;/code&gt;：將&lt;code&gt;current&lt;/code&gt;從node(A)移到node(X)；&lt;/li&gt;
&lt;li&gt;對新的&lt;code&gt;current&lt;/code&gt;進行Left Rotation：對node(X)進行Left Rotation。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;圖一(j)右符合Case3：「&lt;code&gt;current&lt;/code&gt;成為其&lt;code&gt;parent&lt;/code&gt;的&lt;code&gt;leftchild&lt;/code&gt;，且其&lt;code&gt;uncle&lt;/code&gt;node(Y)是黑色」，因此，只要再進行如同圖一(f)之修正流程即可。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Insert/insert10.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(j)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="example"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h4&gt;&lt;strong&gt;幾個範例&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Example1&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;考慮一棵RBT如圖二(a)：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Insert/insert11.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(a)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;若想新增node(75)，由於其將接在node(80)的&lt;code&gt;leftchild&lt;/code&gt;位置上，而node(80)為紅色，因此需要進行修正。&lt;br /&gt;
接著觀察，node(75)之&lt;code&gt;uncle&lt;/code&gt;為node(60)，同樣是紅色，因此可以使用Case1的方法，如圖二(b)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;將&lt;code&gt;parent&lt;/code&gt;與&lt;code&gt;uncle&lt;/code&gt;塗黑：node(80)與node(60)塗黑；&lt;/li&gt;
&lt;li&gt;將grandparent塗紅：node(70)塗紅；&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;current&lt;/code&gt;移至node(70)；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;進入下一個迴圈&lt;/strong&gt;判斷node(70)是否與其&lt;code&gt;parent&lt;/code&gt;形成紅色與紅色node相連。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;恰好，node(50)為&lt;code&gt;root&lt;/code&gt;，一定是黑色，因此新增node(75)便算是完成。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Insert/insert12.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(b)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;若想繼續新增node(25)，由於其將接在node(30)的&lt;code&gt;leftchild&lt;/code&gt;，而node(30)為紅色，因此需要修正。&lt;br /&gt;
接著觀察，node(25)之&lt;code&gt;uncle&lt;/code&gt;為&lt;code&gt;NIL&lt;/code&gt;是黑色，而node(25)本身是&lt;code&gt;leftchild&lt;/code&gt;，因此可以使用Case3的方法，如圖二(c)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;將&lt;code&gt;parent&lt;/code&gt;塗成黑色：node(30)塗成黑色；&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;parent-&amp;gt;parent&lt;/code&gt;塗成紅色：node(40)塗成紅色；&lt;/li&gt;
&lt;li&gt;對&lt;code&gt;parent-&amp;gt;parent&lt;/code&gt;node(40)進行&lt;strong&gt;Right Rotation(向右旋轉)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Insert/insert13.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(c)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;若想繼續新增node(79)，由於其將接在node(75)的&lt;code&gt;rightchild&lt;/code&gt;，而node(75)為紅色，因此需要修正。&lt;br /&gt;
接著觀察，node(79)之&lt;code&gt;uncle&lt;/code&gt;為&lt;code&gt;NIL&lt;/code&gt;是黑色，而node(79)本身是&lt;code&gt;rightchild&lt;/code&gt;，因此可以使用Case2的方法，先將問題從Case2轉換成Case3，再由Case3之方法修正，如圖二(d)：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Insert/insert14.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(d)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example2&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;考慮一棵RBT如圖三(a)：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Insert/insert15.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(a)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;要在其中新增node(4)，則會依序經歷case1、case2直到case3完成修正，如圖三(b)、圖三(c)、圖三(d)與圖三(e)所示。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Insert/insert16.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(b)：。&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt;&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Insert/insert17.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(c)：。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Insert/insert18.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(d)：。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Insert/insert19.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(e)：。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;根據以上說明，可以歸納出對於&lt;code&gt;InsertRBT()&lt;/code&gt;的修正(Fix-Up)之情形(Case)間的循環圖，如圖四：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;當新增node之&lt;code&gt;parent&lt;/code&gt;為紅色時，需要對RBT進行修正；&lt;/li&gt;
&lt;li&gt;若進入Case1，有可能執行一次即完成，也有可能再次出現紅色與紅色相連的情況，如圖三(b)-(c)；&lt;/li&gt;
&lt;li&gt;若進入Case2，就轉換成Case3的情境；&lt;/li&gt;
&lt;li&gt;一旦進入Case3，經過修正後必定能滿足RBT之特徵限制。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Insert/insert20.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;最後還有一點需要說明。&lt;/p&gt;
&lt;p&gt;圖五中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;左圖是本篇文章介紹修正(Fix-Up)的出發點：將新增的node接在node(X)上，而node(X)是node(Z)的&lt;code&gt;leftchild&lt;/code&gt;(&lt;code&gt;parent&lt;/code&gt;是&lt;code&gt;parent-&amp;gt;parent&lt;/code&gt;的&lt;code&gt;leftchild&lt;/code&gt;)；&lt;/li&gt;
&lt;li&gt;還有另外一半的情況就如圖五之右圖：將新增的node接在node(Y)上，而node(Y)是node(Z)的&lt;code&gt;rightchild&lt;/code&gt;(&lt;code&gt;parent&lt;/code&gt;是&lt;code&gt;parent-&amp;gt;parent&lt;/code&gt;的&lt;code&gt;rightchild&lt;/code&gt;)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Insert/insert21.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;必須要區分這兩者的原因有二：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一是&lt;code&gt;uncle&lt;/code&gt;：因為&lt;code&gt;parent&lt;/code&gt;與&lt;code&gt;uncle&lt;/code&gt;分別為&lt;code&gt;parent-&amp;gt;parent&lt;/code&gt;之&lt;code&gt;leftchild&lt;/code&gt;與&lt;code&gt;rightchild&lt;/code&gt;，若&lt;code&gt;parent&lt;/code&gt;是&lt;code&gt;left-&lt;/code&gt;，&lt;code&gt;uncle&lt;/code&gt;就要是&lt;code&gt;right-&lt;/code&gt;，反之亦然，兩者屬於互斥(exclusive)的、不能同時發生的情境；&lt;/li&gt;
&lt;li&gt;二是Rotation(旋轉)：在Case2與Case3中必須使用Left/Right Rotation，因此，延續第一點原因，考慮到&lt;code&gt;parent&lt;/code&gt;是&lt;code&gt;leftchild&lt;/code&gt;或是&lt;code&gt;rightchild&lt;/code&gt;的不同，Left/Right Rotation的方向也會相反。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name="code"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;程式碼&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;InsertFixedUpRBT()&lt;/code&gt;之範例程式碼分成以下幾個部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定義&lt;code&gt;color&lt;/code&gt;：0為紅色，1為黑色；&lt;/li&gt;
&lt;li&gt;如同圖四所示，修正的過程可能歷經不止一個Case，因此利用&lt;code&gt;while&lt;/code&gt;迴圈實現，條件式便是判斷當前&lt;code&gt;current&lt;/code&gt;之&lt;code&gt;parent&lt;/code&gt;是否為紅色；&lt;/li&gt;
&lt;li&gt;分別進行Case1(圖一(b)與圖一(c))、Case2(圖一(j))與Case3(圖一(f))之修正；&lt;/li&gt;
&lt;li&gt;最後，在&lt;strong&gt;line50&lt;/strong&gt;出現一行&lt;code&gt;root-&amp;gt;color=1&lt;/code&gt;，將&lt;code&gt;root&lt;/code&gt;之顏色塗黑，這是為了Case1所設，由於Case1之修正方法是把「紅色與紅色node相連」之可能性往&lt;code&gt;root&lt;/code&gt;方向傳遞，有可能&lt;code&gt;root&lt;/code&gt;恰好是&lt;code&gt;current&lt;/code&gt;的grandparent而被塗成紅色，如圖六，但因為RBT之第二點特徵要求&lt;code&gt;root&lt;/code&gt;一定是黑色，因此必須作此預防。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Insert/insert22.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖六：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;RBT&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;InsertFixedUpRBT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="c1"&gt;// Case0: parent是黑色, 就不用進迴圈&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;   &lt;span class="c1"&gt;// 若parent是紅色即進入迴圈&lt;/span&gt;
        &lt;span class="c1"&gt;// 上半部：parent為grandparent的leftchild之情況，如圖五左&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; 
            &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;uncle&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="c1"&gt;// 若uncle是紅色：Case1&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;uncle&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;uncle&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//grandparent改成紅色&lt;/span&gt;
                &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
            &lt;span class="c1"&gt;// 若uncle是黑色：Case2 or Case3&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="c1"&gt;// 若current是rightchild：Case2  &lt;/span&gt;
                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;        
                    &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                    &lt;span class="n"&gt;LeftRotation&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                &lt;span class="p"&gt;}&lt;/span&gt;
                &lt;span class="c1"&gt;// 若current是leftchild：Case3&lt;/span&gt;
                &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;     
                &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;     
                &lt;span class="n"&gt;RightRotation&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="c1"&gt;// 下半部：parent為grandparent的rightchild之情況，如圖五右&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;  
            &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;uncle&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="c1"&gt;// 若uncle是紅色：Case1&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;uncle&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;uncle&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//grandparent改成紅色&lt;/span&gt;
                &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
            &lt;span class="c1"&gt;// 若uncle是黑色：Case2 or Case3&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                    &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                    &lt;span class="n"&gt;RightRotation&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                &lt;span class="p"&gt;}&lt;/span&gt;
                &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;LeftRotation&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;/br&gt;
&lt;a name="ref"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;參考資料&lt;/strong&gt;：&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844"&gt;Introduction to Algorithms, Ch13&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376"&gt;Fundamentals of Data Structures in C++&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://code.geeksforgeeks.org/NtLnIk"&gt;GeeksforGeeks：Red Black Tree&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name="tree_series"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;Tree系列文章&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/treeshu-introjian-jie.html"&gt;Tree(樹): Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-introjian-jie.html"&gt;Binary Tree: Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-traversalxun-fang.html"&gt;Binary Tree: Traversal(尋訪)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-jian-li-yi-ke-binary-tree.html"&gt;Binary Tree: 建立一棵Binary Tree&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-introjian-jie.html"&gt;Binary Search Tree: Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-searchsou-xun-zi-liao-insertxin-zeng-zi-liao.html"&gt;Binary Search Tree: Search(搜尋資料)、Insert(新增資料)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-sortpai-xu-deleteshan-chu-zi-liao.html"&gt;Binary Search Tree: Sort(排序)、Delete(刪除資料)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-introjian-jie.html"&gt;Red Black Tree: Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-rotationxuan-zhuan.html"&gt;Red Black Tree: Rotation(旋轉)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-insertxin-zeng-zi-liao-yu-fixupxiu-zheng.html"&gt;Red Black Tree: Insert(新增資料)與Fixup(修正)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-deleteshan-chu-zi-liao-yu-fixupxiu-zheng.html"&gt;Red Black Tree: Delete(刪除資料)與Fixup(修正)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="C++"></category><category term="Red Black Tree"></category></entry><entry><title>Red Black Tree: Rotation(旋轉)</title><link href="http://alrightchiu.github.io/SecondRound/red-black-tree-rotationxuan-zhuan.html" rel="alternate"></link><updated>2016-01-24T23:06:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2016-01-24:SecondRound/red-black-tree-rotationxuan-zhuan.html</id><summary type="html">&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;先備知識與注意事項&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;雖說是Rotation(旋轉)，但其實沒有這麼神奇，只是視覺上看起來像旋轉，在電腦實際將讀取的程式碼實現上，僅僅是數個pointer之指向的重新改寫，所以千萬別害怕。&lt;/p&gt;
&lt;p&gt;本篇文章的第一部分將以Insert(新增資料)與Delete(刪除資料)來說明為什麼需要Rotation(旋轉)，但是讀者可以先不必理會細節，因為實際上的Insert與Delete將有更多情況必須考慮，此部分將留待後續文章逐項說明，在本篇文章只要掌握Rotation(旋轉)即可。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#fail"&gt;於RBT中進行Insert與Delete後竟然不符合RBT&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#rotation"&gt;Rotation(旋轉)&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#left-rotate"&gt;Left Rotation(向左轉)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#right-rotate"&gt;Right Rotation(向右轉)&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#ref"&gt;參考資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#tree_series"&gt;Tree系列文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name="fail"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;於RBT中進行Insert與Delete後竟然不符合RBT&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;現考慮如圖一(a)之RBT，欲進行Insert(新增資料)與Delete(刪除資料)：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="rotation" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Rotation/rotate0.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(a)：一棵符合規則的RBT。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;為滿足RBT之特徵第五點：從&lt;code&gt;root&lt;/code&gt;走向任何一個leaf node(&lt;code&gt;NIL&lt;/code&gt;)的任何一條path上之黑色node數皆相同，一般在RBT中Insert(新增資料)時，會先將欲新增的node塗成紅色。&lt;br /&gt;
若幸運地，新增的node接在黑色node上，則RBT仍然是一棵RBT，如圖一(b)，新增node(15)。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="rotation" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Rotation/rotate1.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(b)：在RBT中新增node(15)，新增完後仍然滿足RBT之規則。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;但是，若要在RBT中新增node(31)，因為node(34)是紅色，此處便會出現紅色與紅色相連的情況，違反RBT之第四點特徵，因此需要修正，如圖一(c)。  &lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="rotation" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Rotation/rotate2.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(c)：在RBT中新增node(31)，新增完後無法滿足RBT之規則。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;修正的方法便是將node(35)塗成紅色，node(34)塗成黑色，並且對&lt;strong&gt;node(35)&lt;/strong&gt;進行&lt;strong&gt;Right Rotation(向右旋轉)&lt;/strong&gt;，如此一來，RBT便能維持其基本特徵。&lt;br /&gt;
值得注意的是，在執行Rotation時，有時會順便調整RBT的height(樹高)，使得RBT維持在平衡(balanced)的狀態。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="rotation" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Rotation/rotate3.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(d)：使用&lt;/strong&gt;Rotation&lt;strong&gt;對Insert(新增資料)進行修正。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;在正確新增node(31)後，若要刪除node(20)，因為node(20)是黑色，若將其刪除則違反RBT之第五點特徵：從&lt;code&gt;root&lt;/code&gt;走向任何一個leaf node(&lt;code&gt;NIL&lt;/code&gt;)的任何一條path上之黑色node數皆相同，因此同樣需要進行修正。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="rotation" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Rotation/rotate4.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(e)：因為node(20)是黑色，若將其刪除會違反RBT之第五點特徵。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;修正的方法則是將node(30)塗黑，node(34)塗紅，然後對&lt;strong&gt;node(34)&lt;/strong&gt;進行&lt;strong&gt;Left Rotation(向左旋轉)&lt;/strong&gt;，如此一來，RBT便能維持其基本特徵。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="rotation" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Rotation/rotate5.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(f)：使用&lt;/strong&gt;Rotation&lt;strong&gt;對Delete(刪除資料)進行修正。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;經過以上說明，應該能體會到Rotation在修正Insert(新增資料)與Delete(刪除資料)時的威力，接著便來實地走訪Rotation實際上是哪些pointer在指來指去。&lt;/p&gt;
&lt;p&gt;&lt;a name="rotation"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;Rotation(旋轉)&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;在說明Rotation(旋轉)之前有兩點需要先申明：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;若是要應用在BST上，則Rotation(旋轉)前後的BST必須要維持相同之Key排序。此處介紹的Rotation(旋轉)便屬於此類。&lt;/li&gt;
&lt;li&gt;Rotation(旋轉)與node是否具有顏色無關，即使是在一般的BST，亦能夠使用Rotation(旋轉)來調整height(樹高)。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a name="left-rotate"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;Left Roration(向左旋轉)&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="rotation" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Rotation/rotate6.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(a)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;從圖二(a)中可以看出，要對以node(X)為&lt;code&gt;root&lt;/code&gt;之subtree進行Left Rotation，必須調整的pointer分別長在node(X)、node(Y)、node(A)與node(j)身上，其中node(j)有可能為&lt;code&gt;NIL&lt;/code&gt;，不過為求完整，在此將以node(j)不為&lt;code&gt;NIL&lt;/code&gt;作說明。&lt;br /&gt;
另外，node(i)與node(k)是否為&lt;code&gt;NIL&lt;/code&gt;皆不影響Left Rotation。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="rotation" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Rotation/rotate7.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(b)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;圖二(b)將所有可能需要更動的pointer列出，其中，藍色箭頭表示由&lt;code&gt;parent pointer&lt;/code&gt;指向&lt;code&gt;child pointer&lt;/code&gt;，紅色箭頭則為&lt;code&gt;child pointer&lt;/code&gt;指向&lt;code&gt;parent pointer&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Left Roration(向左旋轉)&lt;/strong&gt;之步驟如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Left Rotation完成後，node(Y)的&lt;code&gt;leftchild&lt;/code&gt;將會接上node(X)，因此要先把原先node(Y)的&lt;code&gt;leftchild&lt;/code&gt;(也就是node(j))放到node(X)的&lt;code&gt;rightchild&lt;/code&gt;：&lt;ul&gt;
&lt;li&gt;圖二(c)左：將node(X)的&lt;code&gt;rightchild&lt;/code&gt;指向node(j)；&lt;/li&gt;
&lt;li&gt;圖二(c)右：將node(j)的&lt;code&gt;parent&lt;/code&gt;指向node(X)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="rotation" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Rotation/rotate8.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(c)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Left Rotation完成後，node(X)的&lt;code&gt;parent&lt;/code&gt;將會是node(Y)，而node(Y)的&lt;code&gt;parent&lt;/code&gt;要改成原先node(X)的&lt;code&gt;parent&lt;/code&gt;(也就是node(A))：&lt;ul&gt;
&lt;li&gt;圖二(d)左：將node(Y)的&lt;code&gt;parent&lt;/code&gt;指向node(A)。&lt;/li&gt;
&lt;li&gt;圖二(d)右：接著判斷，若原先node(X)是node(A)的&lt;code&gt;leftchild&lt;/code&gt;，那麼node(Y)同樣是node(A)的&lt;code&gt;leftchild&lt;/code&gt;，反之，node(Y)則成為node(A)的&lt;code&gt;rightchild&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="rotation" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Rotation/rotate9.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(d)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最後，只要再把node(Y)的&lt;code&gt;rightchild&lt;/code&gt;指向node(X)，如圖二(e)左，並把node(X)的&lt;code&gt;parent&lt;/code&gt;接上node(Y)，如圖二(e)右，Left Rotation便完成了。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="rotation" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Rotation/rotate10.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(e)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;最後再看一次圖二(a)，若忽略node(A)，左圖中，其餘node之Key順序為&lt;span class="math"&gt;\(i&amp;lt;X&amp;lt;j&amp;lt;Y&amp;lt;k\)&lt;/span&gt;，而右圖中的順序亦為&lt;span class="math"&gt;\(i&amp;lt;X&amp;lt;j&amp;lt;Y&amp;lt;k\)&lt;/span&gt;，因此，如上所述的Left Rotation能夠應用在BST上。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="rotation" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Rotation/rotate6.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(a)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;Left Rotation之程式範例如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;RBT&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;LeftRotation&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;              &lt;span class="c1"&gt;// 把y設成x的rightchild&lt;/span&gt;

    &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="c1"&gt;// 圖二(c)左&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;neel&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;       &lt;span class="c1"&gt;// 圖二(c)右, 若node(j)為NIL則忽略&lt;/span&gt;
        &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;          &lt;span class="c1"&gt;// 圖二(d)左&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;neel&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;          &lt;span class="c1"&gt;// 圖二(d)右&lt;/span&gt;
        &lt;span class="n"&gt;root&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                   
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
        &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;               &lt;span class="c1"&gt;// 圖二(e)左&lt;/span&gt;
    &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                  &lt;span class="c1"&gt;// 圖二(e)右&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;a name="right-rotate"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;Right Roration(向左旋轉)&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;Right Rotation的邏輯與Left Rotation完全相同，只要確實地把與node(X)、node(Y)、node(A)與node(j)有關的pointer重新指向正確的記憶體位置，就能夠完成Right Rotation。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="rotation" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Rotation/rotate11.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;Right Rotation之程式範例如下，把所有&lt;code&gt;LeftRotation()&lt;/code&gt;中的&lt;code&gt;left-&lt;/code&gt;與&lt;code&gt;right-&lt;/code&gt;對調就是了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;RBT&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;RightRotation&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;

    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;               &lt;span class="c1"&gt;// 把x設成y的leftchild&lt;/span&gt;

    &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="c1"&gt;// 把x的rightchild放到y的leftchild    &lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;neel&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;      &lt;span class="c1"&gt;// 若x的rightchild不為NIL, 將其parent指向y&lt;/span&gt;
        &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;          &lt;span class="c1"&gt;// 將x的parent指向原先y的parent&lt;/span&gt;
                                    &lt;span class="c1"&gt;// 以下一組if-else將修改原先y的parent之child&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;neel&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;               &lt;span class="c1"&gt;// 若y原先是root, x將成為新的root&lt;/span&gt;
        &lt;span class="n"&gt;root&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                        
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;// 若原先y是其parent之leftchild, &lt;/span&gt;
        &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;        &lt;span class="c1"&gt;//   x亦成為其新的parent之leftchild&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;                                 &lt;span class="c1"&gt;// 若原先y是其parent之rightchild, &lt;/span&gt;
        &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;       &lt;span class="c1"&gt;//   x亦成為其新的parent之rightchild&lt;/span&gt;

    &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;              &lt;span class="c1"&gt;// 將y設為x之rightchild&lt;/span&gt;
    &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                  &lt;span class="c1"&gt;// 將x設為y之parent&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;/br&gt;  &lt;/p&gt;
&lt;p&gt;以上便是Rotation(旋轉)的說明，在接下來介紹Insert(新增資料)與Delete(刪除資料)的兩篇文章中將會再次與各位相會。  &lt;/p&gt;
&lt;p&gt;&lt;/br&gt;
&lt;a name="ref"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;參考資料&lt;/strong&gt;：&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844"&gt;Introduction to Algorithms, Ch13&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376"&gt;Fundamentals of Data Structures in C++&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://code.geeksforgeeks.org/NtLnIk"&gt;GeeksforGeeks：Red Black Tree&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name="tree_series"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;Tree系列文章&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/treeshu-introjian-jie.html"&gt;Tree(樹): Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-introjian-jie.html"&gt;Binary Tree: Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-traversalxun-fang.html"&gt;Binary Tree: Traversal(尋訪)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-jian-li-yi-ke-binary-tree.html"&gt;Binary Tree: 建立一棵Binary Tree&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-introjian-jie.html"&gt;Binary Search Tree: Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-searchsou-xun-zi-liao-insertxin-zeng-zi-liao.html"&gt;Binary Search Tree: Search(搜尋資料)、Insert(新增資料)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-sortpai-xu-deleteshan-chu-zi-liao.html"&gt;Binary Search Tree: Sort(排序)、Delete(刪除資料)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-introjian-jie.html"&gt;Red Black Tree: Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-rotationxuan-zhuan.html"&gt;Red Black Tree: Rotation(旋轉)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-insertxin-zeng-zi-liao-yu-fixupxiu-zheng.html"&gt;Red Black Tree: Insert(新增資料)與Fixup(修正)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-deleteshan-chu-zi-liao-yu-fixupxiu-zheng.html"&gt;Red Black Tree: Delete(刪除資料)與Fixup(修正)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="C++"></category><category term="Red Black Tree"></category></entry><entry><title>Red Black Tree: Intro(簡介)</title><link href="http://alrightchiu.github.io/SecondRound/red-black-tree-introjian-jie.html" rel="alternate"></link><updated>2016-01-23T16:09:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2016-01-23:SecondRound/red-black-tree-introjian-jie.html</id><summary type="html">&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;先備知識與注意事項&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;在閱讀過BST系列文章後可以發現，在BST中的操作，不論是Insert(新增資料)或是Delete(刪除資料)，皆需要先做Search(搜尋)，而Search(搜尋)的效率，取決於BST的height(樹高)，如果一棵樹越矮、越平衡(balanced)，則在此BST中搜尋資料的速度較快，理想狀況為Complete Binary Tree(時間複雜度：&lt;span class="math"&gt;\(O(\log N)\)&lt;/span&gt;)。反之，若由於輸入資料的順序使得BST沒長好、偏一邊，則在此BST中搜尋資料的最壞情況將有可能如同在Linked List做搜尋(時間複雜度：&lt;span class="math"&gt;\(O(N)\)&lt;/span&gt;)。  &lt;/p&gt;
&lt;p&gt;本篇文章將介紹BST的進階版Red Black Tree(RBT，紅黑樹)之基本性質，會說是進階版，原因在於RBT其實也是BST(滿足&lt;span class="math"&gt;\(Key(L)&amp;lt;Key(Current)&amp;lt;Key(R)\)&lt;/span&gt;)，不過RBT的node比BST多加了「顏色」(紅色或黑色)，而正因為多了「顏色」，便能修正BST有可能退化成Linked list(連結串列)的潛在缺陷。 &lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="anarchy" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Intro/biasedtree.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一：不平衡的BST。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;另外，本篇文章將不進行「RBT之時間複雜度如何能視同Complete Binary Tree」之論證(筆者火侯不夠，請見諒)，建議讀者可以參考&lt;a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844"&gt;Introduction to Algorithms，第13章&lt;/a&gt;，不過結論就是，RBT可以被視為如同Complete Binary Tree的BST，所有與Search(搜尋)有關的操作(Leftmost、Successor、Insert、Delete等等)，都能夠在&lt;span class="math"&gt;\(O(\log N)\)&lt;/span&gt;內完成。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#why"&gt;為什麼需要Red Black Tree？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#rbt"&gt;Red Black Tree的特徵&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#code"&gt;程式碼&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#ref"&gt;參考資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#tree_series"&gt;Tree系列文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name="why"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;為什麼需要Red Black Tree？&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;若考慮最壞情況，在建立BST時，輸入資料的Key恰好被排序過(例如：1、2、3、4...)，那麼這顆BST便會退化成Linked List(接續前例，所有leftchild pointer都指向&lt;code&gt;NULL&lt;/code&gt;，只有rightchild child被使用)：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;BST&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;InsertBST&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   &lt;span class="c1"&gt;// 依序加入Key為1、2、3...之資料&lt;/span&gt;
    &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;InsertBST&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;InsertBST&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;圖二中，右側的藍色數字表示「搜尋該node需要比較(&lt;code&gt;if KEY == current-&amp;gt;key&lt;/code&gt;)的次數」，也就是迴圈的次數。考慮一串Linked List共有N個node，若要尋找第K個node，則最壞情況即是一路找到最後一個node，需要N次。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="linked list" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Intro/rbt1.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二：BST退化成Linked List。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;再比較Complete Binary Tree，如圖三。其中，node裡的數字即為Key，node旁邊的藍色數字代表該node在Complete Binary Tree中的位置順序，右側的藍色數字代表迴圈次數。&lt;br /&gt;
位置順序與迴圈次數有以下關係：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在位置&lt;span class="math"&gt;\(2^3=8\)&lt;/span&gt;與&lt;span class="math"&gt;\(2^4=16\)&lt;/span&gt;之間的node(&lt;span class="math"&gt;\(2^3\leq i&amp;lt;2^4, i=8\sim 15\)&lt;/span&gt;)，只需要&lt;span class="math"&gt;\(3+1\)&lt;/span&gt;次比較(comparison)即可找到。&lt;/li&gt;
&lt;li&gt;依此類推，若BST中有N個node，則所有node保證能夠在&lt;span class="math"&gt;\(\lfloor {\log N} \rfloor +1\)&lt;/span&gt;次 (&lt;span class="math"&gt;\(2^k\leq N&amp;lt;2^{k+1}, k\leq\log N\)&lt;/span&gt;)迴圈以內找到。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="cbt" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Intro/rbt2.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三：搜尋BST的理想情況：Complete Binary Tree。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;以上兩個範例為一棵具有N個node的BST之height(樹高)提供了邊界：&lt;span class="math"&gt;\(\log N\leq height\leq N\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;因此，BST越平衡，在樹中搜尋資料的時間就越短，連帶地Insert(新增資料)、Delete(刪除資料)也會變得更有效率。&lt;br /&gt;
這就是RBT值得被介紹的原因。&lt;/p&gt;
&lt;p&gt;&lt;a name="rbt"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;Red Black Tree的特徵&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Red Black Tree(RBT)是node塗了「顏色」的Binary Search Tree(BST)，藉由控制顏色，能夠保證在RBT中，&lt;strong&gt;最長path(路徑)不會超過最短path的兩倍&lt;/strong&gt;(若最短的path是5，最長的path至多只能是10)，如此，RBT便能夠近似地視為平衡，如圖四。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="rbt" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Intro/rbt3.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四：最短的path為3(最右path:26-41-47)，其餘path最長只能是6(最左path:26-17-14-10-7-3)。&lt;br /&gt;
若蓋住&lt;code&gt;NIL&lt;/code&gt;與顏色，此即為BST。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;圖四中，所有原本在BST中指向&lt;code&gt;NULL&lt;/code&gt;的pointer，在RBT中，全部指向了&lt;code&gt;NIL&lt;/code&gt;。然而什麼是&lt;code&gt;NIL&lt;/code&gt;？&lt;code&gt;NIL&lt;/code&gt;是永遠為黑色、並且實際占有記憶體的node，因為有配置記憶體，因此能夠以&lt;code&gt;Node-&amp;gt;color&lt;/code&gt;的方式取得某個node之顏色(若使用&lt;code&gt;NULL&lt;/code&gt;則無法)，此優勢將在後續介紹如何於RBT中Insert(新增資料)與Delete(刪除資料)時派上用場。&lt;/p&gt;
&lt;p&gt;接著來看RBT的五項特徵：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;RBT中的每一個node不是黑色就是紅色。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;root&lt;/code&gt;一定是黑色。&lt;/li&gt;
&lt;li&gt;每一個leaf node(也就是&lt;code&gt;NIL&lt;/code&gt;)一定是黑色。&lt;/li&gt;
&lt;li&gt;如果某個node是紅色，那麼其兩個child必定是黑色，不能有兩個紅色node相連，如圖四中的node(17)、node(30)。&lt;br /&gt;
若某個node為黑色，其child之顏色沒有限制，如圖四中的node(38)、node(26)、node(21)。&lt;/li&gt;
&lt;li&gt;站在任何一個node上，所有從該node走到其任意descendant的path上之黑色node數必定相同。&lt;br /&gt;
以圖四為例，站在node(14)上，所有從node(14)走向其descendant leaves(也就是&lt;code&gt;NIL&lt;/code&gt;)的path上之黑色node數必為3： &lt;ul&gt;
&lt;li&gt;path1:14(&lt;strong&gt;b&lt;/strong&gt;)-10(r)-7(&lt;strong&gt;b&lt;/strong&gt;)-3(r)-NIL(&lt;strong&gt;b&lt;/strong&gt;)；&lt;/li&gt;
&lt;li&gt;path2:14(&lt;strong&gt;b&lt;/strong&gt;)-10(r)-7(&lt;strong&gt;b&lt;/strong&gt;)-NIL(&lt;strong&gt;b&lt;/strong&gt;)；&lt;/li&gt;
&lt;li&gt;path3:14(&lt;strong&gt;b&lt;/strong&gt;)-10(r)-12(&lt;strong&gt;b&lt;/strong&gt;)-NIL(&lt;strong&gt;b&lt;/strong&gt;)；&lt;/li&gt;
&lt;li&gt;path4:14(&lt;strong&gt;b&lt;/strong&gt;)-16(&lt;strong&gt;b&lt;/strong&gt;)-15(r)-NIL(&lt;strong&gt;b&lt;/strong&gt;)；&lt;/li&gt;
&lt;li&gt;path5:14(&lt;strong&gt;b&lt;/strong&gt;)-16(&lt;strong&gt;b&lt;/strong&gt;)-NIL(&lt;strong&gt;b&lt;/strong&gt;)；   &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;根據上述特徵的第四點與第五點，RBT中path可能的長度最小值一定是全部node皆為黑色，而path可能的長度最大值並定是紅色-黑色相間(如圖四)，如此便確保RBT擁有&lt;strong&gt;最長path(路徑)不會超過最短path的兩倍&lt;/strong&gt;的特性。&lt;/p&gt;
&lt;p&gt;&lt;a name="code"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;程式碼&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;實際的程式實現上，會把所有&lt;code&gt;NIL&lt;/code&gt;視為同一個&lt;code&gt;NIL&lt;/code&gt;，並把&lt;code&gt;root&lt;/code&gt;的parent指向&lt;code&gt;NIL&lt;/code&gt;，以節省記憶體空間，如圖五。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="rbt" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Intro/rbt4.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;class TreeNode&lt;/code&gt;與&lt;code&gt;class RBT&lt;/code&gt;之資料成員(data member)程式範例如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;string&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;RBT&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;element&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;         &lt;span class="c1"&gt;// 0: Red,  1: Black&lt;/span&gt;
    &lt;span class="k"&gt;friend&lt;/span&gt; &lt;span class="n"&gt;RBT&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;RBT&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;neel&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="c1"&gt;// 此即為NIL, 常被稱為sentinel&lt;/span&gt;
    &lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;(為了避開某些IDE將&lt;code&gt;NIL&lt;/code&gt;設定成保留關鍵字(reserved keywords，例如&lt;code&gt;template&lt;/code&gt;、&lt;code&gt;while&lt;/code&gt;、&lt;code&gt;struct&lt;/code&gt;等等)，因此使用&lt;code&gt;neel&lt;/code&gt;。)&lt;/p&gt;
&lt;p&gt;為求畫面簡潔，往後的篇幅裡將把RBT示意圖中的&lt;code&gt;NIL&lt;/code&gt;隱藏起來，只顯示RBT中的internal node，如圖六，不過心裡要記得，RBT無時無刻都被&lt;code&gt;NIL&lt;/code&gt;充滿著。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="rbt" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/RBT_fig/Intro/rbt5.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖六：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;以上便是RBT之初探，最重要的結論為：就時間複雜度而言，RBT能夠被視為平衡的BST，所有操作皆能在時間複雜度為&lt;span class="math"&gt;\(O(\log N)\)&lt;/span&gt;內完成。&lt;/p&gt;
&lt;p&gt;在接下來的三篇文章中，將依序介紹Rotation(旋轉)、Insert(新增資料)與Delete(刪除資料)。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="ref"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;參考資料&lt;/strong&gt;：&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844"&gt;Introduction to Algorithms, Ch13&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376"&gt;Fundamentals of Data Structures in C++&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://code.geeksforgeeks.org/NtLnIk"&gt;GeeksforGeeks：Red Black Tree&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name="tree_series"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;Tree系列文章&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/treeshu-introjian-jie.html"&gt;Tree(樹): Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-introjian-jie.html"&gt;Binary Tree: Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-traversalxun-fang.html"&gt;Binary Tree: Traversal(尋訪)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-jian-li-yi-ke-binary-tree.html"&gt;Binary Tree: 建立一棵Binary Tree&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-introjian-jie.html"&gt;Binary Search Tree: Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-searchsou-xun-zi-liao-insertxin-zeng-zi-liao.html"&gt;Binary Search Tree: Search(搜尋資料)、Insert(新增資料)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-sortpai-xu-deleteshan-chu-zi-liao.html"&gt;Binary Search Tree: Sort(排序)、Delete(刪除資料)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-introjian-jie.html"&gt;Red Black Tree: Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-rotationxuan-zhuan.html"&gt;Red Black Tree: Rotation(旋轉)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-insertxin-zeng-zi-liao-yu-fixupxiu-zheng.html"&gt;Red Black Tree: Insert(新增資料)與Fixup(修正)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-deleteshan-chu-zi-liao-yu-fixupxiu-zheng.html"&gt;Red Black Tree: Delete(刪除資料)與Fixup(修正)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="C++"></category><category term="Red Black Tree"></category><category term="Intro"></category></entry><entry><title>Binary Search Tree: Sort(排序)、Delete(刪除資料)</title><link href="http://alrightchiu.github.io/SecondRound/binary-search-tree-sortpai-xu-deleteshan-chu-zi-liao.html" rel="alternate"></link><updated>2016-01-15T21:27:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2016-01-15:SecondRound/binary-search-tree-sortpai-xu-deleteshan-chu-zi-liao.html</id><summary type="html">&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;先備知識與注意事項&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;由於Sort與Delete會用到先前在&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-traversalxun-fang.html#in_parent"&gt;Binary Tree：Traversal介紹過的Leftmost()、Rightmost()、Successor()與Predecessor()&lt;/a&gt;，因此建議在開始閱讀本篇文章之前，先復習上述四個函式操作。  &lt;/p&gt;
&lt;p&gt;在文章最後將會附上四個函式的範例程式碼。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#sort"&gt;Sort(排序)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#delete"&gt;BST::DeleteBST(刪除資料)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#main"&gt;main()&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#4function"&gt;Leftmost、Rightmost、Successor、Predecessor範例程式碼&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#ref"&gt;參考資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#tree_series"&gt;Tree系列文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name="sort"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;Sort(排序)&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;讀者可能會發現，在&lt;code&gt;class BST&lt;/code&gt;的定義中，根本就沒有類似&lt;code&gt;SortBST()&lt;/code&gt;的函式，沒錯，因為在BST中，每一個&lt;code&gt;Treenode&lt;/code&gt;都有&lt;span class="math"&gt;\(Key(L)&amp;lt;Key(Current)&amp;lt;Key(R)\)&lt;/span&gt;的性質，這正好與Inorder(LVR)之順序相同，因此，對整棵樹進行Inorder Traversal，就能夠對資料由小到大(依照Key)進行Visiting。&lt;/p&gt;
&lt;p&gt;以上一篇&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-searchsou-xun-zi-liao-insertxin-zeng-zi-liao.html#binary-search-tree-searchsou-xun-zi-liao-insertxin-zeng-zi-liao"&gt;Binary Search Tree: Search()、Insert()&lt;/a&gt;的&lt;code&gt;main()&lt;/code&gt;所建立的BST為例，如圖一，要將此樹中的資料按照Key之順序由小到大印出，只需要對整棵樹做一次Inorder Traversal即可。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/sort_delete/sort_delete1.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;以下範例程式，將Visiting用作列印資料(print)：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;BST&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;InorderPrint&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Leftmost&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="c1"&gt;// Visiting&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;element&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;(&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;)&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot; &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    
        &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Successor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;            &lt;span class="c1"&gt;// 移動至current的Successor&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;output:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;克林&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="err"&gt;龜仙人&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="err"&gt;比克&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;513&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="err"&gt;悟空&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1000&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;a name="delete"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;BST::DeleteBST(刪除資料)&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;要在BST上執行刪除資料(被刪除的node稱為A)，必須讓刪除A後的BST仍然維持BST的性質，因此，所有「具有指向A的pointer」之node(也就是A的&lt;code&gt;parent&lt;/code&gt;、A的&lt;code&gt;leftchild&lt;/code&gt;與A的&lt;code&gt;rightchild&lt;/code&gt;)都必須指向新的記憶體位置。&lt;/p&gt;
&lt;p&gt;刪除資料的工作，根據欲刪除之node「有幾個child pointer」分成三類：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Case1：欲刪除之node沒有&lt;code&gt;child pointer&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;Case2：欲刪除之node只有一個&lt;code&gt;child pointer&lt;/code&gt;(不論是&lt;code&gt;leftchild&lt;/code&gt;或&lt;code&gt;rightchild&lt;/code&gt;)；&lt;/li&gt;
&lt;li&gt;Case3：欲刪除之node有兩個&lt;code&gt;child pointer&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以圖二(a)為例，依序刪除撒旦、弗力札與西魯：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/sort_delete/sort_delete2.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(a)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Case1&lt;/strong&gt;：由於撒旦沒有&lt;code&gt;child pointer&lt;/code&gt;，因此只要考慮撒旦的parent(普烏)，將普烏的&lt;code&gt;leftchild&lt;/code&gt;指向&lt;code&gt;NULL&lt;/code&gt;即可維持BST的正確性，如圖二(b)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/sort_delete/sort_delete3.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(b)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Case2&lt;/strong&gt;：由於弗力札有一個&lt;code&gt;leftchild&lt;/code&gt;(基紐)，因此在刪除弗力札之前，需要先將基紐的parent指向弗力札的&lt;code&gt;parent&lt;/code&gt;(龜仙人)，並且將龜仙人的&lt;code&gt;rightchild&lt;/code&gt;從原本的弗力札指向基紐，因為基紐原本就位於龜仙人的right subtree(右子樹)，因此，上述操作仍能維持BST的正確性，如圖二(c)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/sort_delete/sort_delete4.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(c)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Case3&lt;/strong&gt;：由於西魯有兩個&lt;code&gt;child&lt;/code&gt;，若直接刪除西魯的資料，並釋放其記憶體位置，要牽動的node較多。變通的祕訣就是「找替身」，原本要刪西魯，但是實際上是釋放西魯的「Successor(達爾)」的記憶體位置(或是「Predecessor(16號)」)，最後再把「Successor(達爾)」(或是「Predecessor(16號)」)的資料放回到西魯的記憶體位置上，又因為BST的特徵，所有「具有兩個&lt;code&gt;child&lt;/code&gt;」的node的Successor或是Predecessor一定是leaf node或是只有一個&lt;code&gt;child&lt;/code&gt;，如此，便回到如同撒旦與弗力札「至多只有一個&lt;code&gt;child&lt;/code&gt;」的情境。 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;驗證「具有兩個&lt;code&gt;child&lt;/code&gt;的node的Successor或是Predecessor一定是leaf node或是只有一個&lt;code&gt;child&lt;/code&gt;」：若某個node有兩個&lt;code&gt;child&lt;/code&gt;，則Successor找的是「right subtree中Key最小的node」，而Predecessor找的是「left subtree中Key最大的node」，因此Successor和Predecessor必定不會同時也有兩個child。以圖二(d)為例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;龜仙人(8)的Predecessor為克林(2)，Successor為基紐(69)；&lt;/li&gt;
&lt;li&gt;比克(513)的Predecessor為基紐(69)，Successor為16號(520)；&lt;/li&gt;
&lt;li&gt;悟飯(888)的Predecessor為達爾(881)，Successor為普烏(999)；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/sort_delete/sort_delete5.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(d)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;現欲刪除西魯，就去找西魯的Successor(達爾)當做替身，因為達爾沒有&lt;code&gt;child&lt;/code&gt;，其刪除方法便如同上述刪除撒旦的方法，如圖二(e)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/sort_delete/sort_delete6.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(e)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最後再將達爾的資料放進原先存放西魯資料的記憶體位置，便完成了刪除西魯的操作，如圖二(f)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/sort_delete/sort_delete7.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(f)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;BST::DeleteBST()&lt;/code&gt;之範例程式碼分成以下幾個步驟：：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先確認BST中有沒有要刪除的node；&lt;/li&gt;
&lt;li&gt;把要刪除的node調整成「至多只有一個&lt;code&gt;child&lt;/code&gt;」；&lt;/li&gt;
&lt;li&gt;把要刪除的node的&lt;code&gt;child&lt;/code&gt;指向新的&lt;code&gt;parent&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;把要刪除的node的&lt;code&gt;parent&lt;/code&gt;指向新的&lt;code&gt;child&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;若實際上刪除的是「替身」，再把替身的資料放回BST中。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;即完成BST之刪除資料操作。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;BST&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;DeleteBST&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;KEY&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;               &lt;span class="c1"&gt;// 要刪除具有KEY的node&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;delete_node&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;delete_node&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Search&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;KEY&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;              &lt;span class="c1"&gt;// 先確認BST中是否有具有KEY的node&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;delete_node&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;data not found.&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;      &lt;span class="c1"&gt;// 真正要被刪除並釋放記憶體的node&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;      &lt;span class="c1"&gt;// 要被刪除的node的child&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;delete_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;delete_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;delete_node&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
        &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Successor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;delete_node&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                                            &lt;span class="c1"&gt;// 經過以上的if-else, y至多只有一個child&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;               &lt;span class="c1"&gt;// 將x設成y的child, 可能是有效記憶體, 也有可能是NULL&lt;/span&gt;
        &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
        &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;                          
        &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;              &lt;span class="c1"&gt;// 此即為圖二(c)中, 基紐指向龜仙人的實作方式&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;                  &lt;span class="c1"&gt;// 再將要被刪除的node之parent指向新的child&lt;/span&gt;
        &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
        &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;delete_node&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;                 &lt;span class="c1"&gt;// y即是達爾, delete_node即是西魯&lt;/span&gt;
        &lt;span class="n"&gt;delete_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;SetKey&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;GetKey&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;   &lt;span class="c1"&gt;// 實際被刪除的是y, 因此最後要再將y的資料放進delete_node的記憶體位置&lt;/span&gt;
        &lt;span class="n"&gt;delete_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;SetElement&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;GetElement&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;   
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;a name="main"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;main()&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;延續上一篇文章&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-searchsou-xun-zi-liao-insertxin-zeng-zi-liao.html#binary-search-tree-searchsou-xun-zi-liao-insertxin-zeng-zi-liao"&gt;Binary Search Tree: Search()、Insert()&lt;/a&gt;的&lt;code&gt;main()&lt;/code&gt;，加入&lt;code&gt;BST::DeleteBST&lt;/code&gt;，把龜仙人(8)刪除，應該會得到如圖三的BST，比克(513)成為新的&lt;code&gt;root&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/sort_delete/sort_delete8.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;BST&lt;/span&gt; &lt;span class="n"&gt;b1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="n"&gt;n1&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;龜仙人&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="n"&gt;n2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1000&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;悟空&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="n"&gt;n3&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;克林&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="n"&gt;n4&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;513&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;比克&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;b1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;InsertBST&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;b1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;InsertBST&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;b1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;InsertBST&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n3&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;b1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;InsertBST&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n4&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;b1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DeleteBST&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;          &lt;span class="c1"&gt;// 刪除龜仙人&lt;/span&gt;
    &lt;span class="n"&gt;b1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;InorderPrint&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;output:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;克林&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="err"&gt;比克&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;513&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="err"&gt;悟空&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1000&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;a name="4function"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;Leftmost、Rightmost、Successor、Predecessor範例程式碼&lt;/strong&gt;&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;BST&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Leftmost&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;BST&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Rightmost&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;BST&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Successor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;Leftmost&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;new_node&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;new_node&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;new_node&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;new_node&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;BST&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Predecessor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;Rightmost&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;new_node&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;new_node&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;new_node&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;new_node&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;以上便是BST中&lt;code&gt;BST::DeleteBST()&lt;/code&gt;之介紹，關鍵即在Successor與Predecessor。  &lt;/p&gt;
&lt;p&gt;在接下來將介紹的Red Black Tree(RBT，紅黑樹)中，BST的&lt;code&gt;Insert()&lt;/code&gt;與&lt;code&gt;Delete()&lt;/code&gt;會再次出現，不過，需要再「多一道手續」以滿足RBT的性質。&lt;/p&gt;
&lt;p&gt;最後，因為RBT的圖比較複雜，所以圈圈裏面放名字會太擠，有礙觀瞻，因此要忍痛讓「悟空」、「克林」退居幕後，直接在node裡面放上Key。 
不過，相信透過這三篇BST的介紹，讀者對七龍珠也有一定程度的了解，後面的部分一定可以靠自學來搜集龍珠的。&lt;/p&gt;
&lt;p&gt;cha la head cha la～～&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;
&lt;a name="ref"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;參考資料&lt;/strong&gt;：&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844"&gt;Introduction to Algorithms&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376"&gt;Fundamentals of Data Structures in C++&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name="tree_series"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;Tree系列文章&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/treeshu-introjian-jie.html"&gt;Tree(樹): Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-introjian-jie.html"&gt;Binary Tree: Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-traversalxun-fang.html"&gt;Binary Tree: Traversal(尋訪)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-jian-li-yi-ke-binary-tree.html"&gt;Binary Tree: 建立一棵Binary Tree&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-introjian-jie.html"&gt;Binary Search Tree: Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-searchsou-xun-zi-liao-insertxin-zeng-zi-liao.html"&gt;Binary Search Tree: Search(搜尋資料)、Insert(新增資料)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-sortpai-xu-deleteshan-chu-zi-liao.html"&gt;Binary Search Tree: Sort(排序)、Delete(刪除資料)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-introjian-jie.html"&gt;Red Black Tree: Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-rotationxuan-zhuan.html"&gt;Red Black Tree: Rotation(旋轉)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-insertxin-zeng-zi-liao-yu-fixupxiu-zheng.html"&gt;Red Black Tree: Insert(新增資料)與Fixup(修正)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-deleteshan-chu-zi-liao-yu-fixupxiu-zheng.html"&gt;Red Black Tree: Delete(刪除資料)與Fixup(修正)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="C++"></category><category term="Binary Search Tree(二元搜尋樹)"></category></entry><entry><title>Binary Search Tree: Search(搜尋資料)、Insert(新增資料)</title><link href="http://alrightchiu.github.io/SecondRound/binary-search-tree-searchsou-xun-zi-liao-insertxin-zeng-zi-liao.html" rel="alternate"></link><updated>2016-01-03T20:17:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2016-01-03:SecondRound/binary-search-tree-searchsou-xun-zi-liao-insertxin-zeng-zi-liao.html</id><summary type="html">&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;先備知識與注意事項&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;在開始介紹search(搜尋資料)與insert(新增資料)之前，先定義好&lt;code&gt;class TreeNode&lt;/code&gt;與&lt;code&gt;class BST&lt;/code&gt;，順便對未來將介紹的其他member function(成員函式)留下美好的第一印象：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;string&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;BST&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;element&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="c1"&gt;// constructor&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;element&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;element&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="c1"&gt;// default copy constructor&lt;/span&gt;
    &lt;span class="c1"&gt;// default destructor&lt;/span&gt;

    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;GetKey&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;;};&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;GetElement&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;element&lt;/span&gt;&lt;span class="p"&gt;;};&lt;/span&gt;

    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;SetKey&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;;};&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;SetElement&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt; &lt;span class="n"&gt;element&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;;};&lt;/span&gt;   

    &lt;span class="k"&gt;friend&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;BST&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="c1"&gt;// 放在 private 或 public 都可以 &lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="c1"&gt;// class BST&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;BST&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nf"&gt;Rightmost&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nf"&gt;Leftmost&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nf"&gt;Copy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;origNode&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;    &lt;span class="c1"&gt;// preorder traversal, 用在 copy constructor和 operator=&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;PostorderDelete&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;BST&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;     &lt;span class="c1"&gt;// default constructor&lt;/span&gt;
    &lt;span class="n"&gt;BST&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;BST&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;      &lt;span class="c1"&gt;// copy constructor&lt;/span&gt;
    &lt;span class="n"&gt;BST&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;BST&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;BST&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  &lt;span class="c1"&gt;// destructor&lt;/span&gt;

    &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nf"&gt;Search&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;InsertBST&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nf"&gt;Successor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nf"&gt;Predecessor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;InorderPrint&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;DeleteBST&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;KEY&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="nf"&gt;IsEmpty&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;);};&lt;/span&gt;    &lt;span class="c1"&gt;// 確認BST是否存有資料&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;文章內容將著重於BST這個資料結構，並提供此資料結構中可行的演算法，因此，有關C++的實作方法並不唯一，筆者相信有更優秀的寫法(有效利用記憶體、避免memory leak(記憶體洩漏)等議題)，建議讀者可以多多參考例如&lt;a href="http://codereview.stackexchange.com/"&gt;Stack Exchange:Code Review&lt;/a&gt;等等眾多優秀的網站，看網友的程式碼的寫法以及由該份程式碼所開啟的討論串，應該會對實際寫作技巧有些幫助。&lt;br /&gt;
(筆者也還在學啊啊啊啊)&lt;/p&gt;
&lt;p&gt;另外，用以測試的&lt;code&gt;main()&lt;/code&gt;將在BST系列的演算法都介紹完後登場。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#search"&gt;BST::Search(搜尋)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#insert"&gt;BST::InsertBST(新增資料)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#main"&gt;main()&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#ref"&gt;參考資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#tree_series"&gt;Tree系列文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name="search"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;BST::Search(搜尋)&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;BST的&lt;code&gt;Search()&lt;/code&gt;操作，便是根據BST的特徵：&lt;span class="math"&gt;\(Key(L)&amp;lt;Key(Current)&amp;lt;Key(R)\)&lt;/span&gt;，判斷&lt;code&gt;Current&lt;/code&gt;node應該往left subtree走，還是往right subtree走。&lt;/p&gt;
&lt;p&gt;現有一棵BST如圖一(a)所示：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/search_insert/f18.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(a)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;   &lt;/p&gt;
&lt;p&gt;搜尋結果可能成功，可能失敗，以下便分別以兩個KEY值作說明。&lt;/p&gt;
&lt;h4&gt;搜尋成功&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;若現在要從BST中搜尋基紐隊長，便以基紐隊長的KEY(627)進入BST。&lt;br /&gt;
進入BST後，便把用來移動的&lt;code&gt;Current&lt;/code&gt;node指向&lt;code&gt;root&lt;/code&gt;，如圖一(b)。  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/search_insert/f19.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(b)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt; &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;此時，便將KEY(627)和比克(&lt;code&gt;root&lt;/code&gt;)的戰鬥力(513)比較，結果是基紐隊長戰勝，因此，基紐隊長如果在BST裡面，應該會長在比克的right subtree，於是便將&lt;code&gt;Current&lt;/code&gt;往比克的right child(達爾)移動，如圖一(c)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/search_insert/f20.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(c)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt; &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;將&lt;code&gt;Current&lt;/code&gt;移動到達爾之後，再將KEY(627)與達爾的戰鬥力(524)比較，結果仍然是基紐隊長大勝，因此步驟同上，繼續將&lt;code&gt;Current&lt;/code&gt;往達爾的right child(弗力札)移動，如圖一(d)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/search_insert/f21.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(d)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt; &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;將&lt;code&gt;Current&lt;/code&gt;移動到弗力札之後，再將KEY(627)與弗力札的戰鬥力(709)比較，結果是弗力札略勝，於是便往弗力札的left child尋找基紐隊長，如圖一(e)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/search_insert/f22.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(e)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;此時，&lt;code&gt;Current&lt;/code&gt;的Key(627)與傳送進&lt;code&gt;Search()&lt;/code&gt;的KEY(627)相同，便確認&lt;code&gt;Current&lt;/code&gt;即為基紐隊長，於是跳出&lt;code&gt;while&lt;/code&gt;迴圈，並傳回&lt;code&gt;Current&lt;/code&gt;。&lt;br /&gt;
即搜尋成功。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;搜尋失敗&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;若現在要從BST中尋找克林，便以克林的戰鬥力(2)為KEY(2)，進入&lt;code&gt;Search()&lt;/code&gt;。&lt;br /&gt;
進入BST後，同樣把用來移動的&lt;code&gt;Current&lt;/code&gt;node指向&lt;code&gt;root&lt;/code&gt;，如圖一(b)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/search_insert/f19.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(b)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt; &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;接著便將KEY(2)和比克的戰鬥力(513)比較，結果是比克勝出，於是將&lt;code&gt;Currnet&lt;/code&gt;往比克的left child(龜仙人)移動，如圖一(f)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/search_insert/f23.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一(f)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt; &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;將&lt;code&gt;Current&lt;/code&gt;移動至龜仙人後，將KEY(2)和龜仙人的戰鬥力(8)比較，便判斷出，要將&lt;code&gt;Current&lt;/code&gt;往龜仙人的left child移動，如圖一(f)。&lt;br /&gt;
然而，由於龜仙人沒有left child，於是&lt;code&gt;Current&lt;/code&gt;指向&lt;code&gt;NULL&lt;/code&gt;，便跳出迴圈，並回傳&lt;code&gt;NULL&lt;/code&gt;，即表示搜尋失敗，克林不在BST中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下是&lt;code&gt;BST::Search()&lt;/code&gt;的範例程式碼，其中，有兩種情況會跳出&lt;code&gt;while&lt;/code&gt;迴圈：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;KEY與&lt;code&gt;Current&lt;/code&gt;node的key相同，表示搜尋成功；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Current&lt;/code&gt;移動到&lt;code&gt;NULL&lt;/code&gt;，表示搜尋失敗。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;BST&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Search&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;KEY&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;KEY&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;GetKey&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;KEY&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;GetKey&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
            &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="c1"&gt;// 向左走&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;
            &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;// 向右走&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;/br&gt; 
&lt;a name="insert"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;BST::InsertBST(新增資料)&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;函式&lt;code&gt;InsertBST()&lt;/code&gt;的演算法概念，可以視為&lt;code&gt;Search()&lt;/code&gt;的延伸：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;根據BST對Key之規則，先找到「將要新增之node」適合的位置；&lt;/li&gt;
&lt;li&gt;再將欲新增的node接上BST。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;要尋找「對新增node而言的適當位置」，需要召喚一位「哨兵」先行探路，而「將會成為新增node的&lt;strong&gt;parent node&lt;/strong&gt;(準新手爸媽)」則跟著「哨兵」的腳步，往前推進。 &lt;/p&gt;
&lt;p&gt;定義「哨兵」為&lt;strong&gt;x&lt;/strong&gt;，「準新手爸媽」為&lt;strong&gt;y&lt;/strong&gt;，現欲新增「比克，戰鬥力(513)」進入如圖二(a)之BST。&lt;br /&gt;
(這裡的「哨兵&lt;strong&gt;x&lt;/strong&gt;」具有&lt;code&gt;BST::Search()&lt;/code&gt;中&lt;code&gt;Current&lt;/code&gt;node的功能。)&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/search_insert/f24.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(a)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt; &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如圖二(a)，剛進入BST時，「哨兵&lt;strong&gt;x&lt;/strong&gt;」進到&lt;code&gt;root&lt;/code&gt;，而「準新手爸媽&lt;strong&gt;y&lt;/strong&gt;」即為&lt;code&gt;root&lt;/code&gt;的parent，即為&lt;code&gt;NULL&lt;/code&gt;。  &lt;/li&gt;
&lt;li&gt;接著，將欲新增node之Key(比克(513))與「哨兵&lt;strong&gt;x&lt;/strong&gt;」之Key(龜仙人(8))相比，比克的戰鬥力比龜仙人高，所以比克應該要長在龜仙人的right subtree，因此把「哨兵&lt;strong&gt;x&lt;/strong&gt;」往龜仙人的right child(悟空)移動，並且更新「準新手爸媽&lt;strong&gt;y&lt;/strong&gt;」為龜仙人，如圖二(b)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/search_insert/f25.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(b)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt; &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;接著，繼續比較欲新增node之Key(比克(513))與「哨兵&lt;strong&gt;x&lt;/strong&gt;」之Key(悟空(1000))，結果是悟空的戰鬥力較高，比克應該要長在悟空的left subtree，因此，將「哨兵&lt;strong&gt;x&lt;/strong&gt;」往悟空的left child(&lt;code&gt;NULL&lt;/code&gt;)移動，同時更新「準新手爸媽&lt;strong&gt;y&lt;/strong&gt;」為悟空，如圖二(c)。&lt;/li&gt;
&lt;li&gt;更新後，「準新手爸媽&lt;strong&gt;y&lt;/strong&gt;」成為悟空，「哨兵&lt;strong&gt;x&lt;/strong&gt;」指向&lt;code&gt;NULL&lt;/code&gt;壯烈犧牲，即達到跳出迴圈之條件。此時，便找到了「新增node」之適當位置。&lt;br /&gt;
那個「適當位置」在哪裡呢？就是「準新手爸媽&lt;strong&gt;y&lt;/strong&gt;」的child pointer。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/search_insert/f26.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(c)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt; &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;下一步，便是比較欲新增node之Key(比克(513))與「準新手爸媽&lt;strong&gt;y&lt;/strong&gt;」之Key(悟空(1000))，發現悟空戰鬥力較高，因此，比克(513)便成為「準新手爸媽&lt;strong&gt;y&lt;/strong&gt;」的left child，如圖二(d)，便成功把比克(513)接到BST上。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/search_insert/f27.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(d)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt; &lt;/p&gt;
&lt;p&gt;以下是&lt;code&gt;BST::InsertBST()&lt;/code&gt;的範例程式碼，關鍵便是「哨兵&lt;strong&gt;x&lt;/strong&gt;」與「準新手爸媽&lt;strong&gt;y&lt;/strong&gt;」的冒險之旅：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;BST&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;InsertBST&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;        &lt;span class="c1"&gt;// 準新手爸媽&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;        &lt;span class="c1"&gt;// 哨兵&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;insert_node&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// call default copy constructor of TreeNode&lt;/span&gt;

    &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;                &lt;span class="c1"&gt;// 在while中, 以如同Search()的方式尋找適當的位置       &lt;/span&gt;
        &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                                
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;insert_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;GetKey&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;GetKey&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
            &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;
            &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;                                  &lt;span class="c1"&gt;// 跳出迴圈後, x即為NULL&lt;/span&gt;
    &lt;span class="n"&gt;insert_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;           &lt;span class="c1"&gt;// y即為insert_node的parent&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;                     &lt;span class="c1"&gt;// 下面一組if-else, 把insert_node接上BST&lt;/span&gt;
        &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;insert_node&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;insert_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;GetKey&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;GetKey&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
        &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;insert_node&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
        &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;insert_node&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;備註：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在定義函式&lt;code&gt;InsertBST()&lt;/code&gt;時，函式的參數(argument)可能會視情境而有所改變，這裡是以一個&lt;code&gt;TreeNode&lt;/code&gt;的物件(object)之&lt;strong&gt;reference&lt;/strong&gt;作為參數，傳進函式&lt;code&gt;InsertBST()&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;InsertBST()&lt;/code&gt;特別標示出BST是為了與之後會介紹的Red Black Tree(紅黑樹)之&lt;code&gt;InsertRBT()&lt;/code&gt;做區別。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name="main"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;main()&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;有了&lt;code&gt;BST::InsertBST()&lt;/code&gt;後，就可以用土法煉鋼的方式建立一棵如圖二(d)的BST:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;BST&lt;/span&gt; &lt;span class="n"&gt;b1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="n"&gt;n1&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;龜仙人&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="n"&gt;n2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1000&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;悟空&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="n"&gt;n3&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;克林&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="n"&gt;n4&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;513&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;比克&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;b1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;InsertBST&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;b1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;InsertBST&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;b1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;InsertBST&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n3&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;b1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;InsertBST&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n4&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;以上便是BST中&lt;code&gt;Search()&lt;/code&gt;與&lt;code&gt;InsertBST()&lt;/code&gt;之介紹，只要掌握BST的性質&lt;span class="math"&gt;\(Key(L)&amp;lt;Key(Current)&amp;lt;Key(R)\)&lt;/span&gt;與樹中的Traversal(pointer的移動)即可輕鬆上路。 &lt;/p&gt;
&lt;p&gt;&lt;/br&gt;
&lt;a name="ref"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;參考資料&lt;/strong&gt;：&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844"&gt;Introduction to Algorithms&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376"&gt;Fundamentals of Data Structures in C++&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name="tree_series"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;Tree系列文章&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/treeshu-introjian-jie.html"&gt;Tree(樹): Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-introjian-jie.html"&gt;Binary Tree: Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-traversalxun-fang.html"&gt;Binary Tree: Traversal(尋訪)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-jian-li-yi-ke-binary-tree.html"&gt;Binary Tree: 建立一棵Binary Tree&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-introjian-jie.html"&gt;Binary Search Tree: Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-searchsou-xun-zi-liao-insertxin-zeng-zi-liao.html"&gt;Binary Search Tree: Search(搜尋資料)、Insert(新增資料)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-sortpai-xu-deleteshan-chu-zi-liao.html"&gt;Binary Search Tree: Sort(排序)、Delete(刪除資料)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-introjian-jie.html"&gt;Red Black Tree: Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-rotationxuan-zhuan.html"&gt;Red Black Tree: Rotation(旋轉)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-insertxin-zeng-zi-liao-yu-fixupxiu-zheng.html"&gt;Red Black Tree: Insert(新增資料)與Fixup(修正)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-deleteshan-chu-zi-liao-yu-fixupxiu-zheng.html"&gt;Red Black Tree: Delete(刪除資料)與Fixup(修正)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="C++"></category><category term="Binary Search Tree(二元搜尋樹)"></category></entry><entry><title>Binary Search Tree: Intro(簡介)</title><link href="http://alrightchiu.github.io/SecondRound/binary-search-tree-introjian-jie.html" rel="alternate"></link><updated>2016-01-02T12:15:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2016-01-02:SecondRound/binary-search-tree-introjian-jie.html</id><summary type="html">&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;先備知識與注意事項&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;先前的文章介紹過廣義的Tree(樹)、Binary Tree(二元樹)，這篇文章將繼續增加限制條件，使Binary Tree晉升成Binary Search Tree(BST，二元搜尋樹)。  &lt;/p&gt;
&lt;p&gt;這裡要處理的資料是日本漫畫的曠世鉅作《七龍珠》中各角色的戰鬥力。&lt;br /&gt;
七龍珠的劇情(正篇有七龍珠、七龍珠Z、七龍珠改、七龍珠GT、七龍珠超，劇場版還有&lt;a href="https://zh.wikipedia.org/wiki/%E4%B8%83%E9%BE%99%E7%8F%A0#.E5.8A.87.E5.A0.B4.E7.89.88"&gt;七龍珠劇場版(太多了請參閱維基百科)&lt;/a&gt;)時而前後連貫，時而交錯，為了維持每個系列之間的角色設定，就需要對角色的戰鬥力進行管理，避免劇情不合邏輯變成鬧劇，在此，筆者推薦鳥山明老師可以使用先進如BST的資料結構來整理角色的資料(當然，也是可以用excel或是國小生字簿，&lt;a href="http://www.imdb.com/title/tt1178663/"&gt;Whatever Works&lt;/a&gt;)。  &lt;/p&gt;
&lt;p&gt;熱血沸騰了。  &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#dictionary"&gt;引入dictionary&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#bst"&gt;Binary Search Tree的特徵&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#operation"&gt;在Binary Search Tree中管理資料&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#insert"&gt;insert(新增資料)&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="#search"&gt;search(搜尋資料)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#sort"&gt;sort(排序)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#delete"&gt;delete(刪除資料)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#ref"&gt;參考資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#tree_series"&gt;Tree系列文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name="dictionary"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;引入dictionary&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;搜尋與排序都需要「比大小」，欲執行「比大小」，就要使用「能夠比大小」的資料形態(亦即：兩個比較之物只能唯一滿足於「大於」、「小於」或「等於」之關係)，最直觀的便是使用整數(integer)。  &lt;/p&gt;
&lt;p&gt;在先前的文章中，&lt;code&gt;class TreeNode&lt;/code&gt;包含了指向child的pointer、指向parent的pointer，以及一個&lt;code&gt;char data&lt;/code&gt;來儲存字母。  &lt;/p&gt;
&lt;p&gt;而更多時候，node所攜帶的資料項目(在此為&lt;code&gt;char data&lt;/code&gt;)可能更複雜，也許是一個姓名、一組帳戶資料、一本照片集、一組科學資料等等，然而，要使用這些資料進行「比大小」必須而外自行定義規則，例如：「姓氏照字母順序排序，字母越前面值越大；若第一個字相同，則依序往下比較；若姓名中所有字母之順序皆相同則...」，非常不實際，因此，不用再則了，變通的方法便是直接在資料上加上「編號」(也可以想成，把資料對應(mapping)到特定編號)，以編號做排序，並且能夠以特定編號搜尋其所對應之資料項目，即可避開上述麻煩。  &lt;/p&gt;
&lt;p&gt;如此概念便是Dictionary，稱上述的「編號」為「Key(鍵值)」，稱「資料項目」為「Element(元素)」，則稱一組「Key-Element pairs」的集合為「Dictionary」。  &lt;/p&gt;
&lt;p&gt;如圖一所示，若將先前的字母視為「Element」並加上「Key」，則(Key, Element)可以表示成(編號, A)，若處理學生資料，將編號視為學號，資料視為姓名，則能夠將(Key, Element)可以表示成(學號, 姓名)。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;
&lt;center&gt;
&lt;img alt="dictionary1" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/Intro/f1.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt; &lt;/p&gt;
&lt;p&gt;在接下來的篇幅裡，將使用七龍珠的角色(悟空)作為Element，角色的戰鬥力視為Key：&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;
&lt;center&gt;
&lt;img alt="dictionary2" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/Intro/f2.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;修正後的&lt;code&gt;class TreeNode&lt;/code&gt;可能長這樣： &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;       &lt;span class="c1"&gt;// Element&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Key&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                &lt;span class="c1"&gt;// Key, used for comparison &lt;/span&gt;
     &lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;備註： &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Dictionary的概念也出現在&lt;strong&gt;Hash Table&lt;/strong&gt;(有天才翻譯成"哈希表"也很酷)、C/C++標準函式庫(Standard Library)中的&lt;strong&gt;container&lt;/strong&gt;:&lt;code&gt;map&lt;/code&gt;等等，有非常多應用。&lt;/li&gt;
&lt;li&gt;以下角色戰鬥力的絕對值是捏造的，不過相對值盡力維持正確(除了撒旦)，若有疑問，歡迎龍珠粉來信討論。 &lt;/li&gt;
&lt;li&gt;由於故事的角色眾多，以下將挑選具代表性之角色用來說明BST。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a name="bst"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;Binary Search Tree的特徵&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;有了加裝Dictionary後的&lt;code&gt;TreeNode&lt;/code&gt;，便能夠說明BST的特徵：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;任何CurrnetNode之Key若與其left child、right child之Key有以下關係(若pointer指向&lt;code&gt;NULL&lt;/code&gt;則忽略)：&lt;span class="math"&gt;\(Key(L)&amp;lt;Key(Current)&amp;lt;Key(R)\)&lt;/span&gt;，則可稱這棵樹為Binary Search Tree(BST)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以圖三為例，樹中有三個node，悟空的戰鬥力為1000，龜仙人的戰鬥力為8，克林的戰鬥力為2，若將龜仙人設為&lt;code&gt;root&lt;/code&gt;，則克林的戰鬥力較小，因此成為龜仙人的left child，悟空的戰鬥力較大，便成為龜仙人的right child，如此便滿足&lt;span class="math"&gt;\(Key(L)&amp;lt;Key(Current)&amp;lt;Key(R)\)&lt;/span&gt;，即可稱圖三為一棵BST。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/Intro/f3.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;有了BST後，便能夠替鳥山明老師處理角色之間的戰鬥力關係了。&lt;/p&gt;
&lt;p&gt;&lt;a name="operation"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;在Binary Search Tree中管理資料&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;故事一開始的主要角色有悟空(1000)、龜仙人(8)和克林(2)，以龜仙人為&lt;code&gt;root&lt;/code&gt;能夠建立出一棵BST如圖四：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bst1" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/Intro/f14.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;
&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="insert"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;insert(新增資料)&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;隨著故事劇情推進，角色也會跟著增加，因此，要在BST中&lt;strong&gt;新增node(新增資料)&lt;/strong&gt;。&lt;br /&gt;
在此，比克大魔王現身地球危害人間，其戰鬥力為513，欲將其放進BST，根據BST的規則判斷出，比克的戰鬥力比龜仙人高，因此要將比克放在龜仙人的right subtree(右子樹)；接著，再和悟空比較，比克的戰鬥力比悟空低，因此將比克建立在悟空的left child上，如圖五(a)所示：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="insert" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/Intro/f4.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五(a)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;接著，賽亞人王子達爾登場，其戰鬥力為524，根據BST的規則，判斷出其應在「龜仙人的right subtree」、「悟空的left subtree」與比克的「right child」，如圖五(b)所示。&lt;br /&gt;
在下一篇文章將會看到，實際上的演算法正是以這種方式實現：移動&lt;code&gt;CurrentNode&lt;/code&gt;，並將&lt;code&gt;CurrentNode&lt;/code&gt;之Key與「欲新增之node的Key」比較，找到符合BST規則的位置後，置入新的node。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="insert" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/Intro/f5.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五(b)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="search"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;search(搜尋資料)&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;在處理資料時，時常需要尋找某特定資料，是否存在資料結構中。以BST處理資料，最簡單的方式便是用Key尋找。&lt;br /&gt;
以圖六為例，故事推進到納美克星弗力札大王篇，若想要確認基紐隊長的資料是否已經建立完成，只要記住隊長的戰鬥力為「627」，進入BST中，便能夠找到隊長，必且回傳(return)隊長的node。&lt;br /&gt;
有時會出現欲搜尋的資料尚未被建立進BST中、或者已經從BST中移除的情況，例如，若要在悟空變成超級賽亞人之前找克林，以克林的戰鬥力「2」來搜尋，但是發現找不到，便回傳(return)&lt;code&gt;NULL&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;因為克林被弗力札大王給殺死了啊啊阿啊(變身超級賽亞人)。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="search" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/Intro/f16.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖六：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;（界王神的聲音：為什麼&lt;code&gt;root&lt;/code&gt;從龜仙人變成比克？不會違反BST規則嗎？詳見&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-rotationxuan-zhuan.html"&gt;Red Black Tree系列之Rotation(旋轉)&lt;/a&gt;。）&lt;/p&gt;
&lt;p&gt;&lt;a name="sort"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;sort(排序)&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;故事來到了魔人普烏篇，因為角色有點多，有點混亂，此時，若想要知道各角色戰鬥力的大小排序，只要按照&lt;strong&gt;Inorder Traversal&lt;/strong&gt;即可按照戰鬥力(Key)高低列出所有資料：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="sort" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/Intro/f17.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖七：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="delete"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;delete(刪除資料)&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;最後，當角色死掉去領便當，就需要從BST刪除資料，而根據欲刪除資料之「&lt;strong&gt;child個數&lt;/strong&gt;」可以分成三種情況：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;刪除撒旦：撒旦&lt;strong&gt;沒有child&lt;/strong&gt;，因此，直接把撒旦的parent(普烏)之left child指向&lt;code&gt;NULL&lt;/code&gt;即可。&lt;/li&gt;
&lt;li&gt;刪除弗力札：弗力札有&lt;strong&gt;一個child&lt;/strong&gt;(left child)，因此刪除弗力札之前，需要先把弗力札的left child(基紐)接到弗力札的parent(龜仙人)上，又因為弗力札原本是龜仙人的right child，因此基紐將遞補弗力札，成為龜仙人的right child。&lt;/li&gt;
&lt;li&gt;刪除西魯：西魯有&lt;strong&gt;兩個child&lt;/strong&gt;，稍微麻煩一點，需要「多一個步驟」，將留待之後的文章做詳細說明。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="delete" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BST_fig/Intro/f15.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖八：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;以上便是BST與BST中的基本操作之介紹，所有操作都是以BST之特徵：&lt;span class="math"&gt;\(Key(L)&amp;lt;Key(Current)&amp;lt;Key(R)\)&lt;/span&gt;為出發點，尤其是新增node與刪除node，務必要滿足BST之規則。&lt;/p&gt;
&lt;p&gt;接下來，將以兩篇文章的篇幅，說明上述四種資料處理操作的演算法。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;
&lt;a name="ref"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;參考資料&lt;/strong&gt;：&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844"&gt;Introduction to Algorithms&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376"&gt;Fundamentals of Data Structures in C++&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://zh.wikipedia.org/wiki/%E4%B8%83%E9%BE%99%E7%8F%A0#.E5.8A.87.E5.A0.B4.E7.89.88"&gt;Wikipedia：七龍珠&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.imdb.com/title/tt1178663/"&gt;IMDB：Whatever Works&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name="tree_series"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;Tree系列文章&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/treeshu-introjian-jie.html"&gt;Tree(樹): Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-introjian-jie.html"&gt;Binary Tree: Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-traversalxun-fang.html"&gt;Binary Tree: Traversal(尋訪)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-jian-li-yi-ke-binary-tree.html"&gt;Binary Tree: 建立一棵Binary Tree&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-introjian-jie.html"&gt;Binary Search Tree: Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-searchsou-xun-zi-liao-insertxin-zeng-zi-liao.html"&gt;Binary Search Tree: Search(搜尋資料)、Insert(新增資料)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-sortpai-xu-deleteshan-chu-zi-liao.html"&gt;Binary Search Tree: Sort(排序)、Delete(刪除資料)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-introjian-jie.html"&gt;Red Black Tree: Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-rotationxuan-zhuan.html"&gt;Red Black Tree: Rotation(旋轉)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-insertxin-zeng-zi-liao-yu-fixupxiu-zheng.html"&gt;Red Black Tree: Insert(新增資料)與Fixup(修正)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-deleteshan-chu-zi-liao-yu-fixupxiu-zheng.html"&gt;Red Black Tree: Delete(刪除資料)與Fixup(修正)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;  &lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="C++"></category><category term="Binary Search Tree(二元搜尋樹)"></category><category term="Intro"></category></entry><entry><title>Binary Tree: 建立一棵Binary Tree</title><link href="http://alrightchiu.github.io/SecondRound/binary-tree-jian-li-yi-ke-binary-tree.html" rel="alternate"></link><updated>2015-12-27T16:53:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2015-12-27:SecondRound/binary-tree-jian-li-yi-ke-binary-tree.html</id><summary type="html">&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;先備知識與注意事項&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;在&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-traversal.html#ex_code"&gt;Binary Tree：Traversal&lt;/a&gt;中，非常沒誠意地用暴力方式建了一棵Binary Tree，在這裡至上深深歉意，因此，在本篇文章將提供一種方法，由一個字元陣列(char array)輸入字母，並按照&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-intro.html#fullcomplete"&gt;Complete Binary Tree&lt;/a&gt;之順序重新建立&lt;strong&gt;那顆樹&lt;/strong&gt;。(一種不健康的雪恥心態)&lt;/p&gt;
&lt;p&gt;其中，問題情境之原始資料是一個字元陣列(char array)，為了方便處理(偷懶)選擇使用C++語言中的神器：&lt;a href="http://www3.ntu.edu.sg/home/ehchua/programming/cpp/cp10_io.html"&gt;stringstream&lt;/a&gt;，這裡礙於篇幅與主題(與筆者自己也還在摸索)，就不多談避免誤導，&lt;a href="(http://www3.ntu.edu.sg/home/ehchua/programming/cpp/cp10_io.html)"&gt;點進連結中&lt;/a&gt;有非常詳細的說明，關於&lt;code&gt;istringstream&lt;/code&gt;、&lt;code&gt;ostringstream&lt;/code&gt;、&lt;code&gt;stringstream&lt;/code&gt;等等template class之繼承關係(inheritance)。&lt;br /&gt;
重點是，&lt;code&gt;stringstream&lt;/code&gt;就是神，就是行，學起來簡直光宗耀祖。&lt;/p&gt;
&lt;p&gt;以及，以下提供的Binary Tree之建立方法，基本上是在&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-traversal.html#ex_code"&gt;Binary Tree：Traversal介紹過的level-order traversal&lt;/a&gt;上加油添醋，因此&lt;a href="https://en.wikipedia.org/wiki/Queue_%28abstract_data_type%29"&gt;queue(佇列)&lt;/a&gt;的概念會再次出現。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#description"&gt;問題描述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#code"&gt;程式碼&lt;/a&gt;   &lt;ul&gt;
&lt;li&gt;&lt;a href="#def"&gt;定義class TreeNode、class BinaryTree&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="#constructor"&gt;Constructor of BinaryTree&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="#func1"&gt;Function：LevelorderConstruct()&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#func2"&gt;Function：insertLevelorder()&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#ref"&gt;參考資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#tree_series"&gt;Tree系列文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name="description"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;問題描述&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;問題描述如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;給定一個字元陣列，欲按照Complete Binary Tree之位置規則建立一棵Binary Tree，若陣列元素之資料為大寫字母(ASCII：65~90)，則將其建立成Tree的node，若陣列元素為 ' x ' 則表示該位置沒有node。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-traversal.html#ex_code"&gt;Binary Tree：Traversal&lt;/a&gt;中所提到的Binary Tree為例，如圖一：
&lt;/br&gt;&lt;br /&gt;
&lt;center&gt;
&lt;img alt="binary tree" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/ex.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;   &lt;/p&gt;
&lt;p&gt;其所對應的字元陣列即為：&lt;code&gt;A B C D E F x x x G H x I&lt;/code&gt;，如圖二所示：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="binary tree of char array" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/ex_char.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt; &lt;/p&gt;
&lt;p&gt;以下程式範例的目的就是要以如此文明的方式建立出如圖一的Binary Tree。&lt;/p&gt;
&lt;p&gt;&lt;a name="code"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;程式碼&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;先看看&lt;code&gt;main()&lt;/code&gt;中，上半部分別為：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原始資料：字元陣列；&lt;/li&gt;
&lt;li&gt;以該字元陣列實體化(instantiate)一棵Binary Tree，本篇重點在此；&lt;/li&gt;
&lt;li&gt;以inorder traversal印出樹的資料。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下半部則是示範以&lt;code&gt;queue&lt;/code&gt;實現level-order traversal之小應用：以Complete Binary Tree之位置規則在樹中新增node。  &lt;/p&gt;
&lt;p&gt;溫馨小提醒：純粹以inorder traversal之結果並無法驗證樹之結構正如圖一(舉例來說：以inorder traversal對某一Linked list也可能得出相同結果)，因此，建議還是使用IDE的debug功能把pointer全部攤開。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;sstream&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;queue&amp;gt;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;A B C D E F x x x G H x I&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;BinaryTree&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Inorder_by_parent&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;insertLevelorder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;K&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;insertLevelorder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;L&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;insertLevelorder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;M&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;insertLevelorder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;N&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Inorder_by_parent&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在經過一連串程式碼後，預期得到的output：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;D&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt; &lt;span class="n"&gt;G&lt;/span&gt; &lt;span class="n"&gt;E&lt;/span&gt; &lt;span class="n"&gt;H&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="n"&gt;F&lt;/span&gt; &lt;span class="n"&gt;I&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt;   
&lt;span class="n"&gt;L&lt;/span&gt; &lt;span class="n"&gt;D&lt;/span&gt; &lt;span class="n"&gt;M&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt; &lt;span class="n"&gt;G&lt;/span&gt; &lt;span class="n"&gt;E&lt;/span&gt; &lt;span class="n"&gt;H&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt; &lt;span class="n"&gt;F&lt;/span&gt; &lt;span class="n"&gt;I&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt; &lt;span class="n"&gt;K&lt;/span&gt;    
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;/br&gt; &lt;/p&gt;
&lt;p&gt;&lt;a name="def"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;定義class TreeNode、class BinaryTree&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;幾點說明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;這裡對&lt;code&gt;class TreeNode&lt;/code&gt;與&lt;code&gt;class BinaryTree&lt;/code&gt;之定義，與&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-traversal.html#ex_code"&gt;上一篇文章&lt;/a&gt;之最大不同在於資料的隱蔽性，因為在此不需要於&lt;code&gt;main()&lt;/code&gt;中存取任何pointer(&lt;code&gt;root&lt;/code&gt;、&lt;code&gt;leftchild&lt;/code&gt;、&lt;code&gt;rightchild&lt;/code&gt;)，因此將之放進&lt;strong&gt;private&lt;/strong&gt;區塊。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在許多traversal中，時常以pointer不為&lt;code&gt;NULL&lt;/code&gt;作為&lt;code&gt;while&lt;/code&gt;的判斷式，因此在constructor中，多做一步，將pointer指向&lt;code&gt;NULL&lt;/code&gt;(eg：&lt;code&gt;leftchild = 0&lt;/code&gt;)避免埋地雷在日後炸自己。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在&lt;code&gt;class BinaryTree&lt;/code&gt;除了上一篇介紹過的inorder traversal外，多了兩個新朋友&lt;code&gt;LevelorderConstruct()&lt;/code&gt;與&lt;code&gt;insertLevelorder()&lt;/code&gt;，前者即是本篇主角，吃進&lt;code&gt;stringstream&lt;/code&gt;後，把樹建出來；後者純粹是好玩，其功能為「以Complete Binary Tree之位置規則，在理應出現node的位置，新增node」，能夠儘量減少在新增node時增加樹高(height)。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;看下去。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;BinaryTree&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt; &lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;

    &lt;span class="k"&gt;friend&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;BinaryTree&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;BinaryTree&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;BinaryTree&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;};&lt;/span&gt;
    &lt;span class="n"&gt;BinaryTree&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;LevelorderConstruct&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;stringstream&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;ss&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;insertLevelorder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nf"&gt;leftmost&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nf"&gt;InorderSuccessor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Inorder_by_parent&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;/br&gt;  &lt;/p&gt;
&lt;p&gt;&lt;a name="constructor"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;Constructor of BinaryTree&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;class BinaryTree&lt;/code&gt;的constructor很直觀，拿到一個字元陣列，先送進&lt;code&gt;stringstream&lt;/code&gt;後，再由&lt;code&gt;stringstream&lt;/code&gt;放進樹中，先對樹的&lt;code&gt;root&lt;/code&gt;進行記憶體配置以及賦值，接著以level-order的方式建立Binary Tree。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="n"&gt;BinaryTree&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;BinaryTree&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;stringstream&lt;/span&gt;  &lt;span class="n"&gt;ss&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;ss&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;root&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;ss&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;LevelorderConstruct&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ss&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="func1"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;Function：LevelorderConstruct()&lt;/strong&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;在看&lt;code&gt;LevelorderConstruct()&lt;/code&gt;的函式主體之前，再看一眼&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-traversal.html#level"&gt;level-order traversal&lt;/a&gt;，概念上即是藉著&lt;code&gt;queue&lt;/code&gt;的「先排隊就先購票」的特性，在同一個level中，只要確保由左至右將node放進&lt;code&gt;queue&lt;/code&gt;中，便能確保在進入下一個level後，以先前放入node之順序進行visiting。  &lt;/li&gt;
&lt;li&gt;在&lt;code&gt;while&lt;/code&gt;內，新增條件用來判斷從&lt;code&gt;stringstream&lt;/code&gt;中輸出的字母是「大寫字母」(ASCII：65~90)還是「x」，前者要放入樹中建成node，後者則忽略不計。  &lt;/li&gt;
&lt;li&gt;整份程式碼的關鍵在於神器&lt;code&gt;stringstream &amp;amp;ss&lt;/code&gt;，只要不斷地透過&lt;code&gt;ss &amp;gt;&amp;gt; data&lt;/code&gt;，&lt;code&gt;ss&lt;/code&gt;便會自動尋找下一筆資料餵進&lt;code&gt;data&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;最後，當&lt;code&gt;stringstream&lt;/code&gt;不再更新&lt;code&gt;data&lt;/code&gt;時，也就是字元陣列已全數讀取完畢，即跳出&lt;code&gt;while&lt;/code&gt;迴圈。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;步驟如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，在Binary Tree的constructor中，先配置&lt;code&gt;root&lt;/code&gt;的記憶體位置，並透過第一次&lt;code&gt;ss &amp;gt;&amp;gt; root-&amp;gt;data&lt;/code&gt;將第一個字母放進&lt;code&gt;root&lt;/code&gt;中，如圖三(a)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="construct_0" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/construct0.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(a)：從ss取出第一個字母'A'放進&lt;code&gt;root&lt;/code&gt;。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt; &lt;/p&gt;
&lt;p&gt;接著進入&lt;code&gt;while&lt;/code&gt;迴圈。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;條件式：&lt;code&gt;ss &amp;gt;&amp;gt; data&lt;/code&gt;若為真，表示成功從&lt;code&gt;ss&lt;/code&gt;中取出字母，傳進&lt;code&gt;data&lt;/code&gt;。  &lt;/li&gt;
&lt;li&gt;進入迴圈後，先判斷取出的字母若為大寫字母(在此為&lt;strong&gt;'B'&lt;/strong&gt;)，即生成一個新的&lt;code&gt;new_node&lt;/code&gt;，將B放進&lt;code&gt;new_node&lt;/code&gt;中，並將&lt;code&gt;CurrentNode&lt;/code&gt;(在此為A)的left child指向&lt;code&gt;new_node&lt;/code&gt;，如圖三(b)。  &lt;/li&gt;
&lt;li&gt;在&lt;code&gt;queue&lt;/code&gt;  的部分，若成功建立出新的node(此為B)，便把B放進&lt;code&gt;queue&lt;/code&gt;的隊伍中，表示之後將要把&lt;code&gt;CurrentNode&lt;/code&gt;移到B，繼續往下建立新的node。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt; 
&lt;img alt="construct_1" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/construct1.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(b)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt; &lt;/p&gt;
&lt;p&gt;在同一個迴圈裡，建立完&lt;code&gt;CurrentNode&lt;/code&gt;的left child後，接著嘗試建立right child。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;條件式：&lt;code&gt;if( !(ss &amp;gt;&amp;gt; data) )&lt;/code&gt;若為真，表示&lt;code&gt;ss&lt;/code&gt;中的字母已經讀取完畢，即跳出迴圈(&lt;code&gt;break&lt;/code&gt;)。若否，則繼續從&lt;code&gt;ss&lt;/code&gt;中讀取字母。&lt;/li&gt;
&lt;li&gt;判斷字母是否為大寫字母(此為&lt;strong&gt;'C'&lt;/strong&gt;)，便如同生成left child之方法，建立新的&lt;code&gt;new_node&lt;/code&gt;、配置記憶體、將字母&lt;strong&gt;'C'&lt;/strong&gt;放進&lt;code&gt;new_node&lt;/code&gt;中，並將&lt;code&gt;CurrentNode&lt;/code&gt;之right child指向&lt;code&gt;new_node&lt;/code&gt;，如圖三(c)。&lt;/li&gt;
&lt;li&gt;已成功建立新的node(C)，便把C放進&lt;code&gt;queue&lt;/code&gt;的隊伍中，表示之後將要把&lt;code&gt;CurrentNode&lt;/code&gt;移到B，繼續往下建立新的node。
此時，&lt;code&gt;queue&lt;/code&gt;裡有兩個node，分別為B與C，要注意的是，排隊時，先進入隊伍的人會代表隊伍的前方，因此B為&lt;code&gt;queue&lt;/code&gt;的&lt;strong&gt;Front&lt;/strong&gt;，C為&lt;code&gt;queue&lt;/code&gt;的&lt;strong&gt;Back&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="construct_2" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/construct2.png?raw=true" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(c)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt; &lt;/p&gt;
&lt;p&gt;在建立完&lt;code&gt;CurrentNode&lt;/code&gt;的left child與right child後，接著要移動&lt;code&gt;CurrentNode&lt;/code&gt;，作為下一個&lt;code&gt;while&lt;/code&gt;迴圈的起點。&lt;br /&gt;
&lt;code&gt;queue&lt;/code&gt;的功能便是提供&lt;code&gt;CurrentNode&lt;/code&gt;移動的依據：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一律將&lt;code&gt;queue&lt;/code&gt;隊伍的第一個node視作新的&lt;code&gt;CurrentNode&lt;/code&gt;：&lt;code&gt;CurrentNode = q.front()&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;CurrentNode&lt;/code&gt;移動至B後，便把B從&lt;code&gt;queue&lt;/code&gt;移除：&lt;code&gt;q.pop()&lt;/code&gt;，如圖三(d)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如此便能保證，&lt;code&gt;CurrentNode&lt;/code&gt;的移動會依照level-order「由上至下、由左至右」之順序。
&lt;/br&gt;&lt;br /&gt;
&lt;center&gt;
&lt;img alt="construct_3" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/construct3.png?raw=true" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(d)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt; &lt;/p&gt;
&lt;p&gt;進入第二次&lt;code&gt;while&lt;/code&gt;迴圈後，重複以上之步驟：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;從&lt;code&gt;ss&lt;/code&gt;取出字母，放進&lt;code&gt;data&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;判斷&lt;code&gt;data&lt;/code&gt;是否為大寫，若是，便依序在&lt;code&gt;CurrentNode&lt;/code&gt;之left child與right child建立新的node。&lt;/li&gt;
&lt;li&gt;並且，將成功建立之node放進&lt;code&gt;queue&lt;/code&gt;隊伍中，用作之後&lt;code&gt;CurrentNode&lt;/code&gt;移動之用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;仔細觀察圖三(e)至圖三(h)之&lt;code&gt;ss&lt;/code&gt;與&lt;code&gt;CurrentNode&lt;/code&gt;之移動，與&lt;code&gt;queue&lt;/code&gt;的變化：
&lt;/br&gt;&lt;br /&gt;
&lt;center&gt;
&lt;img alt="construct_4" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/construct4.png?raw=true" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(e)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt; &lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="construct_5" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/construct5.png?raw=true" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(f)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt; &lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="construct_6" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/construct6.png?raw=true" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(g)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt; &lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="construct_7" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/construct7.png?raw=true" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(h)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在建立完C的left child後，從&lt;code&gt;ss&lt;/code&gt;讀取到字母&lt;strong&gt;'x'&lt;/strong&gt;，因為其並非大寫字母，表示C沒有right child，因此跳過生成新的node之步驟，如圖三(i)。  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="construct_8" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/construct8.png?raw=true" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(i)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt; &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若沒有生成新的node，便沒有新的node進入&lt;code&gt;queue&lt;/code&gt;排隊。&lt;/li&gt;
&lt;li&gt;接著要繼續將&lt;code&gt;CurrentNode&lt;/code&gt;移動到&lt;code&gt;queue&lt;/code&gt;的第一個元素，也就是D，並把D從&lt;code&gt;queue&lt;/code&gt;中移除，如圖三(j)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="construct_9" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/construct9.png?raw=true" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(j)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;當&lt;code&gt;CurrentNode&lt;/code&gt;移動到D之後，&lt;code&gt;ss&lt;/code&gt;連續放兩個&lt;strong&gt;'x'&lt;/strong&gt;進入&lt;code&gt;data&lt;/code&gt;，表示D的兩個child pointer皆指向&lt;code&gt;NULL&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;由於沒有新的node產生，&lt;code&gt;queue&lt;/code&gt;的隊伍便沒有更新，如圖三(k)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="construct_10" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/construct10.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(k)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt; &lt;/p&gt;
&lt;p&gt;接著，重複步驟：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;移動&lt;code&gt;CurrentNode&lt;/code&gt;至&lt;code&gt;queue&lt;/code&gt;的第一個元素所指示的node。&lt;/li&gt;
&lt;li&gt;從&lt;code&gt;ss&lt;/code&gt;讀取字母，判斷其為大寫字母，生成新的node接在&lt;code&gt;CurrentNode&lt;/code&gt;的child pointer上。&lt;/li&gt;
&lt;li&gt;若有生成新的node，則將該node推入&lt;code&gt;queue&lt;/code&gt;的隊伍。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="construct_11" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/construct11.png?raw=true" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(l)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt; &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;直到&lt;code&gt;ss&lt;/code&gt;輸出最後一個字母&lt;strong&gt;'I'&lt;/strong&gt;後，這棵樹便建立完成。&lt;/li&gt;
&lt;li&gt;由於，&lt;code&gt;ss&lt;/code&gt;已全數讀取完畢，敘述句：&lt;code&gt;ss &amp;gt;&amp;gt; data&lt;/code&gt;不成立，因此結束迴圈。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="construct_12" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/construct12.png?raw=true" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(m)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt; &lt;/p&gt;
&lt;p&gt;&lt;/br&gt;  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;BinaryTree&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;LevelorderConstruct&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;stringstream&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;ss&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;queue&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="o"&gt;*&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;x&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ss&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;65&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;90&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
            &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;new_node&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  &lt;span class="c1"&gt;// call constructor TreeNode(char s)&lt;/span&gt;
            &lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ss&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
            &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;65&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;90&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
            &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;new_node&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;        &lt;span class="c1"&gt;// call constructor TreeNode()&lt;/span&gt;
            &lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;front&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pop&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;/br&gt;
&lt;a name="func2"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;Function：insertLevelorder()&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;函式&lt;code&gt;insertLevelorder()&lt;/code&gt;的功能是，能夠按照Complete Binary Tree的位置順序放置新增的node，例如，若要在圖三之樹上新增帶有字母&lt;strong&gt;'K'&lt;/strong&gt;的node，則&lt;code&gt;T.insertLevelorder('K')&lt;/code&gt;便會將&lt;strong&gt;'K'&lt;/strong&gt;建成C的right child，如圖四(a)：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="insertK" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/insertK.png?raw=true" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四(a)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt; &lt;/p&gt;
&lt;p&gt;再依序新增L、M、N：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;T.insertLevelorder('L')&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;T.insertLevelorder('M')&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;T.insertLevelorder('N')&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;即會得到如圖四(b)的樹：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="insertLMN" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Construct_from_char_array/insertLMN.png?raw=true" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四(b)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt; &lt;/p&gt;
&lt;p&gt;程式碼之邏輯與&lt;code&gt;LevelorderConstruct&lt;/code&gt;大同小異，最主要的部分就是利用&lt;code&gt;queue&lt;/code&gt;來記錄&lt;code&gt;CurrentNode&lt;/code&gt;移動的順序：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，將&lt;code&gt;current&lt;/code&gt;設成&lt;code&gt;root&lt;/code&gt;，若樹存在，則進入&lt;code&gt;while&lt;/code&gt;迴圈。&lt;/li&gt;
&lt;li&gt;接著判斷，若&lt;code&gt;current&lt;/code&gt;之left child已經有node，則將之放入&lt;code&gt;queue&lt;/code&gt;中，再下次迴圈將以此node作為&lt;code&gt;current&lt;/code&gt;，若left child還沒有node，便產生帶有&lt;code&gt;data&lt;/code&gt;之新node，並將其建立成&lt;code&gt;current&lt;/code&gt;之left child。&lt;br /&gt;
pointer連接完成後，結束迴圈。&lt;/li&gt;
&lt;li&gt;對&lt;code&gt;current&lt;/code&gt;之right child進行相同之步驟。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如此便能有效控制Binary Tree之樹高(height)，使pointer所配置之記憶體空間有效利用，亦能夠減少traversal(以及其他操作)所需的時間。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;BinaryTree&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;insertLevelorder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;    
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;queue&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="o"&gt;*&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;new_node&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;new_node&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;front&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pop&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;/br&gt;&lt;br /&gt;
以上便是利用&lt;code&gt;queue&lt;/code&gt;執行level-order方式建立Binary Tree之範例。&lt;br /&gt;
另外，&lt;a href="http://www.geeksforgeeks.org/level-order-tree-traversal/"&gt;有些方法是利用遞迴的方式，外帶一個迴圈來進行level-order traversal&lt;/a&gt;，也能夠完成相同的功能。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;
&lt;a name="ref"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;參考資料&lt;/strong&gt;：&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844"&gt;Introduction to Algorithms&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376"&gt;Fundamentals of Data Structures in C++&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www3.ntu.edu.sg/home/ehchua/programming/cpp/cp10_io.html"&gt;C++ Programming Language：Stream IO and File IO&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.geeksforgeeks.org/level-order-tree-traversal/"&gt;GeeksforGeeks：Level Order Tree Traversal&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name="tree_series"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;Tree系列文章&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/treeshu-introjian-jie.html"&gt;Tree(樹): Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-introjian-jie.html"&gt;Binary Tree: Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-traversalxun-fang.html"&gt;Binary Tree: Traversal(尋訪)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-jian-li-yi-ke-binary-tree.html"&gt;Binary Tree: 建立一棵Binary Tree&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-introjian-jie.html"&gt;Binary Search Tree: Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-searchsou-xun-zi-liao-insertxin-zeng-zi-liao.html"&gt;Binary Search Tree: Search(搜尋資料)、Insert(新增資料)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-sortpai-xu-deleteshan-chu-zi-liao.html"&gt;Binary Search Tree: Sort(排序)、Delete(刪除資料)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-introjian-jie.html"&gt;Red Black Tree: Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-rotationxuan-zhuan.html"&gt;Red Black Tree: Rotation(旋轉)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-insertxin-zeng-zi-liao-yu-fixupxiu-zheng.html"&gt;Red Black Tree: Insert(新增資料)與Fixup(修正)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-deleteshan-chu-zi-liao-yu-fixupxiu-zheng.html"&gt;Red Black Tree: Delete(刪除資料)與Fixup(修正)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;</summary><category term="C++"></category><category term="Binary Tree(二元樹)"></category></entry><entry><title>Binary Tree: Traversal(尋訪)</title><link href="http://alrightchiu.github.io/SecondRound/binary-tree-traversalxun-fang.html" rel="alternate"></link><updated>2015-12-24T22:41:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2015-12-24:SecondRound/binary-tree-traversalxun-fang.html</id><summary type="html">&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;先備知識與注意事項&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;traversal(尋訪)有「站在A地，往所有與A地相連的地方移動」的意思：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以Graph(圖)的語言來說，站在vertex A上，有一條edge連結A與B，若能夠由A往B移動，此即可視為traversal；&lt;/li&gt;
&lt;li&gt;在以pointer實現之Linked list和Tree中，站在node A上，A具有指向B之pointer，因此能夠由A往B移動，此即可視為traversal。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;移動到特定的node之後，通常伴隨著其他行為，例如print out(顯示資料)、assign(賦值)等等，這些操作又稱作Visiting。&lt;/p&gt;
&lt;p&gt;在閱讀本篇之前，建議先閱讀&lt;a href="http://alrightchiu.github.io/SecondRound/linked-list-traversal.html"&gt;Linked List: Traversal&lt;/a&gt;作簡單複習。在Linked list與Tree中的traversal於pointer的操作概念上完全相同，不過由於Node的pointer增加了，於是從一維的移動拓展到二維的移動。&lt;br /&gt;
本篇文章將介紹在Binary Tree中的四種traversal方法。  &lt;/p&gt;
&lt;p&gt;另外，根據不同的程式實作方法，可能會使用上&lt;a href="https://en.wikipedia.org/wiki/Stack_%28abstract_data_type%29"&gt;stack(堆疊)&lt;/a&gt;與&lt;a href="https://en.wikipedia.org/wiki/Queue_%28abstract_data_type%29"&gt;queue(佇列)&lt;/a&gt;，如果熟悉的話，那就會很酷。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#bttraversal"&gt;Traversal in Binary Tree&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#ex_code"&gt;Example with Code&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#pre"&gt;Pre-Order Traversal&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#in"&gt;In-Order Traversal&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#post"&gt;Post-Order Traversal&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#level"&gt;Level-Order Traversal&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#in_parent"&gt;In-Order Traversal by Parent Field&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#successor"&gt;Successor、leftmost&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#predecessor"&gt;Predecessor、rightmost&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#ref"&gt;參考資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#tree_series"&gt;Tree系列文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name="bttraversal"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;Traversal in Binary Tree&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Binary Tree的Node具有兩個指向child的pointer，Traversal以「當前所在的node」為參考點，所能夠進行的移動有三種：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;V&lt;/strong&gt;：Visiting，對當前所在的node進行print、assign或其他操作。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;L&lt;/strong&gt;：移動到left child。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;R&lt;/strong&gt;：移動到right child。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="VLR" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/VLR.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一：CurrentNode位在A，leftchild與rightchild分別為B與C。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;   &lt;/p&gt;
&lt;p&gt;以圖一為例，假設現在CurrentNode位在A，leftchild與rightchild分別為B與C，並加上一項限制：「L一定在R之前」，便能產生三種相對關係：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="VLR_pre" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/VLR_pre.png?raw=true" /&gt; &lt;img alt="LVR_in" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/VLR_in.png?raw=true" /&gt; &lt;img alt="LRV_post" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/VLR_post.png?raw=true" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二(a)-(c) 依序為： (a)pre-order：VLR、(b)in-order：LVR、(c)post-order：LRV&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;pre-order(VLR)&lt;/strong&gt;：當CurrentNode移動到A時，會先對A進行Visiting，接著前往left child進行Visiting，再前往right child進行Visiting。(若child指向NULL則忽略。)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;in-order(LVR)&lt;/strong&gt;：當CurrentNode移動到A時，會先對A的left child(B)進行Visiting，接著回到A進行Visiting，再前往right child(C)進行Visiting。(若child指向NULL則忽略。)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;post-order(LRV)&lt;/strong&gt;：當CurrentNode移動到A時，會先對A的left child(B)進行Visiting，再前往right child(C)進行Visiting，接著回到A進行Visiting。(若child指向NULL則忽略。)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;
現有一棵樹如圖三(a)，欲進行post-order traversal，並將Visiting用作print(顯示資料)：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bt_a" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/bt_0.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(a)&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;   &lt;/p&gt;
&lt;p&gt;小小備註：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;以下圖例中，V表示CurrentNode所在的node，標上數字後表示已經Visiting，以print(顯示資料)為例，標上"1"表示該node第一個被印出。&lt;/li&gt;
&lt;li&gt;以下文字說明，將使用scope(視野範圍)的概念，用來表示以每個V(CurrentNode)為中心，與其所能夠指向之pointer所構成的範圍(等同於迴圈(或者函式呼叫)的scope)。因為每個迴圈都會改變V(CurrentNode)的位置，因此scope會以V(CurrentNode)為中心不停移動，直到迴圈結束。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;post-order traversal流程如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一開始，CurrentNode進到A(root)，按照post-order的順序規則(LRV)，先檢查B(left child)是否為NULL，若不是，則先移動到B(L)：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bt_b" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/bt_1.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(b)：scope內：A(V)、B(L)、C(R)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;當CurrentNode移動到B，再一次執行post-order的順序規則，檢查D(left child)是否為NULL，若不是，則移動到D(L)：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bt_c" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/bt_2.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(c)：scope內：B(V)、D(L)、E(R)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;當CurrentNode移動到D，再一次執行post-order的順序規則，檢查出D的left child與right child皆為NULL，則回到D做Visiting，在此即印出D(print)，並回到B。  &lt;/li&gt;
&lt;li&gt;回到B的動作發生，即表示「以D為CurrentNode之迴圈或函式已經結束」，於是回到尚未結束的「以B為CurrentNode」之scope。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bt_d" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/bt_3.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(d)：scope內：D(V)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;D已經進行過Visiting，便標上數字"1"，表示D為traversal的第一站。&lt;br /&gt;
接著，在「以B為CurrentNode」的scope中，根據post-order規則，繼續往E(R)移動。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bt_e" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/bt_4.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(e)：scope內：B(V)、D(L)、E(R)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;進入E後，因為E為leaf node，因此過程如圖三(d)，不會進入NULL。&lt;br /&gt;
在D(L)與E(R)都Visiting過後，便回到B(V)進行Visiting，並標上數字。  &lt;/li&gt;
&lt;li&gt;接著回到「以A為CurrentNode」的程序(procedure)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bt_f" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/bt_5.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(f)：scope內：B(V)、D(L)、E(R)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;回到「以A為CurrentNode」的scope後，按照post-order的規則，接著往C(R)移動。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bt_g" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/bt_6.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(g)：scope內：A(V)、B(L)、C(R)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同樣地步驟，再從C移動至F(L)，並發現F為leaf node，於是對F進行Visiting，並標上數字。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bt_h" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/bt_7.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(h)：scope內：C(V)、F(L)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;列出F後，發現C的right child指向NULL，於是略過right child(R)，回到C(V)，並對C進行Visiting，標上數字。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bt_i" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/bt_8.png?raw=true" /&gt;&lt;img alt="bt_j" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/bt_9.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(i)-(j)：scope內：C(V)、F(L)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最後回到「以A為CurrentNode」的scope，對A(V)進行Visiting，便完成了此次post-order traversal，並依序印出&lt;code&gt;D E B F C A&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="bt_k" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/bt_10.png?raw=true" /&gt;&lt;img alt="bt_l" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/bt_11.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三(k)-(l)：scope內：A(V)、B(L)、C(R)。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;以上說明了post-order traversal之過程，另外兩種pre-order與in-order在概念上皆相同，只要把握順序規則即可。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="ex_code"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;Example with Code&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;接下來，再以一棵稍微複雜的Binary Tree作為範例，展示pre-order、in-order、post-order及level-order之traversal。&lt;/p&gt;
&lt;p&gt;現有一棵樹如圖四(a)：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="ex" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/ex.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四(a)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;並以最暴力的方式建立&lt;code&gt;TreeNode&lt;/code&gt;與&lt;code&gt;BinaryTree&lt;/code&gt;之物件(object)：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;string&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;queue&amp;gt;&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;BinaryTree&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
        &lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;};&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;};&lt;/span&gt;

    &lt;span class="k"&gt;friend&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;BinaryTree&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;BinaryTree&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;         &lt;span class="c1"&gt;// 以root作為存取整棵樹的起點&lt;/span&gt;
    &lt;span class="n"&gt;BinaryTree&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;};&lt;/span&gt;
    &lt;span class="n"&gt;BinaryTree&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;){};&lt;/span&gt;

    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Preorder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Inorder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Postorder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Levelorder&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="c1"&gt;// definition of BinaryTree::Preorder()&lt;/span&gt;
&lt;span class="c1"&gt;// definition of BinaryTree::Inorder()&lt;/span&gt;
&lt;span class="c1"&gt;// definition of BinaryTree::Postorder()&lt;/span&gt;
&lt;span class="c1"&gt;// definition of BinaryTree::Levelorder()&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// TreeNode instantiation&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;A&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;B&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;B&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;C&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;D&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;D&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;E&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;E&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;F&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;F&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;G&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;G&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;H&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;H&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;I&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;I&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="c1"&gt;// construct the Binary Tree&lt;/span&gt;
    &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; 
    &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;D&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;E&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; 
    &lt;span class="n"&gt;E&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;G&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;E&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;H&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; 
    &lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;F&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;F&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;I&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;BinaryTree&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Preorder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Inorder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Postorder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Levelorder&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上面的程式碼包含了幾個部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;class TreeNode的定義；&lt;/li&gt;
&lt;li&gt;class BinaryTree的定義，其中有四個member function分別為四種traversal；&lt;/li&gt;
&lt;li&gt;main()中建立如圖四(a)的樹，並在&lt;strong&gt;line54 - line61&lt;/strong&gt;執行四種traversal。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;尚缺的四個函式的定義(definition)請接著看下去。&lt;br /&gt;
其中，pre-order、in-order、post-order traversal的邏輯就只是「V」、「L」、「R」誰先誰後的差別，以下程式碼是以較直覺的遞迴(recursion)形式完成，不過，換成迭代(iteration)配合&lt;a href="https://en.wikipedia.org/wiki/Stack_%28abstract_data_type%29"&gt;stack(堆疊)&lt;/a&gt;在概念上完全相同，實作上即是考慮「V」、「L」、「R」誰先push(推)進stack。  &lt;/p&gt;
&lt;p&gt;&lt;a name="pre"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;Pre-Order Traversal&lt;/strong&gt;&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;BinaryTree&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Preorder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot; &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="c1"&gt;// V&lt;/span&gt;
        &lt;span class="n"&gt;Preorder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;       &lt;span class="c1"&gt;// L&lt;/span&gt;
        &lt;span class="n"&gt;Preorder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;      &lt;span class="c1"&gt;// R&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;output:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt; &lt;span class="n"&gt;D&lt;/span&gt; &lt;span class="n"&gt;E&lt;/span&gt; &lt;span class="n"&gt;G&lt;/span&gt; &lt;span class="n"&gt;H&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt; &lt;span class="n"&gt;F&lt;/span&gt; &lt;span class="n"&gt;I&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;center&gt;
&lt;img alt="ex_pre" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/ex_pre.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四(b)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="in"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;In-Order Traversal&lt;/strong&gt;&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;BinaryTree&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Inorder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;Inorder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;        &lt;span class="c1"&gt;// L&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot; &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="c1"&gt;// V&lt;/span&gt;
        &lt;span class="n"&gt;Inorder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;       &lt;span class="c1"&gt;// R&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;output:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;D&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt; &lt;span class="n"&gt;G&lt;/span&gt; &lt;span class="n"&gt;E&lt;/span&gt; &lt;span class="n"&gt;H&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="n"&gt;F&lt;/span&gt; &lt;span class="n"&gt;I&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;center&gt;
&lt;img alt="ex_in" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/ex_in.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四(c)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="post"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;Post-Order Traversal&lt;/strong&gt;&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;BinaryTree&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Postorder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;Postorder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;     &lt;span class="c1"&gt;// L&lt;/span&gt;
        &lt;span class="n"&gt;Postorder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;    &lt;span class="c1"&gt;// R&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot; &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;// V&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;output:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;D&lt;/span&gt; &lt;span class="n"&gt;G&lt;/span&gt; &lt;span class="n"&gt;H&lt;/span&gt; &lt;span class="n"&gt;E&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt; &lt;span class="n"&gt;I&lt;/span&gt; &lt;span class="n"&gt;F&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;center&gt;
&lt;img alt="ex_post" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/ex_post.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四(d)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="level"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;Level-Order Traversal&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;先前介紹了pre-order、in-order、post-order的traversal，而level-order則是照著level由小到大的順序，由上而下，並在同一個level由左至右地依序Visiting每個node。
以下提供迭代(iteration)配合&lt;a href="https://en.wikipedia.org/wiki/Queue_%28abstract_data_type%29"&gt;queue(佇列)&lt;/a&gt;實現level-order traversal之程式碼，其邏輯也非常直觀：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以圖四(e)為例，當CurrentNode站在A時，先對A作Visiting，接著檢查是否有left child與right child，若不為NULL，則依序push(推)進queue中，又根據queue「先進先出」(first-in-first-out)的特性，先將B(left child)推入queue，再推入C(right child)，便能確保在下一層level時，是由左至右，先Visiting到B，才Visiting到C。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="ex_level" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/ex_level.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四(e)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;BinaryTree&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Levelorder&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;queue&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="o"&gt;*&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot; &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;empty&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
            &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;front&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pop&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;output:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt; &lt;span class="n"&gt;D&lt;/span&gt; &lt;span class="n"&gt;E&lt;/span&gt; &lt;span class="n"&gt;F&lt;/span&gt; &lt;span class="n"&gt;G&lt;/span&gt; &lt;span class="n"&gt;H&lt;/span&gt; &lt;span class="n"&gt;I&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;/br&gt;
&lt;a name="in_parent"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;In-Order Traversal by Parent Field&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;在&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-intro.html#code"&gt;Binary Tree：Intro&lt;/a&gt;提到，若在&lt;code&gt;class TreeNode&lt;/code&gt;加入pointer指向其parent node會非常有幫助，其中一項理由正是接下來要介紹的兩個函式：InorderSuccessor()與InorderPredecessor()。&lt;br /&gt;
說文解字時間：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;字首Inorder-，即是按照inorder之順序規則並應用於inorder traversal；&lt;/li&gt;
&lt;li&gt;字尾Successor/ Predecessor，即是「下一個」與「前一個」。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，InorderSuccessor()與InorderPredecessor()便是用來尋找「以inorder順序」進行traversal之下一個與前一個node。&lt;br /&gt;
以圖四(c)為例，若CurrentNode站在H(&lt;code&gt;CurrentNode = H&lt;/code&gt;)，則&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;CurrentNode = InorderSuccessor(CurrentNode)&lt;/code&gt;會將CurrentNode移動至A；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CurrentNode = InorderPredecessor(CurrentNode)&lt;/code&gt;則會將CurrentNode移動至E。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="ex_in" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/ex_in.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四(c)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;特別介紹inorder，一大原因是為了Binary Search Tree(BST)鋪路，在BST中，照著inorder順序印出node，就會得到排序過的資訊(詳見：&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-sortpai-xu-deleteshan-chu-zi-liao.html#binary-search-tree-sortpai-xu-deleteshan-chu-zi-liao"&gt;Binary Search Tree: Sort(排序)、Delete(刪除資料)&lt;/a&gt;)。&lt;br /&gt;
另外，若觀察前面提過的遞迴(recursion)形式之inorder traversal，Visiting被包含在遞迴函式內，這表示若要進行多種不同的Visiting，例如print(顯示資料)、assign(賦值、更新資料)，都需要重新寫一個專門功能的遞迴函式。顯然，把Visiting和Traversal獨立開來會更有效率。&lt;/p&gt;
&lt;p&gt;在看兩個實用的函式之前，有幾件前置作業：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在main()裡建立圖四之Binary Tree的部分，連結node與其parent node之pointer：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="c1"&gt;// inside main()&lt;/span&gt;
    &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;D&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;E&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;D&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;E&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;E&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;G&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;E&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;H&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;G&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;E&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;H&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;E&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;F&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;F&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;F&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;I&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;I&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;F&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;並在&lt;code&gt;class BinaryTree&lt;/code&gt;的定義中加入六個member function(成員函式)：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="c1"&gt;// inside definition of class BinaryTree&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nf"&gt;leftmost&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nf"&gt;rightmost&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nf"&gt;InorderSuccessor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nf"&gt;InorderPredecessor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Inorder_by_parent&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Inorder_Reverse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中，除了&lt;code&gt;InorderSuccessor()&lt;/code&gt;與&lt;code&gt;InorderPredecessor()&lt;/code&gt;之函式主體外，還有&lt;code&gt;leftmost()&lt;/code&gt;和&lt;code&gt;rightmost()&lt;/code&gt;即是找到Binary Tree中最左與最右的node，可有可無，不過學會了很酷；以及&lt;code&gt;Inorder_by_parent()&lt;/code&gt;與&lt;code&gt;Inorder_Reverse()&lt;/code&gt;為用以呼叫&lt;code&gt;InorderSuccessor()&lt;/code&gt;與&lt;code&gt;InorderPredecessor()&lt;/code&gt;的迴圈主體。&lt;/p&gt;
&lt;p&gt;看下去。&lt;/p&gt;
&lt;p&gt;&lt;a name="successor"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;Successor、leftmost&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;函式&lt;code&gt;TreeNode* leftmost(TreeNode *current)&lt;/code&gt;的功能為：尋找以&lt;code&gt;current&lt;/code&gt;為root之subtree中，最左邊的node，最左邊的意思是從&lt;code&gt;current&lt;/code&gt;開始一路往left child做類似&lt;a href="http://alrightchiu.github.io/SecondRound/linked-list-traversal.html"&gt;Linked list之單向traversal&lt;/a&gt;的「一路向左」，而以inorder的順序來說，會找到該subtree中第一個進行Visiting的node。以圖四(c)為例，進入以A為root的Binary Tree，&lt;code&gt;leftmost()&lt;/code&gt;將回傳D。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;BinaryTree&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;leftmost&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;接著觀察在inorder規則下，某一node的下一個node的所在位置有兩種可能：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;若CurrentNode的right child不是NULL，則CurrentNode之下一個順序的node即為以「Current-&amp;gt;rightchild為root」之subtree中，最左的node。&lt;br /&gt;
如圖五(a)所示，若CurrentNode站在B上，B的下一個node即為「以B的right child(也就是E)」為root之subtree中的最左node，即為G。&lt;/li&gt;
&lt;li&gt;若CurrentNode沒有right child，則CurrentNode之下一個順序的node是「以left child的身份尋找到的ancestor」。&lt;br /&gt;
以圖五(a)中的H為例，H沒有right child，因此往上(往root方向)找ancestor，首先找到E，但是H是E的right child，因此再繼續往上找，此時CurrentNode移動到E。而E也是B的right child，再更新CurrentNode為B，往parent找到A，此時，&lt;strong&gt;B為A的left child&lt;/strong&gt;，則A即為H的下一個順序的node。&lt;/li&gt;
&lt;li&gt;若整棵樹偏一邊(稱為skewed Binary Tree)，root只有left subtree，沒有right subtree，則回傳NULL，表示root的successor。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="successor" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/successor.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五(a)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;BinaryTree&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;InorderSuccessor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;leftmost&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;new_node&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;new_node&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;new_node&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;new_node&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;最後，有了&lt;code&gt;leftmost()&lt;/code&gt;與&lt;code&gt;InorderSuccessor()&lt;/code&gt;，即能夠以迴圈的方式進行inorder traversal，相較於遞迴形式的函式，具有更大彈性：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;BinaryTree&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Inorder_by_parent&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;leftmost&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot; &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;InorderSuccessor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;output:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;D&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt; &lt;span class="n"&gt;G&lt;/span&gt; &lt;span class="n"&gt;E&lt;/span&gt; &lt;span class="n"&gt;H&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="n"&gt;F&lt;/span&gt; &lt;span class="n"&gt;I&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;/br&gt;
&lt;a name="predecessor"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;Predecessor、rightmost&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;只要把&lt;code&gt;InorderSuccessor()&lt;/code&gt;與&lt;code&gt;leftmost()&lt;/code&gt;中，所有的left與right互換，就得到&lt;code&gt;InorderPredecessor()&lt;/code&gt;與&lt;code&gt;rightmost()&lt;/code&gt;，而概念上也確實是如此：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;rightmost&lt;/strong&gt;：從「以CurrentNode為subtree」的root一路向右做Linked list的單向traversal。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Predecessor&lt;/strong&gt;：某一CurrentNode的「前一個順序的node」之位置有兩種可能：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;若CurrentNode的left child不是NULL，則CurrentNode之前一個順序的node即為以「Current-&amp;gt;lefttchild為root」之subtree中，最右的node。&lt;br /&gt;
如圖五(b)所示，若CurrentNode站在C上，C的前一個node即為「以C的right child(也就是F)」為root之subtree中的最右node，即為I。&lt;/li&gt;
&lt;li&gt;若CurrentNode沒有left child，則CurrentNode之前一個順序的node是「以right child的身份尋找到的ancestor」。&lt;br /&gt;
以圖五(b)中的F為例，F沒有left child，因此往上(往root方向)找ancestor，首先找到C，但是F是C的left child，因此再繼續往上找，此時CurrentNode為C，往parent找到A，此時，&lt;strong&gt;C為A的right child&lt;/strong&gt;，則A即為F的前一個順序的node。&lt;/li&gt;
&lt;li&gt;同樣地，若整棵樹為skewed Binary Tree，root只有right subtree，沒有left subtree，則回傳NULL，表示root的predecessor。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="predecessor" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Traversal/predecessor.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五(b)：。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;BinaryTree&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;rightmost&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;BinaryTree&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;InorderPredecessor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;rightmost&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;new_node&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;new_node&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;new_node&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;new_node&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;new_node&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;有了&lt;code&gt;rightmost()&lt;/code&gt;與&lt;code&gt;InorderPredecessor()&lt;/code&gt;，便能夠照inorder traversal的相反順序對樹的node做Visiting：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;BinaryTree&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Inorder_Reverse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;rightmost&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot; &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;InorderPredecessor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;output:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;C&lt;/span&gt; &lt;span class="n"&gt;I&lt;/span&gt; &lt;span class="n"&gt;F&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="n"&gt;H&lt;/span&gt; &lt;span class="n"&gt;E&lt;/span&gt; &lt;span class="n"&gt;G&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt; &lt;span class="n"&gt;D&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;/br&gt;&lt;br /&gt;
&lt;code&gt;InorderSuccessor()&lt;/code&gt;和&lt;code&gt;InorderPredecessor()&lt;/code&gt;在Binary Search Tree的部分會再次出現，並且出現在基本操作：deletion(刪除node)中，因此學起來不止酷，還很實用的啊。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;
&lt;a name="ref"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;參考資料&lt;/strong&gt;：&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844"&gt;Introduction to Algorithms&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376"&gt;Fundamentals of Data Structures in C++&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Stack_%28abstract_data_type%29"&gt;Wikipedia：Stack(abstract data type)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Queue_%28abstract_data_type%29"&gt;Wikipedia：Queue(abstract data type)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name="tree_series"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;Tree系列文章&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/treeshu-introjian-jie.html"&gt;Tree(樹): Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-introjian-jie.html"&gt;Binary Tree: Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-traversalxun-fang.html"&gt;Binary Tree: Traversal(尋訪)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-jian-li-yi-ke-binary-tree.html"&gt;Binary Tree: 建立一棵Binary Tree&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-introjian-jie.html"&gt;Binary Search Tree: Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-searchsou-xun-zi-liao-insertxin-zeng-zi-liao.html"&gt;Binary Search Tree: Search(搜尋資料)、Insert(新增資料)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-sortpai-xu-deleteshan-chu-zi-liao.html"&gt;Binary Search Tree: Sort(排序)、Delete(刪除資料)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-introjian-jie.html"&gt;Red Black Tree: Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-rotationxuan-zhuan.html"&gt;Red Black Tree: Rotation(旋轉)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-insertxin-zeng-zi-liao-yu-fixupxiu-zheng.html"&gt;Red Black Tree: Insert(新增資料)與Fixup(修正)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-deleteshan-chu-zi-liao-yu-fixupxiu-zheng.html"&gt;Red Black Tree: Delete(刪除資料)與Fixup(修正)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;</summary><category term="C++"></category><category term="Binary Tree(二元樹)"></category></entry><entry><title>Linked List: Traversal(尋訪)</title><link href="http://alrightchiu.github.io/SecondRound/linked-list-traversalxun-fang.html" rel="alternate"></link><updated>2015-12-23T20:00:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2015-12-23:SecondRound/linked-list-traversalxun-fang.html</id><summary type="html">&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;先備知識與注意事項&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;traversal(尋訪)有「站在A地，往所有與A地相連的地方移動」的意思：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以Graph(圖)的語言來說，站在vertex A上，有一條edge連結A與B，若能夠由A往B移動，此即可視為traversal；&lt;/li&gt;
&lt;li&gt;在以pointer實現之Linked list和Tree中，站在node A上，A具有指向B之pointer，因此能夠由A往B移動，此即可視為traversal。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;移動到特定的node之後，通常伴隨著其他行為，例如print out(顯示資料)、assign(賦值)等等，這些操作又稱作Visiting。&lt;/p&gt;
&lt;p&gt;這篇文章將介紹在Linked list中的traversal。  &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;&lt;strong&gt;Traversal in Linked List&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;若有一個Linked list如圖一：&lt;/p&gt;
&lt;p&gt;&lt;/br&gt; 
&lt;center&gt;
&lt;img alt="linked list" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Linked%20List/Traversal_fig/LLtraversal.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一：Linked list: A-&amp;gt;B-&amp;gt;C-&amp;gt;D-&amp;gt;NULL。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;   &lt;/p&gt;
&lt;p&gt;現要求Visiting為print(顯示資料)，欲列印出Linked list中的所有字母，也就是從A開始，依序印出B、C、D，程式範例如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;string&amp;gt;&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;         &lt;span class="c1"&gt;// pointer to next node&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="c1"&gt;// data&lt;/span&gt;

    &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;(){};&lt;/span&gt;                       &lt;span class="c1"&gt;// default constructor&lt;/span&gt;
    &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;){};&lt;/span&gt;   &lt;span class="c1"&gt;// constructor&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;traversal&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;CurrentNode&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CurrentNode&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;CurrentNode&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot; &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;traversal&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CurrentNode&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// initialize nodes&lt;/span&gt;
    &lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;A&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;B&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;B&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;C&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;D&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;D&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="c1"&gt;// construct linked list&lt;/span&gt;
    &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;D&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;// representing the front of linked list by CurrentNode&lt;/span&gt;
    &lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;CurrentNode&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;// traversal by iteration &lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CurrentNode&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;CurrentNode&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot; &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;CurrentNode&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;CurrentNode&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;// traversal by recursion&lt;/span&gt;
    &lt;span class="n"&gt;traversal&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;output：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;A B C D     // from while loop
A B C D     // from traversal()
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;line5 - line12：&lt;/strong&gt;定義&lt;code&gt;class Node&lt;/code&gt;，其中包含了指向下一個node的pointer，以&lt;code&gt;string&lt;/code&gt;攜帶字母，以及&lt;code&gt;Node&lt;/code&gt;的constructor。(為了在main()中能夠取用，全部寫成public member。)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;line13 - line18：&lt;/strong&gt;此為recursion(遞迴)形式的traversal，與&lt;strong&gt;line42&lt;/strong&gt;一併討論。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;line21 - line24：&lt;/strong&gt;定義帶有字母A、B、C、D的node。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;line27 - line29：&lt;/strong&gt;示範如何使用最暴力的方式建立出如圖一的Linked list。(管理Linked list之過程時常是動態的(今天新增一筆資料，明天刪除兩筆資料)，因此建議將「新增node」寫成函式形式，例如：insert())。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;line32：&lt;/strong&gt; 定義&lt;code&gt;CurrentNode&lt;/code&gt;表示「當前所位於的node」。在Linked list(及其衍生資料結構)的操作中，時常使用CurrentNode，目的是為了讓函式能夠有效地重複利用。&lt;br /&gt;
舉例來說，若要用最暴力的方式依序印出A、B、C、D：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot; &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot; &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot; &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;output：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt; &lt;span class="n"&gt;D&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然而，這樣的寫法除了&lt;a href="https://www.youtube.com/watch?v=Qdcfxk-e_iw"&gt;太hardcore&lt;/a&gt;之外，還有幾點缺陷：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只有當資料量小，並且站在全知視角(已經知道Linked list中A、B、C、D之相對位置)時，才能土法煉鋼。假設Linked list中有一百個node，欲依序列出資料，又或者Node裡不只有定義pointer next，而是有pointer next1、next2、next3，就只好關閉視窗。&lt;/li&gt;
&lt;li&gt;資料隱蔽問題：一般情況，在定義&lt;code&gt;class Node&lt;/code&gt;時，不會把&lt;code&gt;Node *next&lt;/code&gt;與&lt;code&gt;string str&lt;/code&gt;裸露在外，而是寫成private member讓使用者無法任意修改。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;隱蔽性問題這裡不多談，大致上的方向是使用member function存取private member。&lt;br /&gt;
接著要處理的是程式的重複使用性。  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;line35 - line38：&lt;/strong&gt; traversal主體。  &lt;/p&gt;
&lt;p&gt;分解步驟如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;line35&lt;/strong&gt;：在&lt;strong&gt;line32&lt;/strong&gt;定義之&lt;code&gt;CurrentNode&lt;/code&gt;目前為node A，不是NULL，因此進入&lt;code&gt;While&lt;/code&gt;迴圈。&lt;br /&gt;
如圖二所示，在第一次迴圈中，可觸及的Node只有&lt;code&gt;CurrentNode&lt;/code&gt;與&lt;code&gt;CurrentNode-&amp;gt;next&lt;/code&gt;，即為A與B。 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="linked list_1" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Linked%20List/Traversal_fig/LLtraversal1.png?raw=true" /&gt;&lt;br /&gt;
&lt;strong&gt;圖二：第一次迴圈，可觸及的node只有A與B。&lt;/strong&gt;
&lt;/center&gt; &lt;br /&gt;
&lt;/br&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;line36&lt;/strong&gt;：列印出&lt;code&gt;CurrentNode&lt;/code&gt;所帶的字母。  &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;line37&lt;/strong&gt;：將&lt;code&gt;CurrentNode&lt;/code&gt;移動至&lt;code&gt;CurrentNode&lt;/code&gt;所指向的下一個node，亦即，從A移動到B。  &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;line38&lt;/strong&gt;：跳出迴圈後，若更新過後的&lt;code&gt;CurrentNode&lt;/code&gt;仍不為NULL(在A之後的是B)，將進入第二次&lt;code&gt;while&lt;/code&gt;迴圈，重複&lt;strong&gt;line35 - line38&lt;/strong&gt;。  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;依此類推，第二至第四次迴圈之示意圖如下：&lt;br /&gt;
&lt;/br&gt;
&lt;center&gt;
&lt;img alt="linked list_2" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Linked%20List/Traversal_fig/LLtraversal2.png?raw=true" /&gt;&lt;br /&gt;
&lt;strong&gt;圖三：第二次迴圈，視野範圍內可觸及的node為B與C。&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt;&lt;img alt="linked list_3" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Linked%20List/Traversal_fig/LLtraversal3.png?raw=true" /&gt;&lt;br /&gt;
&lt;strong&gt;圖四：第三次迴圈，視野範圍內可觸及的node為C與D。&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt;&lt;img alt="linked list_4" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Linked%20List/Traversal_fig/LLtraversal4.png?raw=true" /&gt;&lt;br /&gt;
&lt;strong&gt;圖五：第四次迴圈，視野範圍內可觸及的node只有D。&lt;/strong&gt;
&lt;/center&gt; &lt;br /&gt;
&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;直到第四次迴圈之&lt;strong&gt;line37&lt;/strong&gt;，&lt;code&gt;CurrentNode&lt;/code&gt;更新為NULL，表示已經抵達Linked list的尾端，同時，不滿足&lt;code&gt;while&lt;/code&gt;之條件式，便結束迴圈。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;line42：&lt;/strong&gt; 函式traversal()之主體(&lt;strong&gt;line13 - line18&lt;/strong&gt;)與&lt;strong&gt;line35 - line38&lt;/strong&gt;之&lt;code&gt;while&lt;/code&gt;迴圈具有相同的作用。兩者皆能列印出Linked list中的所有資料。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;  &lt;/p&gt;
&lt;p&gt;以上是在Linked list中，單向(single direction)的traversal之介紹，只要把握pointer對記憶體位置(memory address)的操作原則，應該能輕鬆掌握。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;參考資料&lt;/strong&gt;：&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Linked_list"&gt;Wikipedia：Linked List&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.youtube.com/watch?v=Qdcfxk-e_iw"&gt;太hardcore了&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;  &lt;/p&gt;</summary><category term="C++"></category><category term="Linked List(連結串列)"></category></entry><entry><title>Binary Tree: Intro(簡介)</title><link href="http://alrightchiu.github.io/SecondRound/binary-tree-introjian-jie.html" rel="alternate"></link><updated>2015-12-21T22:24:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2015-12-21:SecondRound/binary-tree-introjian-jie.html</id><summary type="html">&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;先備知識與注意事項&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;接續上一篇談到的&lt;a href="http://alrightchiu.github.io/SecondRound/treeshu.html"&gt;Tree(樹)&lt;/a&gt;，這篇文章將介紹樹這個大集合裡的其中一支大宗：&lt;strong&gt;Binary Tree&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;
學海無涯，快點跳海。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#bt"&gt;Binary Tree&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#code"&gt;程式碼&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#fullcomplete"&gt;Full &amp;amp; Complete Binary Tree&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#application"&gt;學習Binary Tree的未來出路&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#ref"&gt;參考資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#tree_series"&gt;Tree系列文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name="bt"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;Binary Tree&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;最廣義的樹(Tree)對於樹上的node之child數目沒有限制，因此，每個node可以有多個child。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;br /&gt;
&lt;img alt="general_tree" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Intro/general_tree.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一：這是一棵樹(Tree)&lt;/strong&gt;
&lt;/center&gt;  &lt;/p&gt;
&lt;p&gt;若限制node只能有兩個child，等價於「樹上的每一個node之degree皆為2」，此即稱為&lt;strong&gt;Binary Tree&lt;/strong&gt;(二元樹)，並稱兩個child pointer為left child和right-child。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;br /&gt;
&lt;img alt="binary_tree" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Intro/binary_tree.png?raw=true" /&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二：這是一棵Binary Tree。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="code"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;程式碼&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;修改在&lt;a href="http://alrightchiu.github.io/SecondRound/treeshu.html#code"&gt;Tree(樹)&lt;/a&gt;提供的程式實作方式，將node的child pointer設為left child與right child，以滿足Binary Tree的形式。&lt;br /&gt;
另外，在class TreeNode有個&lt;code&gt;TreeNode *parent&lt;/code&gt;，顧名思義，即是指向該node之parent的pointer，以圖二為例，B的parent pointer即指向A。&lt;br /&gt;
Binary Tree的node未必需要parent pointer(或稱為parent field)，然而加入parent後，在對樹的操作(operaion)如inorder traversal(中序尋訪)、node deletion(刪除node)、以及任何需要back-tracing(回溯路徑)的操作時，會更加有效率。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// 以C++為例&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Tree&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;         
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;       
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;           
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;data1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                  
    &lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="n"&gt;data2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;...&lt;/span&gt;
    &lt;span class="k"&gt;friend&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Tree&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Tree&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;             &lt;span class="c1"&gt;// 以root作為存取整棵樹的起點&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;a name="fullcomplete"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;Full &amp;amp; Complete Binary Tree&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;有兩類Binary Tree十分常見，分別為&lt;strong&gt;Full Binary Tree&lt;/strong&gt;以及&lt;strong&gt;Complete Binary Tree&lt;/strong&gt;。&lt;br /&gt;
(完滿二元樹？完整二元樹？我的建議是當作專有名詞不要翻譯。) &lt;/p&gt;
&lt;h5&gt;&lt;strong&gt;A. Full Binary Tree&lt;/strong&gt;:&lt;/h5&gt;
&lt;p&gt;如圖三所示，一棵&lt;strong&gt;Full Binary Tree&lt;/strong&gt;(或稱作Perfect Binary Tree)具有以下性質：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有internal node都有兩個subtree(也就是兩個child pointer)；&lt;/li&gt;
&lt;li&gt;所有leaf node具有相同的level(或相同的height)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由以上性質能夠推論出，若一棵Full Binary Tree的leaf node之level為&lt;span class="math"&gt;\(n\)&lt;/span&gt;，整棵樹共有&lt;span class="math"&gt;\(2^n-1\)&lt;/span&gt;個node。leaf node的level為4， 整棵樹共有15個node。&lt;br /&gt;
並且，每個node與其child有以下關係：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第&lt;span class="math"&gt;\(i\)&lt;/span&gt;個node的left child之index為 &lt;span class="math"&gt;\(2i\)&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;第&lt;span class="math"&gt;\(i\)&lt;/span&gt;個node的right child之index為 &lt;span class="math"&gt;\(2i+1\)&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;除了root之parent為NULL之外，第&lt;span class="math"&gt;\(i\)&lt;/span&gt;個node的parent之index為 &lt;span class="math"&gt;\(\lfloor {i\over2} \rfloor\)&lt;/span&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="Full Binary Tree" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Intro/fullBT.png?raw=true" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三：若一棵Full Binary Tree的leaf node之level為&lt;span class="math"&gt;\(n\)&lt;/span&gt;，整棵樹共有&lt;span class="math"&gt;\(2^n-1\)&lt;/span&gt;個node。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;   &lt;/p&gt;
&lt;h5&gt;&lt;strong&gt;B. Complete Binary Tree&lt;/strong&gt;:&lt;/h5&gt;
&lt;p&gt;若一棵樹的node按照Full Binary Tree的次序排列(由上至下，由左至右)，則稱此樹為&lt;strong&gt;Complete Binary Tree&lt;/strong&gt;。  &lt;/p&gt;
&lt;p&gt;以圖四及圖五作說明。&lt;br /&gt;
圖四的樹共有10個node，且這十個node正好填滿Full Binary Tree的前十個位置，則此樹為Complete Binary Tree。  &lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="Complete Binary Tree" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Intro/complBT.png?raw=true" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四：這是一棵Complete Binary Tree。&lt;/strong&gt;
&lt;/center&gt;  &lt;/p&gt;
&lt;p&gt;圖五的樹共有11個node，但是第11個node(K)應該要是第5個node(E)的child，因此，此樹並非Complete Binary Tree。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="Not Complete Binary Tree" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/BinaryTree_fig/Intro/non_complBT.png?raw=true" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五：這不是一棵Complete Binary Tree。&lt;/strong&gt;
&lt;/center&gt;
&lt;/br&gt; &lt;/p&gt;
&lt;p&gt;&lt;a name="application"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;學習Binary Tree的未來出路&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;如果有家長擔心小孩子學了Binary Tree之後對未來的出路沒有幫助，這裡有&lt;a href="http://stackoverflow.com/questions/2130416/what-are-the-applications-of-binary-trees"&gt;網路神人在StackOverFlow&lt;/a&gt;開示，以下簡單翻譯幾項Binary Tree的應用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Binary Search Tree(BST)：在某些資料經常要增加、刪除的應用中，BST常用來做搜尋，例如許多程式語言的Library中的&lt;code&gt;map&lt;/code&gt;和&lt;code&gt;set&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;Binary Space Partition：應用於幾乎所有的3D電玩遊戲以決定哪些物件需要rendered(呈現)。&lt;/li&gt;
&lt;li&gt;Binary Tries：應用於大多數high-bandwidth router(高頻寬路由器)以儲存router-tables。&lt;/li&gt;
&lt;li&gt;Heaps：用以實現高效率的priority queues(優先權佇列)，許多作業系統用來安排工作程序。&lt;/li&gt;
&lt;li&gt;Huffman Coding Tree：例如.jpeg、.mp3等壓縮技術皆使用Huffman編碼。(在一顆20MB的硬碟要價新台幣一萬元的時代，壓縮技術就是救世主。)  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以及其他應用(記得點進連結瞻仰大神網友風範)。&lt;br /&gt;
大致可以體會到Binary Tree是許多進階應用的基礎，學會了幾乎是治病強身。&lt;br /&gt;
接下來將會介紹Binary Tree(以及往後主題)中最基本的操作：traversal(尋訪)，顧名思義，就是如何在樹中移動，有了traversal之後再進一步探討search(搜尋)、insertion(新增node)、deletion(刪除node)、sorting(排序)會更加容易。&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;
&lt;a name="ref"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;參考資料&lt;/strong&gt;：&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Binary_tree"&gt;Wikipedia：Binary tree&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376"&gt;Fundamentals of Data Structures in C++&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/2130416/what-are-the-applications-of-binary-trees"&gt;StackOverFlow：What are the applications of binary trees?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name="tree_series"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;Tree系列文章&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/treeshu-introjian-jie.html"&gt;Tree(樹): Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-introjian-jie.html"&gt;Binary Tree: Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-traversalxun-fang.html"&gt;Binary Tree: Traversal(尋訪)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-jian-li-yi-ke-binary-tree.html"&gt;Binary Tree: 建立一棵Binary Tree&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-introjian-jie.html"&gt;Binary Search Tree: Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-searchsou-xun-zi-liao-insertxin-zeng-zi-liao.html"&gt;Binary Search Tree: Search(搜尋資料)、Insert(新增資料)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-sortpai-xu-deleteshan-chu-zi-liao.html"&gt;Binary Search Tree: Sort(排序)、Delete(刪除資料)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-introjian-jie.html"&gt;Red Black Tree: Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-rotationxuan-zhuan.html"&gt;Red Black Tree: Rotation(旋轉)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-insertxin-zeng-zi-liao-yu-fixupxiu-zheng.html"&gt;Red Black Tree: Insert(新增資料)與Fixup(修正)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-deleteshan-chu-zi-liao-yu-fixupxiu-zheng.html"&gt;Red Black Tree: Delete(刪除資料)與Fixup(修正)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="C++"></category><category term="Binary Tree(二元樹)"></category><category term="Intro"></category></entry><entry><title>Tree(樹): Intro(簡介)</title><link href="http://alrightchiu.github.io/SecondRound/treeshu-introjian-jie.html" rel="alternate"></link><updated>2015-12-19T20:27:00+08:00</updated><author><name>Chiu CC</name></author><id>tag:alrightchiu.github.io,2015-12-19:SecondRound/treeshu-introjian-jie.html</id><summary type="html">&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;先備知識與注意事項&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;若熟悉Linked List(連結串列)將會更容易理解樹：Linked list是一維的線性結構(不是往前、就是往後)，而樹(與圖)則推廣成多維的結構。&lt;br /&gt;
&lt;/br&gt;
&lt;center&gt;&lt;img alt="linkedlist" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/Tree_fig/linked_list_size.png?raw=true" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖一：A、B、C、D稱為node(節點)，用以代表資料(data)、狀態(state)。&lt;br /&gt;
連結各個node之間的連結(link)稱為edge，可能是單方向，或者雙向。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;   &lt;/p&gt;
&lt;p&gt;另外則是用詞翻譯的選擇，由於許多名詞時常被設置為程式碼的變數名稱，而且翻譯後將造成理解上的斷層(如node/vertex(節點)、edge(邊緣？)、parent(父還是母？)、child(孩子？)、ancestor(祖先？)、sibling(手足？兄弟姐妹？)...)，所以決定將此類用詞視為專有名詞，不做翻譯。&lt;br /&gt;
文句中將出現中英夾雜的情形，敬請見諒。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.youtube.com/watch?v=u1ZB_rGFyeU"&gt;OK Go&lt;/a&gt;.  &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#example"&gt;隨處可見的Tree(樹)&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="#essence"&gt;那麼，樹最根本的特徵是什麼？&lt;/a&gt;   &lt;/li&gt;
&lt;li&gt;&lt;a href="#tree_not_tree"&gt;還有哪些結構是樹？&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="#element"&gt;用以描述一棵樹的元素&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="#definition"&gt;樹的定義&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="#code"&gt;程式碼&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="#set"&gt;集合關係&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="#ref"&gt;參考資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#tree_series"&gt;Tree系列文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name="example"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;隨處可見的Tree(樹)&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Tree(樹)&lt;/strong&gt;是用以描述具有&lt;strong&gt;階層結構&lt;/strong&gt;(hierarchical structure)的問題的首選，階層結構意味著明確的先後次序，例如，若要印出ABC三個字母的所有排列組合(permutation)，直覺反射的圖像會是：  &lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;br /&gt;
&lt;img alt="fig1.a" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/Tree_fig/abc_permu_size.png?raw=true" /&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;
&lt;img alt="fig1.b" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/Tree_fig/abc_permu_vertical_size.png?raw=true" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖二：ABC字母排列組合。&lt;br /&gt;
視R為樹根(root)，每一個選擇狀態視為node，此即為樹的結構。&lt;/strong&gt;
&lt;/center&gt;
&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;圖二的邏輯為：從起點(R)開始，先決定第一個字母，再依序決定第二、第三個字母，並且，在每一次選擇字母時，可能有不止一個可供選擇的字母。最後一共走出六條路徑，得到六種排列組合，而且這六種排列方式只能經由一種唯一的選擇方式(唯一的路徑)產生。若將起點(R)視為樹根(root)，每一個字母選擇的狀態(例如：A、C、BC、CAB)都視為一個node，這樣的結構便能夠視為一棵樹。  &lt;/p&gt;
&lt;p&gt;另外如一本書的目錄、族譜、官僚企業的職位關係，甚至是更廣義的「從家門口為起點尋找方圓一公里以內的便利商店」都能夠建立出樹的模型。&lt;br /&gt;
&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="essence"&gt;&lt;/a&gt; &lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;那麼，樹最根本的特徵是什麼？&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;以族譜為例，若包龍星是宋世傑的爸爸，那麼包龍星就絕對不能同時又是宋世傑的兒子。圖三以node與edge描述此關係，並定義箭頭是從父指向子，則包龍星指向宋世傑的箭頭表示包為父、宋為子，而宋世傑指向包龍星的箭頭表示宋為父、包為子，這一個箭頭即違反了最初「包龍星是宋世傑的爸爸」的命題，此即稱為cycle，也就是著名的「雞生蛋」與「蛋生雞」。  &lt;/p&gt;
&lt;p&gt;而樹的最根本特徵就是：&lt;strong&gt;在樹的結構裡，只有一個root(樹根)，並且不存在cycle&lt;/strong&gt;。
此特徵將衍生出另外兩項等價的性質：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;在樹中若要從root尋找特定node，一定只存在一條路徑(path)。&lt;/strong&gt;  &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;每個node只會有一個parent。&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;/br&gt; 
&lt;center&gt;
&lt;img alt="cycle" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/Tree_fig/cycle_size.png?raw=true" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三：包龍星若是宋世傑的parent(父)，又同時為其child(子)，即形成cycle。&lt;/strong&gt;
&lt;/center&gt;
&lt;/br&gt; &lt;/p&gt;
&lt;p&gt;&lt;a name="tree_not_tree"&gt;&lt;/a&gt; &lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;還有哪些結構是樹？&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;(若不是樹，皆稱為圖(graph)。)&lt;/p&gt;
&lt;p&gt;下列四種結構中，a、b可以視為樹，而c、d則否：
&lt;/br&gt;
&lt;center&gt;&lt;img alt="fig2.a" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/Tree_fig/is_Tree_a_size.png?raw=true" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三.a：若樹的node只有指向left subtree(左子樹)與right subtree(右子樹)時，又稱為Binary Tree(二元樹)。&lt;/strong&gt;&lt;br /&gt;
&lt;/br&gt; 
&lt;img alt="fig2.b" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/Tree_fig/is_Tree_b_size.png?raw=true" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三.b：若樹退化成Linked list(連結串列)，仍滿足樹的定義。&lt;/strong&gt;  &lt;br /&gt;
&lt;/br&gt;
&lt;img alt="fig2.c" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/Tree_fig/is_Not_Tree_c_size.png?raw=true" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三.c：在F出現cycle；C-&amp;gt;B-&amp;gt;D-&amp;gt;E出現undirected cycle，詳見Graph theory(圖論)。後者等價於：D有兩個parent node。&lt;/strong&gt;&lt;br /&gt;
&lt;/br&gt;
&lt;img alt="fig2.d" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/Tree_fig/is_Not_Tree_d_size.png?raw=true" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖三.d：一棵樹只能有一個root(樹根)。此圖像又稱為Forest(樹林)。&lt;/strong&gt;
&lt;/center&gt;
&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="element"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;用以描述一棵樹的元素&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="fig3" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/Tree_fig/general_Tree.png?raw=true" /&gt;   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖四：這是一棵普通的樹。&lt;/strong&gt;&lt;br /&gt;
&lt;/center&gt;  &lt;/p&gt;
&lt;p&gt;配合圖四，以下將介紹在樹中常見的元素，可以用來計算時間複雜度(time complexity)、與同好交流感情，好處不勝枚舉。   &lt;/p&gt;
&lt;p&gt;針對&lt;strong&gt;node / vertex&lt;/strong&gt;：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;degree(分歧度)&lt;/strong&gt;：一個node擁有的subtree(子樹)的個數。例如：A的degree為3，F的degree為2，N的degree為0。  &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;root(樹根)&lt;/strong&gt;：樹中最上層的node，也是唯一一個其parent為&lt;strong&gt;NULL&lt;/strong&gt;的node。圖四中，A即為root。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;leaf&lt;/strong&gt;：沒有child/subtree的node稱為leaf node。圖四中，G、H、J、K、L、M、N皆為leaf node。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;external node&lt;/strong&gt;：沒有child的node。因此，leaf node與external node同義。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;internal node&lt;/strong&gt;：至少有一個child的node，稱為internal node。圖四中，A、B、C、D、E、F、I皆為internal node。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;針對&lt;strong&gt;樹&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;parent&lt;/strong&gt; &amp;lt;--&amp;gt; &lt;strong&gt;child&lt;/strong&gt;：圖四中，A為C的parent，C為A的child；E為K的parent，K為E的child。若以pointer說明，被指向者(pointed)為child，指向者(point to)為parent。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;siblings&lt;/strong&gt;：擁有相同parent的node們，互相稱兄道弟。例如：B、C、D共同的parent為A。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;descendant(子嗣)&lt;/strong&gt;：圖四中，站在A，所有能夠以「尋找child」的方式找到的node，皆稱為A的descendant，因此整棵樹除了A以外皆為A的descendant。站在F，能夠以「parent指向child」找到的node有L、M，則稱L、M為F的descendant。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ancestor(祖先)&lt;/strong&gt;：圖四中，站在K，所有能夠以「尋找parent」的方式找到的node，皆稱為K的ancestor，因此，E、B、A皆為K的ancestor。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;path(路徑)&lt;/strong&gt;：由descendant與ancestor關係連結成的edge，例如A-B-E-K、A-C-F-N。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;level&lt;/strong&gt;：定義root的level為1，其餘node的level為其parent的level加一。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;height of node&lt;/strong&gt;：某一node與其最長path上之descendant leaf node之間的edge數。例如F的height為1，D的height為2，leaf node的height為0。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;height of tree&lt;/strong&gt;：樹的height即為root的height，圖四中，樹的height為A的height，等於3。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;depth&lt;/strong&gt;：某一node與root之間的edge數。例如，F的depth為2，L的depth為3。&lt;br /&gt;
&lt;/br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name="definition"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;定義&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;以下列出兩種互相等價的Tree(樹)的定義：&lt;br /&gt;
(根據以上範例說明，再配合樹的定義，還不飛上天？)&lt;/p&gt;
&lt;p&gt;A. &lt;strong&gt;Tree(樹)&lt;/strong&gt;是由一個或多個節點所組成的有限集合，並且滿足：  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;存在且只有一個稱為&lt;code&gt;root&lt;/code&gt;(樹根)的節點；&lt;/li&gt;
&lt;li&gt;其餘的節點可以分割成任意正整數個(包含零個)互斥(disjoint)的集合：&lt;span class="math"&gt;\(T_1、...、T_n\)&lt;/span&gt;，其中每一個集合也都滿足樹的定義，這些集合又稱為這棵樹的&lt;strong&gt;subtree(子樹)&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;B. &lt;strong&gt;Tree(樹)&lt;/strong&gt;是由一個或多個nodes/vertices以及edge所組成，而且沒有cycle的集合(set)。  &lt;/p&gt;
&lt;p&gt;在圖三(d)中，曾出現&lt;strong&gt;Forest(樹林)&lt;/strong&gt;，其定義很直觀：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由&lt;span class="math"&gt;\(n\geq 0\)&lt;/span&gt;棵彼此互斥(disjoint)的Tree(樹)所形成的集合(Set)，即稱為Forest(樹林)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="forest" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/Tree_fig/forest_.png?raw=true" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖五：Forest(樹林)由多個Tree(樹)所組成，可以用來表示互斥集合(disjoint set)。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name="code"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;程式碼&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;實務上，要以程式碼實作一棵樹，常用的手法為：先以class TreeNode(或是struct)定義出每顆node能夠指向多少subtree、攜帶哪些資料形態，再以另一個class Tree表示整棵樹，並以root作為樹的存取點：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// C++ code&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Tree&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;leftchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;        &lt;span class="c1"&gt;// 以下表示每一個node有四個pointer指向child&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;rightchild&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;whatever&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;works&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;data1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                  &lt;span class="c1"&gt;// node所攜帶的info&lt;/span&gt;
    &lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="n"&gt;data2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;...&lt;/span&gt;
    &lt;span class="k"&gt;friend&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Tree&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Tree&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;             &lt;span class="c1"&gt;// 以root作為存取整棵樹的起點&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;a name="set"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;集合關係&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;本篇介紹的Tree(樹)位居承先啟後的戰略位置，圖六展示了與Tree(樹)有關的資料結構的集合關係圖：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;img alt="fig4" src="https://github.com/alrightchiu/SecondRound/blob/master/content/Algorithms%20and%20Data%20Structures/Tree%20series/Tree_fig/Set_Graph_Tree_size.png?raw=true" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;圖六：與Tree(樹)相關的資料結構之集合關係。&lt;/strong&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;本篇介紹的Tree(樹)並沒有限制child/ subtree的個數，理論上可以有多到超過記憶體空間的child node。&lt;br /&gt;
然而在實務上，較常使用每個node至多只有兩個child的樹，稱為&lt;a href="(http://alrightchiu.github.io/SecondRound/binary-tree-introjian-jie.html)"&gt;&lt;strong&gt;Binary Tree&lt;/strong&gt;(二元樹)&lt;/a&gt;。&lt;br /&gt;
從Binary Tree再增加「鍵值大小規則」，即得到&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-introjian-jie.html"&gt;&lt;strong&gt;Binary Search Tree&lt;/strong&gt;(BST，二元搜尋樹)&lt;/a&gt;。&lt;br /&gt;
以BST為基礎，在每個node上添加顏色(紅與黑)用以平衡樹的height，以減短搜尋時間，此種樹稱為&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-introjian-jie.html"&gt;&lt;strong&gt;Red Black Tree&lt;/strong&gt;(RBT，紅黑樹)&lt;/a&gt;。&lt;br /&gt;
另一個方向，若打破「不能存在cycle」的限制，則從樹推廣至&lt;a href="http://alrightchiu.github.io/SecondRound/grpah-introjian-jie.html"&gt;&lt;strong&gt;圖(Graph)&lt;/strong&gt;&lt;/a&gt;。  &lt;/p&gt;
&lt;p&gt;在接下來的文章將先以縮小集合的方向依序介紹：Binary Tree、BST、RBT，再進入Graph(圖)這個更複雜的主題。&lt;/p&gt;
&lt;p&gt;&lt;a name="ref"&gt;&lt;/a&gt;
&lt;/br&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;參考資料&lt;/strong&gt;：&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Tree_%28data_structure%29"&gt;Wikipedia：Tree(data structure)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.amazon.com/Fundamentals-Data-Structures-Ellis-Horowitz/dp/0929306376"&gt;Fundamentals of Data Structures in C++&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://program-lover.blogspot.tw/2008/12/tree.html"&gt;Infinite Loop：【演算】樹 - Tree&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://zh.wikipedia.org/wiki/%E4%B9%9D%E5%93%81%E8%8A%9D%E9%BA%BB%E5%AE%98"&gt;Wikipedia：九品芝麻官&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://zh.wikipedia.org/wiki/%E5%AF%A9%E6%AD%BB%E5%AE%98_%281992%E5%B9%B4%E9%9B%BB%E5%BD%B1%29"&gt;Wikipedia：威龍闖天關&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name="tree_series"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;Tree系列文章&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/treeshu-introjian-jie.html"&gt;Tree(樹): Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-introjian-jie.html"&gt;Binary Tree: Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-traversalxun-fang.html"&gt;Binary Tree: Traversal(尋訪)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-tree-jian-li-yi-ke-binary-tree.html"&gt;Binary Tree: 建立一棵Binary Tree&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-introjian-jie.html"&gt;Binary Search Tree: Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-searchsou-xun-zi-liao-insertxin-zeng-zi-liao.html"&gt;Binary Search Tree: Search(搜尋資料)、Insert(新增資料)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/binary-search-tree-sortpai-xu-deleteshan-chu-zi-liao.html"&gt;Binary Search Tree: Sort(排序)、Delete(刪除資料)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-introjian-jie.html"&gt;Red Black Tree: Intro(簡介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-rotationxuan-zhuan.html"&gt;Red Black Tree: Rotation(旋轉)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-insertxin-zeng-zi-liao-yu-fixupxiu-zheng.html"&gt;Red Black Tree: Insert(新增資料)與Fixup(修正)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://alrightchiu.github.io/SecondRound/red-black-tree-deleteshan-chu-zi-liao-yu-fixupxiu-zheng.html"&gt;Red Black Tree: Delete(刪除資料)與Fixup(修正)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><category term="C++"></category><category term="Intro"></category></entry></feed>